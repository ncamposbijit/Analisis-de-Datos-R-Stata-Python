[{"path":"index.html","id":"introducción","chapter":"1 Introducción","heading":"1 Introducción","text":"Estas notas están diseñadas para quienes buscan una introducción al análisis de datos en Stata.Se han estructurado como notas de clases, lo que significa que se espera un progreso secuencial lo largo de las sesiones. Sin embargo, aquellos con conocimientos previos más específicos podrán encontrar útiles secciones individuales, como es el caso particular de las notas sobre Stata. El curso de Stata es de nivel avanzado y se centra en el diseño de programas, el trabajo con matrices en Stata y técnicas avanzadas de replicación.Estas notas de clase han evolucionado con el tiempo y continuarán haciéndolo. Han sido enriquecidas gracias las contribuciones de varias personas. Quisiera agradecer especialmente Diego Menares, Catalina Buzio por sus valiosos aportes y observaciones. Sin su ayuda, estas notas serían lo que son hoy. Agradezco especialmente Benjamin Pinto, quien ayudo traspasando las notas este formato.Adicionalmente, estas notas se han basado en una variedad de materiales públicos. lo largo del libro, se señalan las referencias bibliográficas pertinentes y se ofrecen recursos gratuitos para aquellos que deseen ampliar o profundizar sus conocimientos. En muchos casos, los ejemplos provienen de este material complementario. Siempre citamos las fuentes adecuadamente, con el objetivo de respetar la autoría original y facilitar el acceso recursos para los lectores de este libro.Para sugerencias de secciones, dudas o recomendaciones, dudes en escribirme ncamposbijit@gmail.com.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"análisis-de-datos-con-stata","chapter":"2 Análisis de datos con Stata","heading":"2 Análisis de datos con Stata","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"buenas-prácticas-de-programación-y-visualización","chapter":"2 Análisis de datos con Stata","heading":"2.1 Buenas prácticas de programación y visualización","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"introducción-1","chapter":"2 Análisis de datos con Stata","heading":"2.1.1 Introducción","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"programación-defensiva","chapter":"2 Análisis de datos con Stata","heading":"2.1.1.1 Programación defensiva","text":"Las personas somos malas escribiendo códigosEsta sección esta basada en los trabajos y recursos publicados por Nick Eubank.La filosofía de escribir un código esta motivada por el hecho de que las personas somos malas escribiendo códigos.Si queremos evitar errores es suficiente con ser cuidadoso()Es necesario diseñar estrategias que tomen en cuenta el hecho de que vamos cometer errores al escribir un código.Tener buenas estrategias es más relevante cuando existe trabajo colaborativo, que puede amplificar los errores.En esta sección revisaremos cuatro ``buenas practicas’’ de programación. Estas practicas son solo aplicables Stata, más bien son guías generales para escribir códigos en cualquier lenguaje.Usar testeos o pruebas.duplicar información.transcribir información, siempre exportarla.Usar un estilo correcto.Con estos elementos podremos:Minimizar las oportunidades de generar errores al codificar.Maximizar la probabilidad de que cuando se cometa un error (lo que ocurrirá!) se pueda detectar con mayor facilidad.¿Necesito entender estos principios? testearon la reproducibilidad de 67 artículos publicados. Todos con alguna sección empírica. Encuentran que:Solo 29 artículos fueron totalmente replicables.29 artículos tenían problemas al tratar 9 poseen datos incorrectos o errores de codificación. indican que Chang y Li utilizan una versión poco estricta de replicabilidad.¿Qué podemos aprender de esta historia?Todos y todas tienen problemas para codificar.Hoy el trabajo es colaborativo. También tienes que confiar en los demás.Hay cosas que se pueden resolver con ser cuidadoso() al codificar. ¿Si los datos están mal?Reproducibilidad y replicabilidad son claves. Buenas referencias se encuentran en la página de Julia Schulte-Cloos.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"practica-i-escribir-pruebas","chapter":"2 Análisis de datos con Stata","heading":"2.1.1.2 Practica I: escribir pruebas","text":"¿Qué es escribir pruebas?Nick Eubank indica que si el tuviese que elegir solo una practica elegiría agregar pruebas o tests los códigos.¿Qué es una prueba?Son afirmaciones que tienen como respuesta un valor lógico.Buscan chequear una condición particular, en caso de que se cumpla esta condición, la ejecución se detiene.¿Por qué agregar estos chequeos, si yo siempre chequeo o reviso mis códigos?Test se ejecutan cada vez que corres tu códigoLa mayoría testea la primera vez que escribe un código.Si hay una entrega el testeo disminuye rápidamente.Si ya ha pasado algún tiempo. Únicamente ejecuto el código y espero los resultados. Entender un código (incluso el que uno() misma escribió es difícil).Un error que se comete en una de las múltiples ediciones del código pueda ser detectado con facilidad al testear.Genera el hábito de chequear permanentemente un costo razonableLa mayoría se para chequear los datos cuando detecta algún error o bien sospecha que existe un problema.Si nos acostumbramos escribir pruebas al final de los códigos o bien cada vez que se hagan cierto tipo de operaciones (ej. siempre después de unir bases de datos), iremos generando el hábito de chequear constantemente, pero sin sobre-invertir en revisiones posteriores.Ayuda detectar problemas rápidamenteSe donde esta el error. Puedo corregirlo rápidamente.Esto es especialmente importante en Stata dado que nos indica en que linea del código se produjo el error. % Chequear bien esto.Escribir pruebas ayuda detectar más problemas de los previstosLos errores de un código se manifiestan de múltiples formas y muchas veces son consecuencia de errores anteriores.Por ejemplo…Si tengo valores duplicados mi estadística descriptiva estará mala.El problema surge de darle un tratamiento correcto los valores duplicados. surge de algún problema en el código que genera la estadística descriptiva.Ejemplo 1: Para escribir pruebas en Stata utilizaremos el comando |assert|. Notar que este comando detiene la ejecución del código cuando la condición se cumple.Testear si la base de datos tiene 100 observaciones:Testear si la variable tasa_desempleo toma valores razonables:Testear si la variable edad es siempre positiva:Ejercicio 3.1.1:Instrucciones:Descargar carpeta ejercicios - Clase 1Abrir ejercicios_clase1.y fijar directorio de trabajo en la carpeta descargada.Preguntas:La base de datos World Development Indicator (WDI) tiene observaciones duplicadas. Escriba un test que falle cuando existen valores duplicados.Los países en la base de datos Polity deberían ser un subconjunto de los países que están en la base WDI. Escriba un test que falle debido este problema.¿Cuando escribir tests?Después de juntar bases: Siempre incluir test después de utilizar un merge.Después manipulaciones complejas de datos: Si piensas que fue difícil, incluye un test.Después de eliminar observaciones: Siempre incluir test después de utilizar un drop.Regla general siempre que te veas ti misma(o) revisando o chequeando algún segmento de código interactivamente escribe un test.","code":"count \nassert `r(N)' == 100assert tasa_desempleo| > 0 & tasa_desempleo| < 100edad > 0"},{"path":"análisis-de-datos-con-stata.html","id":"practica-ii-no-duplicar-información","chapter":"2 Análisis de datos con Stata","heading":"2.1.1.3 Practica II: no duplicar información","text":"Todo en un solo sitioInformación debe estar expresada una sola vez en un código.Si la información esta en muchas partes en el código, tendrás que buscar todos esos lugares.Veamos un ejemplo…Imaginemos que quiero eliminar todas las observaciones que toman un valor mayor un cierto límite.Lo anterior funciona… ¿Cual es el problema entonces?Imaginemos que queremos cambiar el límite de 110 100. Del modo en que esta escrito, vamos tener que hacer cambios 3 veces!Si estas restricciones se encuentran en distintas partes de tú código, se puede inducir un error.Ejemplo 2: Para evitar el problema anterior, es mejor escribir:De esta forma, en caso de decidir cambiar la restricción, solo tendrás que hacer un cambio. Minimizando la posibilidad de cometer un error.Ejercicio 3.1.2:Todas las regresiones que se encuentran en el código tienen la misma base, es decir, el mismo conjunto de variables que se repite.La idea es consolidar la base con el fin de evitar duplicación de información.Con este fin, agregar population como control en todas las regresiones. Nuevamente, dupliques información.","code":"drop if var1 > 110 \ndrop if var2 > 110 \ndrop if var3 > 110 local lim = 110 \n    drop if var1 > `lim'\n    drop if var2 > `lim' \n    drop if var3 > `lim' "},{"path":"análisis-de-datos-con-stata.html","id":"practica-iii-no-transcribir-exportar-información","chapter":"2 Análisis de datos con Stata","heading":"2.1.1.4 Practica III: no transcribir, exportar información","text":"Nunca transcribirNunca se debe transcribir resultados. Todo debe ser exportado de forma tal que pueda ser actualizado automáticamente.cumplir con esta practica es una importante fuente de errores:Errores de transcripción: Si equivoco en el décimo decimal es tan grave, si cambio un signo si lo es.Problemas para actualizar: Es probable que al actualizar un código (como sucede usualmente en cualquier proyecto), olvidemos traspasar los resultados.¿Como evitar este problema?\nPara usuarios de \\(\\LaTeX\\) cada resultado debe ser guardado en archivos .tex.\nHacer esto solo con las tablas (ej. putexcel). También hacerlo con cualquier estadística que aparezca en el texto.\nGenerar el número que se desea citar. Convertirlo string y guardarlo (ej. midato.tex). Llamarlo con \\input{midato.tex}.\nPara usuarios de Word es un poco más complejo. Veremos que se puede hacer en la Clase 6.\nTambién veremos Stata Markdown.\nPara usuarios de \\(\\LaTeX\\) cada resultado debe ser guardado en archivos .tex.Hacer esto solo con las tablas (ej. putexcel). También hacerlo con cualquier estadística que aparezca en el texto.Generar el número que se desea citar. Convertirlo string y guardarlo (ej. midato.tex). Llamarlo con \\input{midato.tex}.Para usuarios de Word es un poco más complejo. Veremos que se puede hacer en la Clase 6.También veremos Stata Markdown.Ejemplo 3:Importar \\(\\LaTeX\\): \\input{nombredelarchivo.tex}Ejercicio 3.1.3:Calcula el promedio de literacy_rate y guárdalo en una macro local. Generar un formato tal que solo tenga dos decimales. Guarda el valor como string en un archivo .tex en la misma carpeta.","code":"eststo clear\neststo: reg polity gdp_per_cap\neststo: reg polity gdp_per_cap under5_mortality\nesttab using nombredelarchivo.tex, replace ///\n       title(\"Mis estimaciones\")"},{"path":"análisis-de-datos-con-stata.html","id":"practica-iv-estilo-importa","chapter":"2 Análisis de datos con Stata","heading":"2.1.1.5 Practica IV: estilo importa","text":"Algunos comentarios sobre estiloEstilo se refiere la estética del código ni al orden (para bien o para mal!).Tiene que ver con la facilidad con el que este se puede leer. El objetivo final es siempre poder detectar errores.Tres aspectos son claves:\nUtilizar espacios. Usar espacios siempre después de utilizar un operador. Por ejemplo:\nUtilizar espacios. Usar espacios siempre después de utilizar un operador. Por ejemplo:Con criterio…Usar variables que sean informativas en si mismas. escribir var1, si puedes escribir: tasa_desempleo. Requiere más trabajo, pero facilita la lectura. Agregar unidades también facilita la lectura (labels).Usar variables que sean informativas en si mismas. escribir var1, si puedes escribir: tasa_desempleo. Requiere más trabajo, pero facilita la lectura. Agregar unidades también facilita la lectura (labels).Escribir comentarios\nEjercicio para explicar en pocas palabras lo que se ha hecho.\nExiste un equilibrio entre parsimonia y calidad del comentario.\nEstablecer el objetivo del comentario claramente es muy importante.\nEscribir comentariosEjercicio para explicar en pocas palabras lo que se ha hecho.Existe un equilibrio entre parsimonia y calidad del comentario.Establecer el objetivo del comentario claramente es muy importante.hay una regla para escribir comentarios\nUtilizar imperativo si lo tiene que corregir otra persona (ej. modifica parámetros aquí, fija directorio).\nDebe incluir suficiente contexto para que alguien que trabaje directamente en eso entienda que se debe hacer.\nLos comentarios largos deben explicar secciones de código. Importante escribir el código por bloques.\nLa brevedad debe afectar nunca la comprensión. Esto también aplica para los comandos (ejemplo de Michael Shill).\nhay una regla para escribir comentariosUtilizar imperativo si lo tiene que corregir otra persona (ej. modifica parámetros aquí, fija directorio).Debe incluir suficiente contexto para que alguien que trabaje directamente en eso entienda que se debe hacer.Los comentarios largos deben explicar secciones de código. Importante escribir el código por bloques.La brevedad debe afectar nunca la comprensión. Esto también aplica para los comandos (ejemplo de Michael Shill).","code":"gen var1=var2+var3      /// Mal\ngen var1 = var2 + var3  /// Bienhours + minutes / 60 + seconds / 3600 \nhours + minutes/60 + seconds/3600summarize var1\nsum var1\nsu var1"},{"path":"análisis-de-datos-con-stata.html","id":"estilo-de-codificación-en-stata","chapter":"2 Análisis de datos con Stata","heading":"2.1.2 Estilo de codificación en Stata","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"más-allá-del-orden","chapter":"2 Análisis de datos con Stata","heading":"2.1.2.1 Más allá del orden","text":"Un buen estilo es seguir una estrategiaRevisaremos un poco más sobre estilo en base dos referencias adicionales: y de una guía confeccionada por Michael Stepner.Los códigos tienen distintas audiencias. La primera es tu computadora. Si tu computadora entiende tú código es el peor de los mundos.Una de las audiencias más importantes son tus colaboradores y colaboradoras. Si ellos/lo entienden. El problema es tuyo en primer lugar.hay un solo buen estilo. hay una guía que pueda sustituir experiencia o estrategias ya probadas de trabajo de equipo.Lo importante es y utilizarlas en la medida de que sea positivo para el producto final.Ahora veremos algunas estrategias y buenas practicas que pueden ayudar mejorar el estilo de codificación individual y de tu equipo.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"códigos-cortos","chapter":"2 Análisis de datos con Stata","heading":"2.1.2.2 Códigos cortos","text":"Ningún segmento de código debiese ser mayor 100 - 150 carácteres.Códigos largos, debiesen ser escritos de forma más pequeña como funciones (Clase 4).Si tienes dificultades para reducir un código estos estándares, es probable que tengas que pensar en como estructurarlo de mejor forma.Cada segmento de código o funciones debiesen tener un propósito claro e intuitivo para lectores experimentados en el lenguaje de programación que se este utilizando.- files cortos y con focoTodo -file debe tener un propósito que pueda ser explicado en una oración. De hecho, hay que hacerlo. En el preámbulo.Un proyecto debe tener varios -files con las siguientes características.\nCortos: Debes ser capaz de leer un -file completo en poco minutos y entender el objetivo. Una buena regla es que sean más largos de 250 - 350 lineas. es estricta esta regla. Hay ocasiones que se justifican códigos más largos. %Lo importante es claridad. sacrificarla nunca.\nAutocontenidos: Cada -file interactúa con otros solo través de los archivos que carga y de los que guarda.\nEnfocados: Un -file cumple un propósito determinado. Cada parte se debe entender como un paso intuitivo para lograr ese propósito.\nCortos: Debes ser capaz de leer un -file completo en poco minutos y entender el objetivo. Una buena regla es que sean más largos de 250 - 350 lineas. es estricta esta regla. Hay ocasiones que se justifican códigos más largos. %Lo importante es claridad. sacrificarla nunca.Autocontenidos: Cada -file interactúa con otros solo través de los archivos que carga y de los que guarda.Enfocados: Un -file cumple un propósito determinado. Cada parte se debe entender como un paso intuitivo para lograr ese propósito.Funciones clarasUn lector debe saber exactamente cuales son los inputs de las funciones.Las funciones debiesen declarar explicitamente inputs y outputs. Solo deben funcionar en variables locales.Las funciones deben trabajar solo en el conjunto de datos para el cual están diseñadas. Por ejemplo: parametros regresión.Usar variables globales rara vez.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"nombres-descriptivos","chapter":"2 Análisis de datos con Stata","heading":"2.1.2.3 Nombres Descriptivos","text":"Nombres adecuados remplazan comentarios y hacen del código un archivo auto contenido. * Utilizar nombres completos. Abreviaciones solo en el caso de estar seguro que cualquier lector puede entenderlo sin ambigüedad.Si se utilizan abreviaciones. Ser consistente. Utilizar siempre las mismas lo largo del código.Cuando se pueda ser suficientemente claro en un nombre, utilizar si o si para dar una descripción (ej. agregar unidad de medida).labels especifican información. (ej, edad con el label edad al 31 de enero es más informativa que edad y más corto que edad_31enero.utilizar nombres en dos (o más) archivos que expliciten porque son diferentes. Por ejemplo: version_final.y version_final_ahorasiquesi..Los nombres pueden ser más cortos cuando se utilicen con frecuencia o el objeto este inmediatamente después. Por ejemplo:Mejor escrito sería:ser tacaño() al nombrar variables, archivos, carpetas.Probablemente lo escribas solo una vez. ahorres espacio. Siempre pensar en la claridad.Para el caso de una figura:\nc_1.pdf es un pesimo nombre.\ncorrelaciones.pdf es un mal nombre.\nT1_CORRELACIONES_INGRESO_MORTALIDAD.PDF es un mejor nombre.\nc_1.pdf es un pesimo nombre.correlaciones.pdf es un mal nombre.T1_CORRELACIONES_INGRESO_MORTALIDAD.PDF es un mejor nombre.Para el caso de una carpeta:\ndatos/brutos/interregional es un mal nombre.\ndatos/brutos/Estimaciones Censo Interregional 2010 - 2021 es un buen nombre.\ndatos/brutos/interregional es un mal nombre.datos/brutos/Estimaciones Censo Interregional 2010 - 2021 es un buen nombre.Estos nombres nos permiten pensar en el flujo del proyecto sin tener que mirar los códigos.","code":"beta_mco = (educacion' * educacion)^(-1) * ///\n           (educacion' * log_salarios)X = educacion\nY = log_salarios\nbeta_educ_salarios = (X'*X)^(-1)*(X'*Y) "},{"path":"análisis-de-datos-con-stata.html","id":"ojo-con-el-álgebra","chapter":"2 Análisis de datos con Stata","heading":"2.1.2.4 Ojo con el álgebra","text":"Separa el álgebra en partes.Más largo, pero mucho más entendible:","code":"gen pib_percapita_real = ///\n    (cons + ggob + export - import - impuestos)* 10^6 ///\n    /(indice_precios * poblacion_miles * 1000)gen pib_millones_nominal = ///\n    (cons + ggob + export - import - impuestos)\ngen pib_total_real = pib_millones_nominal * 10^6 ///\n    / indice_precios\ngen pop_total = poblacion_miles * 1000\ngen pib_percapita_real = pib_total_real / pob_total "},{"path":"análisis-de-datos-con-stata.html","id":"consistencia","chapter":"2 Análisis de datos con Stata","heading":"2.1.2.5 Consistencia","text":"Ser consistentes\n* Hay cosas de estilo que son solo un tema de gusto. Por ejemplo, hay quienes escriben nivel_empleo_anual y otras que escribe NivelEmpleoAnual.\n* importa la elección de un estilo u otro. Lo que importa es que todas y todos los miembros del equipo utilicen la misma convención.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"chequear-errores","chapter":"2 Análisis de datos con Stata","heading":"2.1.2.6 Chequear errores","text":"Hemos aprendido que es importante escribir pruebas o testeos. Especialmente relevante después de operaciones complicadas o pegado de bases de datos.Stata en algunas ocasiones indica los errores que se comenten, sin la necesidad de colocar estas pruebas. Por ejemplo:Stata retorna el siguiente error:Normalmente el error da suficiente información. pesar de lo anterior, en algunas circunstancias, es tan claro saber cual es el error. Cuando ustedes se hayan encontrado con un error, que les fue fácil descifrar, ** tienen que escribir un comentario que lo indique**. Facilitara mucho el trabajo colaborativo.","code":"gen string x = \"hola\"\ngen y = x^2type mismatch \nr(109);"},{"path":"análisis-de-datos-con-stata.html","id":"separar-tipos-de-códigos","chapter":"2 Análisis de datos con Stata","heading":"2.1.2.7 Separar tipos de códigos","text":"Separar códigos lentos de los rápidosCódigos lentos que rara vez se piensan ejecutar idealmente debiesen estar separados de los códigos rápidos que se quieren ejecutar múltiples ocasiones.Evito tener que ejecutar un código lento cada vez que necesito actualizar algún resultado.Este criterio cambia en caso de que todos los códigos sean rápidos.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"automatización","chapter":"2 Análisis de datos con Stata","heading":"2.1.2.8 Automatización","text":"Todo lo que se pueda automatizar debe ser automatizado.Nunca hacer trabajo que vaya obtener resultados de forma interactiva. Lo interactivo es siempre para inspeccionar.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"abstracción","chapter":"2 Análisis de datos con Stata","heading":"2.1.2.9 Abstracción","text":"Abstraer para eliminar pasos redundantes.Abstraer con fines de hacer códigos más claros. por otras razones.Abstracción es esencial para escribir un buen código por al menos dos razones:\nAl eliminar la redundancia se reducen las posibilidades de cometer errores.\nAumenta la claridad. Para cualquier lector será más facil leer un código redundante.\nAl eliminar la redundancia se reducen las posibilidades de cometer errores.Aumenta la claridad. Para cualquier lector será más facil leer un código redundante.Ejemplo 4: Supongamos que queremos ver la correlación espacial del consumo de papas fritas. Queremos testear si el consumo per-capita de papas fritas esta correlacionado con el consumo promedio percapita de las otras comunas de la misma región.Primero tenemos que calcular el consumo per-capita del resto:Ahora podemos ver si existe correlación. ¿Pero si queremos cambiar el nivel de agregación? Tal vez si existe correlación, pero nivel de área metropolitana. Copiemos el código de nuevo y calculemos esto.Noten que hay un error. Se nos olvido remplazar región por metroarea. Este error se puede propagar si seguimos haciendo operaciones.Una alternativa al copiar y pega es escribir una función con propósito general que calcule la variable que deseamos bajo distintos parámetros.Con el programa podemos escribir los bloques de código anteriores como:Hemos escrito la función de forma totalmente general. Podemos cambiar el nivel de agregación sin inducir errores.","code":"egen total_pc_papitas = total(pc_papitas), by(region)\negen total_obs = count(pc_papitas), by(region)\ngen consumo_papitas_resto_pc = ///\n(total_pc_papitas - pc_papitas)/(total_obs - 1)egen total_pc_papitas = total(pc_papitas), by(metroarea)\negen total_obs = count(pc_papitas), by(region)\ngen consumo_papitas_restometro_pc = ///\n(total_pc_papitas - pc_papitas)/(total_obs - 1)program consumo_papitas_resto \n    syntax, invar(varname) outvar(name) byvar(varname)\n    tempvar tot_invar count_invar \n    egen `tot_invar' = total(`invar'), by(`byvar')\n    egen `count_invar' = count('invar'), by('byvar') \n    gen `outvar' = (`tot_invar' - `invar') ///\n    / (`count_invar' - 1) \nend * Caso 1 \nconsumo_papitas_resto, invar(pc_papitas) ///\noutvar(consumo_papitas_resto_pc) byvar(region)\n\n* Caso 2\nconsumo_papitas_resto, invar(pc_papitas)  ///\noutvar(consumo_papitas_restometro_pc) byvar(metroarea)"},{"path":"análisis-de-datos-con-stata.html","id":"documentación-y-comentarios","chapter":"2 Análisis de datos con Stata","heading":"2.1.2.10 Documentación y comentarios","text":"escribas documentación que vas mantener.Códigos deben ser autoexplicativos.Imaginemos queremos estimar una elasticidad de demanda para hacer un análisis de bienestar.Problema: código contradice comentario. Cuando tenemos dos fuentes o más fuentes que informan sobre el mismo objeto, es probable que estas se puedan contradecir. El problema de inconsistencia interna es especialmente importante para documentación, comentarios, notas, etc.Para evitar este problema es necesario mantener los comentarios al día tal como se hace con los códigos.Hacer esto es costoso. Mantener un código extenso al mismo tiempo que una larga documentación es sencillo.Dado esta restricción, es importante .Volviendo al ejemplo. ¿Como le decimos al lector del código debe tener una elasticidad de 2 y de 3?Ejemplo de un código auto-explicativo:Menos comentarios que el anterior. Sin números mágicos. Pero es más informativo e interno consistentemente dado que puedo cambiar algunos de los parámetros sin modificar el resultado. Comentarios sirven en su justa medida: es imposible desprender del mismo código sin saber la tabla.","code":"* Elasticidad = Cambio porcentual en la cantidad ç\n   / Cambio Porcentual en precio\n* Elasticidad = -0,4 / 0,2 = -2\n* Mirar Informe 1, Tabla 2A.\n    calcular_perdida_bienestar, elasticidad(3)* Mirar Informe 1: Tabla 2A. \n  local cambio_porcentual_cantidad = -0,4\n  local cambio_porcentual_precio = 0,2 \n  local elasticidad = `cambio_porcentual_cantidad' ///\n  / `cambio_porcentual_precio'\n  calcular_perdida_bienestar, elasticidad(`elasticidad') "},{"path":"análisis-de-datos-con-stata.html","id":"identificadores-únicos","chapter":"2 Análisis de datos con Stata","heading":"2.1.2.11 Identificadores únicos","text":"Bases de datos con Identificadores únicosID permiten saber la unidad de observación (hogar, empresas, lugares, etc).Conocer ID únicos es esencial para entender los datos. Indican que es lo que describen los datos.También nos sirven para entender como juntar estos datos con otras fuentes de información.Dos reglas que siempre tener en cuenta:\ntienen que existir observaciones duplicadas que tengan el mismo ID único.\nLos ID pueden tener missings.\ntienen que existir observaciones duplicadas que tengan el mismo ID único.Los ID pueden tener missings.Una forma de verificar estos dos hechos es utilizando el comando isid. Este comando chequea si las variables especificadas identifican únicamente las observaciones. Si esto ocurre arrojara el siguiente mensaje:Si encuentro plausible que alguna variable tenga missing puedo colocar la opción missok.","code":"variable does not uniquely identify the observations"},{"path":"análisis-de-datos-con-stata.html","id":"no-ser-repetitivo","chapter":"2 Análisis de datos con Stata","heading":"2.1.2.12 No ser repetitivo","text":"Hemos hablado de evitar ser repetitivo. ¿Cuándo hacerlo? Repetir en una operación simple con dos categorías es razonable.Si tengo que operar 15 veces, mejor hacerlo iterativamente:Si involucra múltiples operaciones. pesar de que solo existan dos categorías, es mejor hacerlo iterativo.Un ejemplo de convención para evitar ser repetitivos:Cuando necesites cambiar solo una cosa en el código utilizar un loop. foreach y forvalues iteran por el mismo código múltiples veces, cambiando el valor de una variable local cada vez.Cuando necesites cambiar múltiples cosas dentro de un código, define un programa dentro del -file utilizando program. De este modo tu podrás especificar más de un argumento.Cuando necesites repetir un código en múltiples .files, pueden definir un programa en un ado-file, guardarlo y llamarlo cuando lo necesites. Es importante que el código agregue automáticamente la ruta en donde se encuentran guardados estos programas.Algunas ayudas:\n* Cuando algunas lineas de código necesiten cambiar entre repeticiones utilizar /else y forvalues. Estos iteran por el mismo código múltiples veces, cambiando el valor de una variable local cada vez.\n* Cuando definas programas dentro de un -file, agrega una linea que diga cap program drop <program_name> antes de program define. Automáticamente se eliminará y redefinirá el programa cada vez que ejecutes el código.Mensajes finales sobre estilo de codificaciónHaz las cosas lo más simples posibles para ti (y tu equipo) de hoy y del futuro.confíes tanto en ti de hoy y menos en el del futuro. Es mejor programar defensivamente.Ser consistente en formato, estilo, organización y nombres. Sigue estrategias.Reducir en lo posible pegado y repetición.Testear regularmente.Documentar menudo, estratégicamente, pero mínimamente.","code":"xtile decil_ing_ga = ing if grupo==\"A\", nq(10)\nxtile decil_ing_gb = ing if grupo==\"B\", nq(10)forvalues y = 2001/2015 {\n    xtile decil_ing_`y' = inn if año == `y', nq(10)\n}foreach g in \"A\" \"B\" {\n    assert ingreso >= 0 if grupo == \"`g'\"\n    xtile decil_ingreso_`g' = ingreso /// \n    if grupo==\"`g'\"  & ingreso > 0, nq(10)  \n    replace decil_ingreso_`g' = 0 /// \n    if grupo==\"`g'\"  & ingreso == 0\n    label var decil_ingreso_`g' \"Deciles de ingreso\"\n}"},{"path":"análisis-de-datos-con-stata.html","id":"organización-de-un-proyecto-en-stata","chapter":"2 Análisis de datos con Stata","heading":"2.1.3 Organización de un proyecto en Stata","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"flujo-de-trabajo-en-stata","chapter":"2 Análisis de datos con Stata","heading":"2.1.3.1 Flujo de trabajo en Stata","text":"Hasta el momento uno de los mayores mensajes es adoptar un sistema de organización compartirlo en el equipo y adherirse él. Este debe incluir:Estructuras de directorio.Estilo de codificación.Convenciones para escribir nombres.Convenciones para exportar datos.Hemos visto en detalle (2) y (3). Algunas cosas de (4) (más detalles en Sección 3.6). En esta sección nos enfocaremos en (1). Esta sección se basa en una de las guías de Asjad Nqvi. Muy buenos recursos. Muy recomendado. También revisaremos algunos elementos de ().\n* Un proyecto de análisis de datos contempla: planificar el trabajo, documentar las actividades, crear y verificar variables, generar y presentar análisis estadístico, replicar resultados y archivar.\n* Todo lo anterior es lo que nos referiremos como flujo de trabajo.\n* Un buen flujo de trabajo es esencial para que tu y tus colaboradores() y los interesados en tu trabajo puedan replicarlo.\n* Replicar es clave para generar información confiable y correcta.La administración del flujo de trabajo se hace al inicio de un proyecto. al final. hacerlo así tiene costos en tiempo y posiblemente induzca errores forzados. Veremos algunos aspectos relacionados con la administración de datos y scripts. Nuevamente, más que reglas seguir, lo presentado aquí son una serie de buenas practicas que pueden ayudar mejorar la gestión del trabajo con Stata. La idea de esto es que finalmente podamos dedicarle más y mejor tiempo al análisis de datos., prefacio.. problems due oversights realized consequences things failed .","code":""},{"path":"análisis-de-datos-con-stata.html","id":"organización-de-archivos-y-carpetas","chapter":"2 Análisis de datos con Stata","heading":"2.1.3.2 Organización de archivos y carpetas","text":"¿Les suena familiar?Tener múltiples versiones de un archivo y saber cual es cual.poder encontrar un archivo y pensar que lo borrado.Tu equipo (y tú) saben cual es el informe final. Hay dos archivos que con el nombre archivo final, pero con distinto contenido.Para evitar los problemas anteriores es importante diseñar la estructura de la carpeta de trabajo y comprometerse seguir una alerta.CarpetasTodo se guarda en carpetas. TODO.Estas deben seguir un orden lógico e intuitivo. Como consejo. Colocar números en la carpeta. Al ordenar las carpetas seguirán este orden y el alfabético.tener espacios en el nombre de las carpetas.Nunca utilizar (-) entre nombres de una carpeta. Utilizar (_).Evitar nombrar las carpetas con mayúsculas.Siempre escribir un README.txt. Puede ser tedioso, pero muy necesario. Corto, informativo, que explique el flujo de trabajo y las carpetas. Sugerencia: colocar las rutas.Proyecto muy pequeñoProyecto pequeñoProyecto grandeOtro ejemplo de proyecto. Ejemplo de Es importante generar dos tipos de carpetas para los resultados trabajo y otras que diga compartir.trabajo guarda todos los resultados (ej. tablas, gráficos, documentos) que están siendo trabajados.compartir guarda resultados terminados y listos para compartir en alguna etapa del proyecto. Por ejemplo, cuando se quieran compartir resultados intermedios del proyecto.Dos reglas:Resultados se comparten solo después que los archivos que lo generan pasen la carpeta compartir.Una vez traspasados la carpeta compartir. se modifican. Incluso cuando puedan existir errores.Ayuda garantizar que los resultados que se comparte se puedan replicar. Si encuentras errores o decides cambiar algo cambies los ya posteados. Genera nuevos. Esto también ayuda la replicabilidad: permite saber que cambios existieron durante un proyecto.Un directorio de trabajo estructurado es especialmente importante para proyectos colaborativos donde todo se puede desordenar mas fácilmente. Dos directorios son sugeridos cuando se trabaja de forma colaborativa: correo y otras que diga privados. correo guarda intercambios entre colaboradoras mientras que privados guarda el trabajo propio de cada colaborador(). Otras carpetas que pueden complementar trabajo son porhacer que sea una carpeta que sirva como una lista de tareas poraprender. En cualquier caso, estas carpetas pueden ser parte de privados.Cuando se tengan versiones se pueden utilizar dos modos:v1, v2, v3, etc.Fechas. Si se utilizan estas escribirlo en año/mes/día. De esta forma se ordenara automáticamente desde el último al primero.Cuando versiones anteriores te sean útiles. Borralas! acumules archivos y códigos porque sí. Si por alguna razón deseas dejarlos (ej. necesidad de respaldar lo hecho). Genera una carpeta temporal. Esta puede estar en tú versión personal del proyecto, pero en el archivo final.Master -fileDiferentes -files para diferentes tareas.Separar en secciones y subsecciones. Por ejemplo: Preámbulo, cargar datos, generar variables, figura , Tabla 3, etc.Crear master_do.files cada proyecto o subproyecto debe tener un archivo maestro que ejecute todos los códigos de inicio fin y genere todos los resultados.Cada vez que se termine un proyecto o se obtenga algún resultado es importante ejecutar el master_do.files.Ejemplo de master -file:Rutas de las carpetas:Es importante tener una carpeta principal y referenciar todas las rutas esa dirección.Utilizar siempre / \\textbackslash. Puede causar problemas según el sistema operativo que utilices.Utilizar macros para nombrar las carpetas. Que estos nombres tengan sentido y se relacionen con el flujo de trabajo.Recordar que una variable local guarda información temporalmente mientras que global guarda información permanentemente. Esto último hace de los global algo recomendable de utilizar constantemente. obstante, es útil para los directorios.","code":"  *** Información del proyecto aquí ***\n  *** Información sobre directorios ***\n  *** Ejecutar códigos ***\n  * Generación de datos\n  do ./dofiles/01_datos_v11.do \n  do ./dofiles/02_merge_v2.do \n  * Generación de tablas\n  do ./dofiles/03_tablas_v4.do \n  * Estimación principal\n  do ./dofiles/04_estimaciones_v11.do \n  * Figuras principales\n  do ./dofiles/05_graficos_v11.do    *** Nota 1: Remplazar esta ruta ***\n   global miproyecto \"C://Program Files/Dropbox/miproyecto/\"\n   \n   *** Nota 2: Directorios de subcarpetas ***\n   clear\n   global datosbrutos \"$miproyecto/datos/brutos\"\n   cd \"$datosbrutos\"\n   use datos1.dta, replace "},{"path":"análisis-de-datos-con-stata.html","id":"buenas-practicas-de-visualización","chapter":"2 Análisis de datos con Stata","heading":"2.1.4 Buenas practicas de visualización","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"principios-de-una-buena-visualización-de-datos","chapter":"2 Análisis de datos con Stata","heading":"2.1.4.1 Principios de una buena visualización de datos","text":"Un gráfico mal hecho desinforma, gráficos mal hechos son inefectivos. Comunican mal la información o incluso la distorsionan. Las personas tenemos un procesamiento visual limitado. Existe uno previo e inconsciente y uno posterior consciente. Entender este aspecto es importante si queremos diseñar visualizaciones que sean efectivas.Esta sección esta basada en Economist’s Guide Visualizing Data ().Tres principios básicosMostrar los datos\nEs la parte más importante del gráfico.\nmostrar ni mucho, ni muy poco.\nEs la parte más importante del gráfico.mostrar ni mucho, ni muy poco.Disminuir distractores.\nDisminuir el uso de elementos visuales útiles para entender los datos.\nSímbolos innecesarios, texto, texturas son ejemplos de elementos visuales útiles. * Integrar el texto al gráfico\nEl gráfico debe ser capaz de complementar el texto y al mismo tiempo contener suficiente información para estar sin él.\nDisminuir el uso de elementos visuales útiles para entender los datos.Símbolos innecesarios, texto, texturas son ejemplos de elementos visuales útiles. * Integrar el texto al gráficoEl gráfico debe ser capaz de complementar el texto y al mismo tiempo contener suficiente información para estar sin él.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"siete-gráficos-alternativos","chapter":"2 Análisis de datos con Stata","heading":"2.1.4.2 Siete gráficos alternativos","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"sublime-text","chapter":"2 Análisis de datos con Stata","heading":"2.1.5 Sublime Text","text":"Esta sección esta basada en la página web de Alvaro Carril.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"qué-es-sublime","chapter":"2 Análisis de datos con Stata","heading":"2.1.5.1 ¿Qué es Sublime?","text":"Sublime Text es un editor de códigos gratuito. Este editor permite compilar códigos de distintos lenguajes de programación tales como Stata, Python, R, , entre muchos otros.Sublime Text es un editor de códigos gratuito. Este editor permite compilar códigos de distintos lenguajes de programación tales como Stata, Python, R, , entre muchos otros.Tiene algunas herramientas que facilitan el trabajo de programación tales como atajos (shortcuts) o multicolumnas. Veremos varias en esta sección.\nEs muy útil cuando tienes un proyecto grande con códigos de distintos tipos de lenguaje.\nInstalar SublimeTiene algunas herramientas que facilitan el trabajo de programación tales como atajos (shortcuts) o multicolumnas. Veremos varias en esta sección.\nEs muy útil cuando tienes un proyecto grande con códigos de distintos tipos de lenguaje.\nInstalar SublimeDirígete sublimetext.com. Descarga e instala Sublime Text 4 (ST4) para tu sistema operativo.Dirígete sublimetext.com. Descarga e instala Sublime Text 4 (ST4) para tu sistema operativo.Es esencial que también instales Package Control, que te permite añadir y eliminar fácilmente complementos adicionales. Si esta bien instalado debiese aparecer en preferences.Es esencial que también instales Package Control, que te permite añadir y eliminar fácilmente complementos adicionales. Si esta bien instalado debiese aparecer en preferences.Para installar hay que entrar sublime, apretar ctrl + shift + p.Para installar hay que entrar sublime, apretar ctrl + shift + p.Tipear Install Package Control y presionar enter.Tipear Install Package Control y presionar enter.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"ejecutar-stata-desde-sublime","chapter":"2 Análisis de datos con Stata","heading":"2.1.5.2 Ejecutar Stata desde Sublime","text":"Para WindowsInstalar StataEditor: En ST4 aprete ctrl+shift+p. Escriba install y presione Enter. Ahora busque StataEditor y haga clic en él para instalarlo.Instale Pywin32: repita el proceso anterior pero instalando el complemento Pywin32.Configure StataEditor:En ST4 vaya Preferences -> Package Settings -> StataEditor -> Settings - UsersEn este archivo en blanco debe escribir la ruta de su ejecutable de Stata y la versión que posee.Mi archivo de configuración en Windows se ve así:Registre la biblioteca de automatización de Stata:Vaya al ejecutable de Stata del que ha copiado la ruta (por ejemplo, StataMP-64.exe).Cree un acceso directo en su escritorio.Ahora haga clic con el botón derecho en este nuevo acceso directo y seleccione ``Propiedades”.En el campo ``Destino”, añada /Registro al final (con un espacio precedente). En mi caso es:Aplicar y aceptar los cambios. Apretar sobre el acceso directo el click derecho y ejecutar como administrador. Y listo!Para MacPara instalar el Editor Mejorado de Stata en ST4, inicie la paleta de comandos con Cmd+shift+p, escriba `install\" y presioneEnter`.Ahora busque Stata Improved Editor y haga clic en él para instalarlo.Reinicie ST4 y listo!AutoguardadoSublime permite auto-guardar los códigos.De esta forma hay que preocuparse en casos de que hayas respaldado tu código.Para esto hay que escribir vamos instalar el paquete autosave y adicionalmente vamos agregar ``preferencias”:Codificación colaborativaPara trabajo colaborativo existen editores de códigos que se enfocan en que dos o más personas puedan programar desde sus computadoras.Una buena página es Code ShareMuy útil para pedir ayuda o hacer una revisión final.","code":"{\n  \"stata_path\": \"C:/Program Files/Stata17/StataMP-64.exe\",\n   \"stata_version\": 17,\n}\"C:\\Program Files\\Stata17\\StataMP-64.exe\" /Register``save_on_focus_lost\": true."},{"path":"análisis-de-datos-con-stata.html","id":"programar-do---files-parte-i","chapter":"2 Análisis de datos con Stata","heading":"2.2 Programar do - files (Parte I)","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"programar-en-stata","chapter":"2 Análisis de datos con Stata","heading":"2.2.1 Programar en Stata","text":"Esta sección esta basada en: introduction Stata Programing (), en notas de clase de la profesora Erin Hengel, en Advanced Stata Topics del profesor Alexander C. Lembcke, en Seventy-six Stata tips , en Top 10 ``gotchas” de y en Data Management Using Stata. Practical Handbook de .","code":""},{"path":"análisis-de-datos-con-stata.html","id":"qué-es-programar-en-stata","chapter":"2 Análisis de datos con Stata","heading":"2.2.1.1 ¿Qué es programar en Stata?","text":"Programar en Stata es:Escribir - files: una secuencia de comandos ejecutables través de un archivo ..Escribir los que formalmente en Stata es un programa: un conjunto de comandos que incluyen el comando program. Un programa en Stata se guarda como un ado - file.Escribir lenguaje de programación matricial: denominado mata.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"do---files","chapter":"2 Análisis de datos con Stata","heading":"2.2.1.2 do - files","text":"El uso de -file garantiza la replicabilidad del análisis de datos utilizando Stata. Recordar que un -file puede llamar otros (ej. master .file. La jerarquización de los -file puede ser importante para proyectos grandes o complejos. Es importante evitar trabajar en Stata interactivamente. Únicamente hay que hacerlo para inspeccionar datos (recordar practicas Sección 3.1).","code":""},{"path":"análisis-de-datos-con-stata.html","id":"ado---files","chapter":"2 Análisis de datos con Stata","heading":"2.2.1.3 ado - files","text":"Sirven para crear tus propios en Stata. Una vez que armes tu programa y lo guardes en la carpeta de ado-file puedes utilizarlo como cualquier otro comando de Stata. Por ejemplo, puedes agregar las opciones , range y otras. También puedes escribir un documento de ayuda (help} que explique el programa. Crear tus propios comandos es una muy buena forma de ser más eficiente al trabajar con Stata (recordar Sección 1).Mata para ado-files: Los ado-files pueden realizar tareas más complejas que involucren ejecutar el comando múltiples veces.El lenguaje de programación mata es mucho más rápido que un ado-file.Útil para realizar tareas que sean intensivas computacionalmente.es solo un lenguajes de programación que utiliza matrices. También sirve para tareas que involucran texto o listas.Próximante discutiremos este lenguaje.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"comandos-y-funciones-claves-y-algunos-detalles","chapter":"2 Análisis de datos con Stata","heading":"2.2.2 Comandos y funciones claves (y algunos detalles)}","text":"Revisaremos algunos aspectos necesarios para mejorar la eficiencia al trabajar en Stata.Directorios y uso de profile..Tipos de comandos.Tipos de datos y uso de compress.Uso de capture, preserve y restore.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"directorios","chapter":"2 Análisis de datos con Stata","heading":"2.2.2.1 Directorios","text":"cd y pwd sirven para fijar y conocer mis directorios. Es importante utilizar dobles comillas en los casos en que la ruta del directorio tenga espacios.El comando sysdir provee una lista de los directorios importantes para Stata.El comando update sirve para actualizar los comandos.La carpeta PLUS es el directorio donde se guardan comandos descargados. Si utilizas ssc, se guardara en esta carpeta.PERSONAL para tus propios ado-files.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"profile-do","chapter":"2 Análisis de datos con Stata","heading":"2.2.2.2 Profile do","text":"¿Qué es profile ?Una opción tan conocida es la utilización de profile.doEste archivo se ejecuta cada vez que Stata se inicia. Si tienes uno guardado pasa nada.Este -file permite, por ejemplo, fijar tu directorio de trabajo inicial, cambiar características de los gráficos, generar atajos.También se puede hacer que Stata abra un log-file y lo guarde siempre en el mismo lugar.Cada vez que inicies sesión Stata ira por profile.. Si lo encuentra lo va ejecutar.Stata recomienda guardar profile.en home directory (ver help profilew para ususarios de windows y profilem para Mac).Vamos ver como modificar profile.. En particular:\nAjustes generales.\nEstablecer las características de los gráficos.\nEstablecer atajos\nAbrir, cerrar y guardar un log-file con la fecha.\nAjustes generales.Establecer las características de los gráficos.Establecer atajosAbrir, cerrar y guardar un log-file con la fecha.Ejercicio 3.3.1:InstruccionesDescargar carpeta ejercicios-clase3.Abrir profile.e inspeccionar cada una de las lineas del código.PreguntasAgrega dos elementos alguna sección.Modifica las carpetas según las características de tu computadora.Guarda profile.en el home directory. Ejecutar nuevamente Stata y verificar que el código se ha ejecutado.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"tipos-de-comandos","chapter":"2 Análisis de datos con Stata","heading":"2.2.2.3 Tipos de comandos","text":"Comandos r-class y e-classMuchos comandos en Stata (ej. summarize, correlate, regress) hacen que sea posible utilizar sus resultados una vez que estos son ejecutados.summarize y correlate son comandos r-class. Es decir, comandos que guardan sus resultados en r().regress es un comando e-class. Es decir, comandos que guardan sus resultados en e().return list retorna los valores guardados en r()Su limitación es que solo están disponibles los valores del último comando r-class ejecutado.Los comandos e-class son comandos de estimación. Para verlos ereturn list y para llamarlos individualmente e(nombre). Guardan más información que los de r-class : matrices, vectores y funciones. La información de los comandos e-class sigue estando disponible una vez que utilizamos algún comando r-class`. Aquí una diferencia!Un ejemplo clásico son las estimaciones de regresión lineal.En general cualquier comando de estimación se guarda en esta clase de formato.","code":"* r-class\nsysuse auto.dta, clear \nsummarize mpg \nreturn list \n\nsummarize mpg, detail \nreturn list \ndisplay \"La asimetría de mpg es\" r(skewness) \nsummarize price, detail \nreturn list regress mpg weight length rep78 \ndisplay \"La regresión se estimo para \" e(N) \" observaciones.\" \nereturn list"},{"path":"análisis-de-datos-con-stata.html","id":"tipos-de-datos","chapter":"2 Análisis de datos con Stata","heading":"2.2.2.4 Tipos de datos","text":"numeric y stringLa mayor distinción entre tipos de datos es entre numeric y string.Al trabajar con datos muchas veces es necesario realizar conversiones entre estos dos formatos. Los comandos destring, tostring y encode son útiles para estas tareas (si alguien tiene dudas con alguno escriben).strings pueden soportar un máximo de 244 caracteres con un byte por cada carácter.Por ejemplo, una variable del tipo str20 requiere 20 bytes por observación.Clasificación de los datosPara las variables en formato numeric los tipos de datos son: byte, int, long, float y double.Los tres primeros solo puede almacenar valores enteros. long puede almacenar todos los números de 9 dígitos, pero es limitado para 10 dígitos.float y double pueden almacenar números grandes.asumir que float será aritméticamente exacto. Por ejemplo:¿Como utilizar esto para programar efectivamente en Stata?IDs con muchos dígitos (y caracteres) guardarlos como string. como integers, float o doubles.confiar en test exactos contra una constante con datos en formato float. Utilizar formato double para cualquier serie que necesita ser precisa (ej. suma de los residuos de una regresión).Utiliza integers cuando sea apropiado (ej. variables dicotómicas). Guardar valores como int o byte ayuda utilizar de forma más eficiente el espacio en el disco.compress examina cada variable y determina si estas pueden ser guardadas de forma más eficiente. Utilizarlo.Si se especifican valores iniciales fuera de los rangos permitidos para cada tipo de dato el resultado será un missing.Notar que se genera ninguna alerta de missing cuando este se crea. Esto es distinto para variables que ya existen.Si el valor esta fuera de los rangos permitidos, la variable se guarda en un formato mayor. byte int, int long, float double. En este caso un mensaje aparece.","code":"    display float(16777216)\n        16777216\n    display float(16777217)\n        16777216clear all \nset obs 10 \ngenerate byte var1 = 101\nsummarize var1 clear all\nset obs 10\ngenerate byte var1 = 1\nreplace var1 = 101"},{"path":"análisis-de-datos-con-stata.html","id":"capture-preserve-y-restore","chapter":"2 Análisis de datos con Stata","heading":"2.2.2.5 capture, preserve y restore","text":"Manejando errores: captureSirve para evitar que Stata aborte cuando detecta un error.Bueno para cuando quieres borrar algo que ya se encuentra. Lo malo es que suprime todos los errores y oculta todo lo que puede ir mal.Código crea var1 y var2, luego las elimina incluyendo una variable que existe. Al contrario de lo que se intuye, se borran las variables, dado que hay una variable que existe. La recomendación es siempre utilizar capture con moderación. Puede ser utilizado en bloque para así tener que utilizarlo en cada linea.preserve y restoreAlgunos comandos en Stata remplazan la base actual por una nueva (ej. collapse o contract).Utilizar preserve y restore es útil en estos casos.En caso de que queramos obtener estadística descriptiva agregada y asociarla observaciones podemos utilizar estos comandos.","code":"set obs 10\ngenerate byte var1 = 5\ngenerate byte var2 = 10 \ncapture drop var1 var2 var3 \ndescribe var1 var2sysuse auto.dta, clear\ncapture{\nreg price mpg-trunk\nreg price mpg-weight\nreg price mpg-foreign\n}\nereturn list * Ejemplo con collapse\nsysuse auto.dta, clear\ngenerate lprice = log(price)\npreserve\ncollapse (max) max_lprice=lprice max_mpg=mpg ///\n(iqr) iqr_lprince = lprice iqr_mpg = mpg if !missing(rep78), by(rep78) \nsort rep78 \ntempfile repstats\nsave `repstats'\nrestore \nsort rep78 \nmerge m:1 rep78 using `repstats'\nassert _merge != 2\nsummarize lprice max_lprice max_mpg \n\n* Ejemplo con contract\nsysuse auto.dta, clear\npreserve\ncontract mpg, cfreq(cumfreq) percent(percentage) cpercent(cumpercent)\nsort mpg \ntempfile mpgfreq\nsave `mpgfreq'\nrestore \nsort mpg\nmerge m:1 mpg using `mpgfreq'\nassert _merge != 2\nsummarize _freq cumfreq percentage cumpercent"},{"path":"análisis-de-datos-con-stata.html","id":"missing-values","chapter":"2 Análisis de datos con Stata","heading":"2.2.2.6 Missing values","text":"En general uno utiliza variable !=. para evitar incluir missings.Mejor practica es variable <. para excluir todos los valores en missing. Otra opción es !missing(variable).Los missing están codificados internamente como valores mayores cualquier número. El menor valor de todos los missing es el punto. Al utilizar variable <. es como decir, solo utiliza los números.Como vimos en la Sección 3.1 hay muchos problemas al tratar bien los missings. Este problema se incrementa al momento de trabajar con bases de datos imposibles de inspeccionar. Veremos algunas recomendaciones que pueden ser utiles para evitar estos errores.Los comandos tratan distinto los missingsCualquier función de datos missing será missing.Cuando se calcula un promedio o una desviación estándar solo valores missing son considerados (ej. sum).Algunos comandos en Stata manejan los missing de otras formas. Por ejemplo, las funciones max, min y las funciones para filas de egen: rowmax(), rowmean(), rowmin(), rowsd() y rowtotal() ignoran los missing. Por ejemplo, rowmean(x1,x2,x3) calcula el promedio de las variables y solo retornara missing si todas lo son.Por ejemplo, rowmean(x1,x2,x3) calcula el promedio de las variables y solo retornara missing si todas lo son.collapse (sum) trata los missing como ceros.Calcular un promedio con missingsPromedioSinMissing da como resultado missings. PromedioConMissing considera missings. Es importante tratar de entender como funcionan los missings de los comandos que utilizas.Generar variables considerando missings: Al crear una variable dicotómica, gen y gen byte tratan los missing de formas distintas.sum() considera missing como ceros.max() trata los missing como si estuviesen allí.tabmiss, mvdecode y mvencodeEn ocasiones los missing difieren en notación (ej. al importar datos de otro paquete). Siempre que trabajes con una base de datos nueva es importante recodificar. Notar que todos tienen que ir un punto. Todo depende del origen de los missing.mvdecode y mvencode pueden ser útiles en este tipo de casos.mvdecode permite recodificar valores numéricos como missing. Útil cuando valores son representados como -99, -999.mvencode hace lo inverso. Mapea missing como numéricos.El comando tabmiss inspecciona todas las variables de una base de datos y reporta los missing totales y como fracción del total de observaciones.Ejercicio 3.3.2: InstruccionesAbrir ejercicios-clase3.y ejecute las líneas correspondientes al ejercicio 2.PreguntaCompare las opciones 1, 2 y 3 en relación como tratan los missing. Explique las diferencias entre cada una de estas opciones.generate, replace y missing: Sólo unas pequeños detalles.Opción 1 es la típica. Ojo esta considerando missing. Es necesario agregar & !missing(pop). Escrito de esta forma, si pop es missing, smallpop será cero. Opción 2 es más simple, pero si cualquier valor de pop es missing será evaluado como un cero también. La razón es que los missing en Stata son considerados como números muy grandes para el programa. La Opción 3 soluciona el problema.","code":"clear\nset obs 10 \ngen var1 = rnormal()\ngen var2 = 5 \ngen var3 = .\ngen promedio = (var1 + var2 + var3)/3\negen promedio1 = rowmean(var1 var2 var3)    local N = 500\n    set obs `N'\n    gen indicador = uniform() < .5\n    replace indicador =. if mod(_n, 2) == 0\n    \n    * Si indicador es missing, variable sera missing\n    gen variable_primercaso = 1 if indicador == 1 \n    replace variable_primercaso = 0 if indicador == 0\n    * Si indicador es missing, variable sera cero. \n    gen variable_segundocaso=(indicador==1)\n    \\end{minted}\n    \\end{itemize}    clear all \n    set obs 4 \n    generate byte var1 = cond(mod(_n,2)==1, 1, .)\n    generate byte var1sum = sum(var1)\n    list, noobs  display max(-5,.)clear all \nset seed 1234\nlocal N = 50\nset obs `N'\ngen income = abs(int(rnormal(0,5)))\nassert income >= 0\nreplace income =. if mod(_n, 2) == 0\n* Para ver los missing en variables\ntabmiss \n\n* Transformar un valor númerico a missing\nmvdecode income, mv(2)\n\n* Transformar varios valores númericos a missing.\nmvdecode income, mv(2 5)\n\n* Transformar varios a missing, pero identific ́andolos.\nmvdecode income, mv(3 = .a \\ 6 = .b)\n\n* Missings se cambian de vuelta a su valor original.\nmvencode income, mv(.a = 3 \\ .b = 6)clear \ncd \"$ejercicio3\"\nuse census2c, clear\n\n* Opción 1\ngen smallpop_o1 = 1 if pop<=5000\nreplace smallpop_o1 = 0 if pop>5000\n\n* Opción 2\ngen smallpop_o2 = (pop <= 5000) \n\n* Opcion 3\ngen smallpop_o3 = (pop <= 5000) if !missing(pop)"},{"path":"análisis-de-datos-con-stata.html","id":"string-a-numeric-y-al-revés","chapter":"2 Análisis de datos con Stata","heading":"2.2.2.7 String a numeric y al revés","text":"De string numericSi las variables han sido mal clasificadas como string puedes utilizar la función real().Por ejemplo: generate idpaciente = real(pacienteid).El comando anterior genera missing para todas las observaciones que puedan ser interpretadas como numéricas.Mucho mejor es utilizar destring, replace.Otro caso usual es que tenemos datos en formato string y queremos que tengan un equivalente. El comando encode. es aconsejable utilizar este comando para valores numéricos guardados como string.De numeric stringHay veces en las que se quiere generar un equivalente string valores numéricos.Tres comandos: string() , tostring() y decode().Un ejemplo es querer mantener los 0 que estan al inicio de un código ID.El comando tostring zip, format(\\%05.0f) generate(idstring) genera un string de cinco digitos con los ceros al inicio.decode() sirve para un caso en que tengas un id en numérico, pero que la tengas en string.Strings entre comillas: importa poner las comillas bien.","code":"display \"Este es un string normal\"\n\ndisplay \"Este no es un string con \"comillas\" \"\n\ndisplay `\"Este si es un string con \"comillas\"\"'"},{"path":"análisis-de-datos-con-stata.html","id":"funciones-para-generar-variables","chapter":"2 Análisis de datos con Stata","heading":"2.2.2.8 Funciones para generar variables","text":"generate y replace: función cond()Si quiero que un resultado sea “” si una condición es verdadera y “b” si es falsa.La función cond(x,,b) posee esta capacidad sin la necesidad de utilizar .Las observaciones en Stata estás numeradas desde el 1. _N es el mayor número de observaciones, mientras que el actual es _n. sort (ascendete) y gsort (ascendete o descendente) alteran el orden de las observaciones. Como recomendación eviten generar variables o condiciones que dependan de la posición especifica de una observación.recode para variables discretas: recode crea una nueva variable basada en otra variable.El signo (\\(=\\)) es para indicar valor antiguo valor nuevo. es necesario aplicarlo linea por linea. recode produce un código más eficiente.recode para variables continuas: recode(x,x1,x2,x3,x4,xn) para variables continuas de forma tal de generar intervalos tal que \\(x \\leq x_1 ; x_1 \\leq x \\leq x_2\\) y así sucesivamente. Los resultados son iguales los límites creados.Otros comandos que cumplen una función parecida son floor y ceil(). Ambos sirven para generar un valor entero. El primero para redondear hacia abajo y el otro hacia arriba. floor(x) retorna el entero \\(n\\) tal que \\(n \\leq x < n + 1\\) mientras que ceil(x) es tal que \\(n - 1 < x \\leq n\\).irecode para variables continuas: irecode(x,x1,x2,x3,x4,x_n) es una alternativa para categorizar grupos también. Por ejemplo:Categorizara cada grupo según el intervalo en el que este. Parte del cero!. $x x_1 $, \\(x_1 \\leq x \\leq x_2 \\rightarrow 1\\) y así sucesivamente.Crear cuartiles con xtile: Con xtile podemos querer clasificar las variables según cuantiles (quintiles, deciles, cuartiles, etc).Ejercicio 3.3.3:InstruccionesCargar la base auto.dtaPreguntaGenere una variable que sirva para redondear hacia abajo la variable mpg en en múltiplos de 5, de modo que cualquier valor de 10 14 se redondee 10, cualquier valor de 15 19 15 y así sucesivamente.","code":"* Útil para construir una tabla\ngenerate netmarr2x = cond(marr/divr > 2, 1, 2) \nlabel define netmarr2xc 1 \"marr > 2 divr\" 2 \"marr <= 2 divr\" \nlabel values netmarr2x netmarr2xc \ntabstat pop medage, by(netmarr2x) * Ejemplo 1: uso de gsort\ngsort region -pop \nby region: generate totpop = sum(pop)\n\n* Ejemplo 2: uso de _n y _N\nby region: list region totpop if _n == _N\n\n* Ejemplo 3: sort\ngenerate largepop = 0\nreplace largepop = 1 if pop > 5000 & !missing(pop)\ngen smallpop = (pop <= 5000) if !missing(pop)\ngenerate popsize = smallpop + 2*largepop\nlabel variable popsize \"Population size code\"\nlabel define popsize 1  \"<= 5 million\" 2 \"> 5 million\", modify\nlabel values popsize popsize \nbysort region popsize: egen meanpop2 = mean(pop) * Esta no es una buena opción \nreplace newcode = 5 if oldcode == 2 \nreplace newcode = 8 if oldcode == 3 \nreplace newcode = 12 if inlist(oldcode, 5, 6, 7)\n* Esta si es una buena opción \nrecode oldcode (2 = 5) (3 = 8) (5/7 = 12), gen(newcode) use census2c, clear\ngenerate breaks = recode(medage, 29, 30, 31, 32, 33)use census2c, clear\ngenerate popurbfloor = floor(popurb)\ngenerate popurbceil = ceil(popurb)generate size = irecode(pop, 1000, 4000, 8000, 20000)\nlabel define popsize 0 \"<1m\" 1 \"1-4m\" 2 \"4-8m\" 3 \">8m\" \nlabel values size popsize\ntabstat pop, stat(mean min max) by(size)* Creamos cuartiles para población \nxtile popcuart = pop , nq(4)\ntabstat pop, stat(n mean min max) by(popcuart)"},{"path":"análisis-de-datos-con-stata.html","id":"funciones-de-egen","chapter":"2 Análisis de datos con Stata","heading":"2.2.2.9 Funciones de egen","text":"Todos y todas conocemos algunas de las típicas funciones de egen.Otras funciones son iqr(), kurt(),mad(), mdev(), median(), mode(), pc(), pctile(), rank(), sd(), skwe(), std().egenmoreMenos conocida es la colección de funciones adicionales de egen hechas por Nicholas J. Cox.Estas funciones están contenidas en el comando egenmore.bom() y eom() crean variables de fechas que corresponde al primer y último día de un mes determinado.corr() calcula correlaciones y covarianzas mientras que var() calcular la varianza.semean() calcula la desviación estándar del error de una media.record() permite calcular el valor más alto o más bajo de una serie.rall() y rany() son útiles para el análisis de datos. Evaluan una condición y genera un indicador si todas o alguna observación la cumple.","code":"clear \n* Ejemplo del uso de egen\ngenerate size = irecode(pop, 1000, 4000, 8000, 20000)\nlabel define popsize 0 \"<1m\" 1 \"1-4m\" 2 \"4-8m\" 3 \">8m\" \nlabel values size popsize\nbysort size: egen avgpop = mean(pop)\ngenerate popratio = 100 * pop / avgpop \nformat popratio \\%7.2f\nlist state pop avgpop popratio if size == 0 * Ejemplo 1: Generar variable que tenga la primera palabra de una frase (wordof)\negen firstword = wordof(make),  word(1)\nlist firstword make in  1/15\n\n* Ejemplo 2: Para generar automáticamente valores extremos (outside, 1,5 RIQ)\negen    extrmpg = outside(mpg)\ntab extrmpg,    missingset obs 12\ngen a = 1 in 1 \ngen b = 2 in 2/4\ngen c  = -3  in 5/7\ngen d = 4  in 8/10\ngen e = . in 11/12\negen any = rany(a b c d e) , c(@ > 0 & !missing(@))\negen all = rall(a b c d e) , c(@ > 0 & !missing(@)) "},{"path":"análisis-de-datos-con-stata.html","id":"macros-locales-y-globales","chapter":"2 Análisis de datos con Stata","heading":"2.2.3 Macros locales y globales","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"nombrar-macros","chapter":"2 Análisis de datos con Stata","heading":"2.2.3.1 Nombrar macros","text":"Una macro es un contenedor que puede almacenar números o nombres de variables.Puede ser local o global. La primera es temporal, la segunda .Un ejemplo de variable local es:El primer comando define la macro y sus valores. Para llamar la macro hay que utilizar las comillas (“). local nombre texto \\(\\rightarrow\\) local nombre = text \\(\\rightarrow\\) local nombre = \"text\".Ojo con las rutas:En ocasiones voy querer utilizar una macro dentro de la ruta de una carpeta.Es importante utilizar siempre / o bien \\\\. De otra forma lo reconocerá.Ejercicio 3.3.4: Compare los siguientes comandos y comente las diferencias:display \"Dos mas dos = 2 + 2\"display \"Dos mas dos= 2 + 2’“`Ojo con el signo igual: Algunas veces es bueno colocar un signo \\(=\\) al definir macros. Por ejemplo, cuando redefinimos variables.La primera parte sirve para definir la macro mientras que la segunda sirve para dar cuenta de su valor actual. Al actualizar, ocupen igual.Sin signo igual: En algunas ocasiones queremos escribir una macro dentro de un loop. En estos casos es conveniente evitar el signo igual.El local nuevalista define una macro como string que posee su propio contenido, el valor de contar y el valor del iterador.","code":"local NivelEstres Nada Medio Moderado Severo \ndisplay \"Los niveles de estrés son: `NivelEstres'\"local filename base.dta \nuse \"H:\\ECStata\\`filename'\"\nr(601);\n* Para corregir el error, dos caminos: \nuse \"H:\\ECStata\\\\`filename'\" \nuse \"H:/ECStata/`filename'\"local contador 0\nlocal NivelEstres Nada Medio Moderado Severo \nforeach a of local NivelEstres { \nlocal contador = `contador' + 1 \ndisplay \"Nivel de Estres `contador' : `a'\"\n}local contador 0\nlocal NivelEstres Nada Medio Moderado Severo \nforeach a of local NivelEstres {\nlocal contador = `contador' + 1 \nlocal nuevalista `nuevalista' `contador' 'a' \n} \ndisplay \"`nuevalista'\" "},{"path":"análisis-de-datos-con-stata.html","id":"generar-variables-contadores-y-condiciones-con-macros","chapter":"2 Análisis de datos con Stata","heading":"2.2.3.2 Generar variables, contadores y condiciones con macros","text":"Podemos utilizar macros para renombrar variables.En este fragmento de código, Stata evalúa la expresión 1960 + '' antes de evaluar la macro externa. Por ejemplo, cuando pase por el iterador = 11, el nuevo nombre de la variable será x1971.Resumir condiciones: Podemos utilizar macros para resumir condiciones. Esto es útil para estimar modelos o generar estadística descriptiva.Agrupar en base una condición: Imaginemos que ahora queremos estimar una regresión para todas las compañías de auto que empiezan empiezan con B.La mejor manera de pensar en esto es hacer lo que hace Stata: reemplazar \"ctyname\" por su contenido substr(país,1,1)==\"ctyname’“. Al hacerlo, se convierte ensubstr(país,1,1)==”B”. Si se omiten las comillas dobles, se obtienesubstr(country,1,1)==B`, lo que da lugar un error.Contadores: Las macros también pueden ser útiles para contadores.Muy útil para hacer gráficos o guardar datos en matrices.Utilizar una macro para estimar regresiones: Imaginen que desean estimar regresiones sobre un conjunto de variables donde una parte de este conjunto esta fija y la otra parte es variable.¿Qué ocurre si queremos hacerlo por separado? ¿Uno uno?Lo que ocurre cuando hacemos referencia una macro es que su valor se introduce en ese punto. El uso de una barra invertida en su lugar hace que se introduzca la referencia de la macro, es decir, se sustituirá el valor de add_var sino el término `add_var'. Así que cada vez que llamamos la local rhs el valor actual de el local add_var es sustituido.Ejercicio 3.3.5: InstruccionesCargar la base auto.dtaPreguntasDefina una variable macro llamada control que contenga mpg, rep78 y headroom. Estime una regresión entre price y control para vehículos extranjeros y de nuevo para vehículos domésticos.Defina una variable macro llamada control que contenga mpg, rep78 y headroom. Estime una regresión entre price y control para vehículos extranjeros y de nuevo para vehículos domésticos.Ejecute summarize mpg junto con return list. Defina dos macros display local mean1 r(mean) y local mean2 = r(mean). ¿Son iguales?Ejecute summarize mpg junto con return list. Defina dos macros display local mean1 r(mean) y local mean2 = r(mean). ¿Son iguales?","code":"clear \nforvalues a = 10/20{ \ngen v`a' = rnormal()\n}\n\n* Renombramos variables \nforvalues i = 11/15 { \nrename v`i' x`=1960 + `i''\n}clear \nsysuse auto \nlocal cond \"if foreign==0\"\nlocal varlist \"mpg rep78 trunk weight turn\"\n\n* Estimar la regresión considerando la condicíòn\nreg price `varlist' `cond'local autoname B \nreg price mpg weight if substr(make,1,1)==\"`autoname'\"* Para adelante\nlocal i = 1 \nlocal ++i \ndi `i' \n\n* Para atrás\nlocal i = 1\nlocal --i \ndi `i' local rhs mpg weight\nreg price `rhs' if foreign == 0 \nlocal rhs \"`rhs' headroom trunk\"  \nreg price `rhs' if foreign == 0 local rhs \"mpg weight \\`add_var'\" \nlocal add_var \"headroom\"\nreg price `rhs' if foreign == 0  \nlocal add_var \"trunk\" \nreg price `rhs' if foreign == 0  \nlocal add_var \"turn\" \nreg price `rhs' if foreign == 0  "},{"path":"análisis-de-datos-con-stata.html","id":"globales","chapter":"2 Análisis de datos con Stata","heading":"2.2.3.3 Globales","text":"Crear macros globalesSe crean con el comando global.Útiles para fijar directorios o programas.En otros casos es mejor utilizar local.","code":"* Para generarla \nglobal variable\n\n* En caso de querer llamarla\ndisplay $variable"},{"path":"análisis-de-datos-con-stata.html","id":"funciones-extendidas-de-macros","chapter":"2 Análisis de datos con Stata","heading":"2.2.3.4 Funciones extendidas de macros","text":"¿Qué son las funciones de macros extendidas?Stata también define ciertas macro. Estas se denominan extended macro functions o macros extendidas.En algunos casos contienen información sobre tu sistema operativo, sobre la última estimación que se realizo o sobre la base de datos.El help extended_fcn y la documentación que la acompaña proporcionan una descripción completa de la sintaxis de cada función de macro extendida (hay muchas). Muchas tienen ligeras variaciones de sintaxis entre ellas (por ejemplo, algunas requieren que las macros estén entre comillas dobles; otras lo permiten).Mirar labelsvariable label recupera el nombre asignado una variable.Contar dentro de un localword count y word como funciones de extensión que operan sobre strings.Conocer tipos de datosOjos con las comillas dobles (nuevamente): Algunas veces las macros contienen comillas dobles. Para poder escribirlos sin errores es necesario modificar levemente la forma en que se llama la variable localEjercicio 3.3.6: PreguntasUse una macro extendida para mostrar el tipo de dato (ej. int, float, long,…) de mpg. Revise el help de extended_fcn.Use una macro extendida para retornar el valor del label asociado foreign cuando es igual 1.Use una macro extendida para mostrar solo la primera variable de `controls'.Utilice una función extendida de macros para mostrar todos los archivos de su directorio actual (sugerencia: utilice comillas compuestas cuando muestre los nombres de los archivos).","code":"* La sintaxis general es: \nlocal nombremacro: función macro extendida* Para mirar los labels de trunk\nsysuse auto, clear\nlocal tlab : variable label trunk \ndisplay \"`tlab'\"* Para contar dentro de un local\nlocal NivelEstres Nada Medio Moderado Severo \nlocal wds: word count `NivelEstres' \ndisplay \"Hay `wds' niveles de estres:\"\nforvalues i = 1/`wds' {\nlocal wd: word `i' of `NivelEstres'\ndisplay \"Nivel `i' is `wd'\"\n}* Para conocer tipos de datos\nsysuse auto, clear\nlocal stortype : type make \ndisplay \"`stortype'\"* Con error \nlocal answers yes no \"do not know\" \ndisplay \"`answers'\"\n\n* Sin error \nlocal answers yes no \"do not know\" \ndisplay `\"`answers'\"'"},{"path":"análisis-de-datos-con-stata.html","id":"funciones-de-macro-extendidas-para-listas","chapter":"2 Análisis de datos con Stata","heading":"2.2.3.5 Funciones de macro extendidas para listas","text":"Stata también define ciertas macro para operar sobre listas. Estas funciones permiten combinar listas, buscar elementos dentro de una lista o bien buscar elementos comunes entre dos listas. Conveniente revisar help macrolist para más funciones.Función levelsof: El comando levelsof lista los valores distintos de una variable. Al agregar la opción local(nombremacro) esto se guardara como una macro.","code":"* Sintaxis: \nlocal nombre macro: list función\n\n* Ejemplo de lista\nlocal animales \"gato perro gato loro loro\" \nlocal uniqanimales : list uniq animales \ndisplay \"`uniqanimales'\"* Sintaxis básica\nsysuse auto, clear\nlevelsof rep78 \ndisplay \"`r(levels)'\"\n\n* Sintaxis cuando hay variables categóricas.\nlevelsof foreign, local(levels)\nforeach l of local levels {\ndi \"-> foreign = `: label (foreign) `l''\"\nreg price mpg if foreign == `l'\n}"},{"path":"análisis-de-datos-con-stata.html","id":"manipulación-de-locales-vía-listas-de-macros","chapter":"2 Análisis de datos con Stata","heading":"2.2.3.6 Manipulación de locales vía listas de macros","text":"Listas de macros: Las macro lists permiten obtener el número de elementos de una macro, trabajar con valores duplicados, ordenar elementos. Veremos cuatro aplicaciones:Elementos duplicados.Agregar y remover elementos.Uniones e intersecciones.Ordenar elementos.Elementos duplicados: dups extrae todos los elementos sobrantes.Agregar y remover elementos: Es básicamente pegar elementos de una macro con otra. Definamos dos variables locales: vars y coef y peguémoslos.Para remover tenemos que definir un nuevo local con los elementos que queremos quitar y sustraerlo del original. Supongamos que queremos actualizar el contenido de vars eliminado “y”.Unión de elementos: Podemos pegar todos los elementos diferentes entre dos listas.Noten que los elementos de car fueron pegados. Notar que esto es distinto simplemente pegar macros entre sí.Intersección de elementos: Podemos hacer la intersección entre dos elementos de una lista. Esto corresponde los elementos que pertenecen ambas macros.Noten que en este caso solo car se mantiene.Ordenar elementos: En ocasiones queremos ordenar los elementos de una lista contenida en una macro.Para hacer que los elementos de una macro se ordenen aleatoriamente es conveniente utilizar mata","code":"* Deja solo los unicos\nlocal fib 0 1 1 2 3\nlocal fib_nodups : list uniq fib\ndisplay \"`fib_nodups'\"\n\n* Quita todo los duplicados\nlocal fib 0 1 1 2 3\nlocal fib_dups : list dups fib\ndisplay \"`fib_dups'\"local vars x y z \nlocal coefs a b c \nlocal vars_coefs `vars' `coefs'\ndisplay \"`vars_coefs'\"local not y\nlocal vars : list vars - not\ndisplay \"`vars'\"local A house tree car\nlocal B computer car bike\nlocal all_things : list A | B\ndisplay \"`all_things'\"local A house tree car\nlocal B computer car bike\nlocal common_things : list A & B\ndisplay \"`common_things'\"local names camila camilo pedro paula\nlocal names : list sort names\ndisplay \"`names'\"local nums 1 2 3 4 5\nmata : st_local(\"random_nums\", ///\ninvtokens(jumble(tokens(st_local(\"nums\"))')'))\ndisplay \"`random_nums'\""},{"path":"análisis-de-datos-con-stata.html","id":"creturn","chapter":"2 Análisis de datos con Stata","heading":"2.2.3.7 creturn","text":"Macros con creturnEn algunos casos al utilizar local o global vamos querer fijar algunos parámetros.Para este propósito utilizar creturn. Algunos ejemplos son: c(current_date), c(pwd), c(current_time), c(stata_version), c(pi), c(alpha), c(Wdays).Ejercicio 3.3.7: PreguntasDefine una macro llamada comestibles con peras, manzanas, fresas, yogur, vino y queso en ella. Ponla en orden alfabético.Define una macro llamada unión que contenga los miembros de la macro animales y comestibles y luego utiliza una función de lista extendida de la macro para mostrar el número de palabras que contiene.Ordena unión y muestra la posición de la palabra “vino” utilizando una función de lista extendida de macros.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"programar-do---files-parte-ii","chapter":"2 Análisis de datos con Stata","heading":"2.3 Programar do - files (Parte II)","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"estructuras-de-datos","chapter":"2 Análisis de datos con Stata","heading":"2.3.1 Estructuras de datos","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"escalares","chapter":"2 Análisis de datos con Stata","heading":"2.3.1.1 Escalares","text":"Los escalares pueden contener valores numéricos o strings. Un escalar solo puede contener un valor.La sintaxis para generar un escalar es scalar scalar_name = exp.Para utilizar un escalar en una operación solo es necesario llamarlo por su nombre. Para listar el contenido de todos los escalares scalar list. Para borrar scalar drop scalar_name o si quiero eliminar todo scalar drop _all. Los escalares permiten parametrizar un -file.","code":"quietly: summarize mpg \nscalar mean_mpg = r(mean)\nquietly: summarize rep78\nscalar mean_rep78 = r(mean)\ndisplay \"r(mean) guarda el promedio de rep78: \" r(mean) \ndisplay \"Pero tambien podemos recuperarlo:\" mean_mpguse fem2, clear \nscalar lb1 = 80 \nscalar ub1 = 88 \nscalar lb2 = 89 \nscalar ub2 = 97 \nforvalues i = 1/2 {\ndisplay _n \"IQ\" \"lb`i'\" \"-\" \"ub`i'\" \ntabulate anxiety if inrange(iq, lb`i', ub`i')\n}"},{"path":"análisis-de-datos-con-stata.html","id":"elementos-y-operaciones-con-matrices","chapter":"2 Análisis de datos con Stata","heading":"2.3.1.2 Elementos y operaciones con matrices","text":"Stata puede generar matrices.Las matrices son muy importantes para guardar resultados y exportarlos de forma conveniente. También son útiles para cuando se quieren hacer estimaciones de muchos parámetros y para distintos conjuntos de datos.Operaciones con matrices: Se puede operar con matrices. Por ejemplo, sabemos que \\(b = (X'X)^{-1}X'y\\) y que \\(V = \\sigma^{2}(X'X)^{-1}\\). Si queremos extraer solo la matriz \\(X'y\\) tenemos que operar, calculando \\(\\frac{1}{\\sigma^{2}}V^{-1}b\\).e(b)’ indica la traspuesta, mientras que inv() es para calcular la matriz inversa.Llamar los elementos de una matriz: Se puede acceder los escalares contenidos en las matrices. Por ejemplo, si queremos obtener los elementos de la matriz \\(e(b)\\) tenemos:También podemos utilizar las posiciones de los elementos de la matriz (b[,k)]).","code":"reg weight age age2\nmatrix b = e(b)\nmatrix list b\nmatrix V = e(V)\nmatrix list Vmatrix define b = e(b)' \nmatrix define xty = inv(V) * b /e(rmse)^2\nmatrix list xty display \"The coefficient on weight is: \" _b[weight] \ndisplay \"Its standard error is: \" _se[weight] \n* Valores predichos \ngenerate anxietyhat = _b[_cons] + _b[weight] * weight + /// \n_b[age] * age + _b[age2] * age2"},{"path":"análisis-de-datos-con-stata.html","id":"funciones","chapter":"2 Análisis de datos con Stata","heading":"2.3.1.3 Funciones","text":"Solo disponibles para comandos e-class. Por ejemplo, si estimamos una regresión veremos que la unica función disponible es e(sample).e(sample) nos indica si una determinada observación se utilizó para estimar la regresión. Es decir, es igual uno si una observación estaba en la muestra de estimación y 0 si fue excluida.Ejercicio 3.4.1:Preguntas:Estime una regresión de mpg contra weight length rep78 utilizando base de datos auto, pero solo para los autos extranjeros (foreign == 1).Genere una nueva variable, llamada enmuestra que tome los valores dados por la función e(sample).Utilizando br, observe los valores de enmuestra. ¿Qué observa?Calcule la estadística de mpg solo para las observaciones que fueron incluidas en la regresión.","code":"sysuse auto \nregress mpg weight length rep78\nereturn list"},{"path":"análisis-de-datos-con-stata.html","id":"iteradores","chapter":"2 Análisis de datos con Stata","heading":"2.3.2 Iteradores","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"foreach","chapter":"2 Análisis de datos con Stata","heading":"2.3.2.1 Foreach","text":"foreach y forvalues: forvalues itera sobre una lista de números y foreach recorre los elementos de una macro, o los nombres de las variables de una lista de variables, o los elementos de una lista de números.Hay algunas variaciones en foreach según el tipo de lista. La sintaxis es similar la recien presentada, pero difiere en dos aspectos:se remplaza por .Hay que llamar al identificador.Veamos como iterar sobre una lista de globales y locales.\n\\end{itemize}Veamos como iterar sobre una lista de variables:Veamos como iterar sobre una lista de de nuevas variables:Veamos como iterar sobre una lista de números:","code":"* Foreach\nforeach animal in cats and dogs { \ndisplay \"`animal'\"\n}\n\n* Forvalues \nforvalues i = 1(1)100 { \ngenerate x`i' = runiform()\n}* Sobre locales y globales\nlocal money \"Franc Dollar Lira Pound\" \nforeach currency of local money { \ndisplay \"`currency'\"\n}* Sobre lista de variables\nforeach var of varlist mpg weight-turn { \nquietly summarize `var' summarize `var' if `var' > r(mean)\n}* Sobre lista de nuevas variables\nforeach var of newlist z1-z20 { \ngenerate `var' = runiform()\n}foreach num of numlist 1 4/8 13(2)21 103 { \ndisplay `num'\n}"},{"path":"análisis-de-datos-con-stata.html","id":"combinar-macros-con-iteradores","chapter":"2 Análisis de datos con Stata","heading":"2.3.2.2 Combinar macros con iteradores","text":"foreach y forvalues combinados con macros pueden utilizarse para ahorrarnos mucho trabajo. Podemos generar tun conjunto de locales partir de iteraciones.Como ya hemos visto, el comando levelsof devuelve una lista de todos los valores distintos de una variable categórica y los guarda en la macro r(levels). Esto lo hace en el caso de que nosotros le asignemos un nombre. Podemos utilizar esta lista para los países y años de nuestra muestra para definir dos iteraciones que recorran todos los valores posibles. Para cada valor resumimos la población y definimos una macro local compuesta por el código de país y el año (por ejemplo, USA1990) que toma el valor de la población en ese año para ese país.Una aplicación del forvalues:Utilizando dos forvalues:foreach y recode:Loops anidados: foreach y forvaluesEn estos casos es bueno utilizar espacios para hacer el código más amigable. Ojo que Stata le interesa esto para ejecutar, es solo una cuestión de estilo.También útil para estimar regresiones.Tokenize: Podemos almacenar los elementos de la lista de países en macros numeradas con tokenize.Aquí los nombres de los países se almacenan como valores de las macros numeradas. Debemos referenciar doblemente la macro \\(\\). El contenido de esa macro la primera vez que se pasa por el bucle es el número 1. Para acceder al primer código de país, debemos referenciar la macro \\(`1'\\).","code":"use replicate.dta, replace\nlevelsof cty\nlocal ctries \"`r(levels)'\" \n\nforeach ctr in `ctries' { \n        sum hours_t if cty == \"`ctr'\" \n        local nombre `ctr' = `r(mean)'\n} use gdp4cty, clear \nforvalues i = 1/4 {\ngenerate double lngdp'i' = log(gdp'i')\nsummarize lngdp'i'\n}forvalues y = 1995(2)1999 {\n    forvalues i = 2(2)4 {\n        summarize gdp`i'_`y'\n    }\n}use gdp4cty, clear \nlocal ctycode 111 112 136 134 \nlocal i 0\nforeach c of local ctycode{ \n        local ++i \n        local rc \"`rc' (`i'=`c')\" \n}\ndisplay \"`rc'\"\nrecode cc `rc', gen(newcc)use gdp4cty, clear \nlocal country US UK DE FR \nlocal yrlist 1995 1999 \nforvalues i = 1/4 {\n    local cnaine: word `i' of `country'\n    display \"`cnaine'\"\n    foreach y of local yrlist {\n            rename gdp`i'_`y' gdp`cnaine'_`y'\n    } \n}sysuse auto, clear\nforeach y of varlist mpg rep78 headroom trunk weight length { \n    foreach x of varlist rep78 price displacement gear_ratio foreign { \n    regress `y' `x'\n} use gdp4cty, clear\nlocal country US UK DE FR \nlocal yrlist 1995 1999 \nlocal ncty: word count `country'\ndisplay \"`ncty'\"\ntokenize `country'\nforvalues i = 1/`ncty'{\n    foreach y of local yrlist {\n            rename gdp`i'_`y' gdp``i''_`y'\n        }\n}"},{"path":"análisis-de-datos-con-stata.html","id":"while-loop","chapter":"2 Análisis de datos con Stata","heading":"2.3.2.3 While loop","text":"Realiza la iteración o se repite una lista de comandos mientras la condición sea verdadera. La sintaxis es:¿Cuando es útil? : Cuando este seguro() cuantas veces se realizará la iteración. Notar que si hay convergencia, va iterar infinitamente.También se puede combinar con macros. Es importante utilizar los incrementales:La primera parte define el inicio del contador, mientras que la segunda indica la condición para que sea ejecutado. El local final actualiza (incremental). Si el incremento es unitario podemos utilizar local ++.","code":"while exp { \nhace algo\n}while reldif (nueva, antigua) > 0.001 { \n}local i=1 \nwhile `i'<=5 {\ndisplay \"loop number\" `i' \nlocal i = `i'+1\n}"},{"path":"análisis-de-datos-con-stata.html","id":"branching","chapter":"2 Análisis de datos con Stata","heading":"2.3.2.4 Branching","text":"Hacer una cosa en caso de que alguna condición sea cierta y otra cosa en caso de que sea falsa. La sintaxis básica es:Ejercicio 3.4.2:PreguntasDefina una macro llamada mimacro que sea igual un número entero aleatorio entre 1 y 99.Utilizando y else muestre un mensaje que diga si es par o impar.","code":"if algo es verdadero { \nhacer esto\n} else {\nhacer lo contrario\n}"},{"path":"análisis-de-datos-con-stata.html","id":"aplicaciones","chapter":"2 Análisis de datos con Stata","heading":"2.3.2.5 Aplicaciones","text":"Seguir secuencias especiales: creturn posee varias constantes y valores los que se puede acceder. Por ejemplo:c(filename) nombre del último nombre del archivo guardado.c(alpha/ALPHA) lista de letras minúsculas/mayusculas.c(Mons) lista de nombres de los meses abreviados.c(Months) lista de los nombres de los meses abreviados.c(Wdays) lista de los dias de la semana abreviados tres caracteres.c(Weekdays) lista de los días de la semana abreviados.Con un iterador es posible aplicar estas listas para agregar labels. Suponga que tenemos valores de 1 12 que representan meses.","code":"clear all\nset obs 12\ngen month = _n \ntokenize `c(Months)' \nforvalues i = 1/12 {\n    label define monthlab `i' \"``i''\" , modify \n                   }\nlabel val month monthlab"},{"path":"análisis-de-datos-con-stata.html","id":"monitorear-un-loop","chapter":"2 Análisis de datos con Stata","heading":"2.3.2.6 Monitorear un loop","text":"Ejemplo proveniente de (Stata tip 41). Cualquier loop puede ser modificado para que muestre su progreso con el comando _dots. Esto es importante para cuando se requieren hacer procesos que toman varias horas y es necesario monitorear avances.El primer comando _dots establece las lineas. Titulo y número de repeticiones son opcionales. reps solo acepta enteros como argumento. _dots ‘’ 0 tiene dos elementos:El primer argumento es el número de repetición, que registra el número de intentos en curso. En el ejemplo, esta automáticamente determinado por el loop.El segundo argumento es el código de retorno, el cual indica el tipo de símbolo. En el ejemplo tenemos un 0.Los códigos de retorno alternativos producen una “s” (-1), “.” (), “x” roja (1), una “e” (2), una “n” (3) o un “?” (cualquier otro valor).Ejemplo numérico: La idea es definir una macro local para que actue como un contador.Contar repeticiones:El número de repeticiones en rep es calculado por _dots. Es necesario contar manualmente las variables e introducir el número.Esto lo vamos hacer con la ayuda de una función de macro extendida sizeof.unab permite ingresar una lista de variable abreviada y expandirla, de forma tal de que la pueda contar.Un ejemplo más complejo es:Se ejecuta hasta que logre 70 aciertos. En este ejemplo artificial, cada iteración tiene un éxito aleatorio con una probabilidad del 80%. Los éxitos se indican con un punto (.) y los fracasos con una x.","code":"_dots 0, title(Loop ejecutando) reps(75) \nforvalues i = 1/75 { \n_dots ‘i’ 0\n}\n\n----+--- 1 ---+--- 2 ---+--- 3 ---+--- 4 ---+--- 5\n..................................................    50\n.........................sysuse auto\n_dots 0, reps(10)\nforeach var of varlist price - gear_ratio {\n  sum `var', d\n  local i = `i'+1\n  _dots `i' 0\n}sysuse auto\nunab myvars : price - gear_ratio\nlocal N : list sizeof myvars\n_dots 0, reps(`N')\nforeach var of varlist `myvars' {\n  ...\n  local i = `i'+1\n  _dots `i' 0\n}noisily _dots 0, title(Looping until 70 successes...) \nlocal rep 1 \nlocal nsuccess 0 \nwhile ‘nsuccess’ < 70 { \nlocal fail = uniform() < .2 \nlocal nsuccess = ‘nsuccess’ + (‘fail’ == 0) \nnoisily _dots ‘rep++’ ‘fail’\n}"},{"path":"análisis-de-datos-con-stata.html","id":"manejo-de-bases-de-datos","chapter":"2 Análisis de datos con Stata","heading":"2.3.3 Manejo de bases de datos","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"prefijo-by","chapter":"2 Análisis de datos con Stata","heading":"2.3.3.1 Prefijo: by","text":"Los prefijos en Stata ejecutan tareas repetitivas sin la necesidad de especificar el rango de valores sobre la tarea que es ejecutada. Un prefijo muy conocido es . Por ejemplo, varlist [, sort]: command. command es repetido para cada valor de la variable. Es más, repeticiones siguen el orden de la variable sea string o numeric.","code":"use bpress, clear\nbysort sex agegrp: summarize bp "},{"path":"análisis-de-datos-con-stata.html","id":"prefijo-xi","chapter":"2 Análisis de datos con Stata","heading":"2.3.3.2 Prefijo: xi","text":"xi es útil para cuando queremos producir un variable indicador para las observaciones que son distintas entre si.El ejemplo le esta diciendo Stata que genere variables indicadores. Esto es muy útil para reducir los códigos.Interpretando prefijo xi: xi es comúnmente utilizado como un prefijo. La principal ventaja es cuando existen múltiples interacciones entre las variables.","code":"xi i.agegrp* Caso 1: incluye indicadores de ambas variables.\nxi: regress bp i.agegrp i.sex\n\n* Caso 2: incluye además interacciones entre ellas.\nxi: regress bp i.agegrp*i.sex\n\n* Caso 3: Interactúa una variable continua con una discreta.\nxi: regress bp i.agegrp*bp0\n\n* Caso 4: Incluye solo interacciones con variable continua (además de principal). \nxi: regress bp i.agegrp|bp0 "},{"path":"análisis-de-datos-con-stata.html","id":"prefijo-statsby","chapter":"2 Análisis de datos con Stata","heading":"2.3.3.3 Prefijo: statsby","text":"statsby permite ampliar . Este último tiene la limitación de permitir únicamente un comando.Se produce una nueva base de datos con una observación por grupo con los estadísticos incorporados. Útil para calcular estadística descriptiva.","code":"statsby mean=r(mean) sd=r(sd) n=r(N), by(agegrp sex): summarize bp"},{"path":"análisis-de-datos-con-stata.html","id":"prefijo-rolling","chapter":"2 Análisis de datos con Stata","heading":"2.3.3.4 Prefijo: rolling","text":"statsby permite obtener estadísticas para sub-muestras que se traslapan. rolling sirve para sub-muestras traslapadas. Por ejemplo, al trabajar con series de tiempo se quiere calcular estadísticas para datos que están traslapados (el. calcular una media móvil).Vamos calcular medias y medianas utilizando una ventana de 90 días:start y end indican el inicio y fin de la ventana.","code":"use ibm, clear \nrolling mean=r(mean) median=r(p50), window(90): summarize spx, d \ntsset end \ntsline mean"},{"path":"análisis-de-datos-con-stata.html","id":"merge-y-append","chapter":"2 Análisis de datos con Stata","heading":"2.3.3.5 Merge y Append","text":"Recomendaciones para utilizar mergeEspecifique siempre el tipo de fusión (1:1, m:1 o 1:m). Si se especifica el tipo de fusión, se llama la versión antigua y robusta de la fusión.Nunca haga fusiones de muchos muchos (m:m), o al menos, sólo hágalo cuando tenga una muy buena razón.Incluya siempre la opción assert() para indicar qué patrón de observaciones coincidentes espera.Incluya siempre la opción keep() para indicar qué observaciones deben conservarse del conjunto de datos fusionados.Siempre que sea posible, incluya la opción keepusing() y enumere explícitamente qué variables pretende añadir al conjunto de datos; puede incluir esta opción incluso cuando mantenga todas las variables de los datos utilizados.Utilice la opción nogen, excepto cuando piense utilizar explícitamente la variable _merge más adelante. Nunca debe guardar un conjunto de datos que tenga _merge; si necesita esta variable más adelante, dele un nombre más informativo.Con respecto especificar _merge y assert notar que:Append con ciudado:El comando append es muy útil para manejos de bases de datos. Una precaución común es con respecto al nombre de las variables. Si dos variables (ej. PRECIO y precio) difieren, se generaran dos columnas nuevas al hacer el append en vez de una.Una precaución un poco menos conocida guarda relación con el tipo de variables. ¿Qué ocurre si dos variables se llaman igual, pero estan guardadas en formatos distintos?En este caso, el orden en el cual se combine la base de datos va importar y puede generar diferencias al momento de pegar datos. Esto es especialmente importante cuando una variable esta guardada en numérico en una base de datos y en string en la otra.Veamos un ejemplo con la base auto.dta. Vamos crear dos bases de datos según la procedencia de los autos y ejecutar el comando append.Notar que append genera el siguiente mensaje: foreign str 7 using data byt byte now. Noten que el contenido de la variable string se ha perdido: 22 casos son ahora missing.¿Qué ocurre si hacemos el proceso al revés? Vamos cargar autos extranjeros y le vamos pegar autos domésticos:El formato de los datos de la primer base de datos manda.\n* utilizar force sin cuidado.\n* Con distintos tipos de datos, append es sensible al orden en que los archivos son pegados. Tener cuidado y revisar consistencia en los datos. Hacer test aquí tambíen es importante.","code":"     merge ..., assert(match master) keep(match)\n\n     * Es equivalente a: \n     merge ...\n     assert _merge==1 | _merge==3\n     keep if _merge==3sysuse auto \ndrop if foreign\nsave autodom \nsysuse auto \ndrop if !foreign \nrename foreign nondom \ngenerate str foreign = \"foreign\" if nondom \nsave autofor\n\nuse autdom \nappend using autofor \ndescribe foreign use autfor \nappend using autodom, force\ndescribe foreign \ncodebook foreign"},{"path":"análisis-de-datos-con-stata.html","id":"programar-ado---files-parte-i","chapter":"2 Análisis de datos con Stata","heading":"2.4 Programar ado - files (Parte I)","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"escribir-programas-en-stata","chapter":"2 Análisis de datos con Stata","heading":"2.4.1 Escribir programas en Stata","text":"En esta sección aprenderemos escribir nuestros propios comandos en Stata. Escribir programas en Stata tiene muchas ventajas relacionadas con las buenas practicas que vimos en la Sección 1.Vamos utilizar program para escribir los programas. Es posible equipar cualquier comando con las opciones típicas usuales (ej. o inrange. Discutiremos mayormente programas del tipo r-class y algunos comentarios con respecto los del tipo e-class.¿Por qué debiese escribir mis propios programas en Stata? Automatizar procesos que se ejecutan frecuentemente y donde los resultados dependen de algún tipo de heterogeneidad.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"por-qué-escribir-programas-abstracción","chapter":"2 Análisis de datos con Stata","heading":"2.4.2 ¿Por qué escribir programas?: Abstracción","text":"Abstraer para eliminar pasos redundantes.Abstraer con fines de hacer códigos más claros. por otras razones.Abstracción es esencial para escribir un buen código por al menos dos razones:\nAl eliminar la redundancia se reducen las posibilidades de cometer errores.\nAumenta la claridad. Para cualquier lector será más facil leer un código redundante.\nAl eliminar la redundancia se reducen las posibilidades de cometer errores.Aumenta la claridad. Para cualquier lector será más facil leer un código redundante.Veamos un ejemplo: Supongamos que queremos ver la correlación espacial del consumo de papas fritas. Queremos testear si el consumo per-capita de papas fritas esta correlacionado con el consumo promedio percapita de las otras comunas de la misma región. Primero tenemos que calcular el consumo per-capita del resto:Ahora podemos ver si existe correlación. ¿Pero si queremos cambiar el nivel de agregación? Tal vez si existe correlación, pero nivel de área metropolitana. Copiemos el código de nuevo y calculemos esto.Noten que hay un error. Se nos olvido remplazar región por metroarea. Este error se puede propagar si seguimos haciendo operaciones. Una alternativa al copiar y pegar es escribir una función con propósito general que calcule la variable que deseamos bajo distintos parámetros.Con el programa podemos escribir los bloques de código anteriores como:Hemos escrito la función de forma totalmente general. Podemos cambiar el nivel de agregación sin inducir errores.Estructura de un programa en Stata: La sintaxis más simple es:Cuando se ha definido un programa con program, este se vuelve indistinguible de cualquier otro comando de Stata. Es importante estar seguros() de que estoy escribiendo el mismo nombre que otro programa. Para garantizar lo anterior, es bueno utilizar el comando .Guardar un programa en StataHay dos lugares en donde puedes guardar tus ado-files.Cuando se ha definido un programa con program, este se vuelve indistinguible de cualquier otro comando de Stata.En el directorio de trabajo del proyecto.Se puede hacer una carpeta nueva en la sección de códigos que indique los programas.Otra opción es guardarlo en el directorio Personal de Stata. Para entrar escriban personal en la consola.Nombrar un programa en StataEs posible darle cualquier nombre un programa mientras sea un nombre que ya es utilizado por Stata.Si por ejemplo, creas un programa llamado summarize Stata lo va ignorar y utilizará su propio comando.","code":"egen total_pc_papitas = total(pc_papitas), by(region)\negen total_obs = count(pc_papitas), by(region)\ngen consumo_papitas_resto_pc = ///\n(total_pc_papitas - pc_papitas)/(total_obs - 1)egen total_pc_papitas = total(pc_papitas), by(metroarea)\negen total_obs = count(pc_papitas), by(region)\ngen consumo_papitas_restometro_pc = ///\n(total_pc_papitas - pc_papitas)/(total_obs - 1)program consumo_papitas_resto \n    syntax, invar(varname) outvar(name) byvar(varname)\n    tempvar tot_invar count_invar \n    egen `tot_invar' = total(`invar'), by(`byvar')\n    egen `count_invar' = count('invar'), by('byvar') \n    gen `outvar' = (`tot_invar' - `invar') ///\n    / (`count_invar' - 1) \nend * Caso 1 \nconsumo_papitas_resto, invar(pc_papitas) ///\noutvar(consumo_papitas_resto_pc) byvar(region)\n\n* Caso 2\nconsumo_papitas_resto, invar(pc_papitas)  ///\noutvar(consumo_papitas_restometro_pc) byvar(metroarea)    program nombredelprograma\n        display \"Lo que va a hacer el programa\"\n    end which tabmiss"},{"path":"análisis-de-datos-con-stata.html","id":"mis-primeros-programas-en-stata","chapter":"2 Análisis de datos con Stata","heading":"2.4.3 Mis primeros programas en Stata","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"programa-1","chapter":"2 Análisis de datos con Stata","heading":"2.4.3.1 Programa 1","text":"Vamos escribir nuestro primer programa:Noten que al ejecutarlo se genera ningún resultado. Lo que hemos hecho es definir un comando llamado minombrees con una simple función. Esta es la idea principal de un programa. Ejecuten nuevamente el programa. Al hacer esto observaran que se genera un error. Esto es porque al igual que las variables, es posible asignar dos nombres iguales un programa. Para evitar esto, es importante utilizar program drop minombrees antes de cargar el comando nuevamente. Este es un buen momento para utilizar capture.","code":"  * Mi primer programa en Stata\n    program minombrees \n        display \"Hola, mi nombre es \"\n    end "},{"path":"análisis-de-datos-con-stata.html","id":"programa-2","chapter":"2 Análisis de datos con Stata","heading":"2.4.3.2 Programa 2","text":"Vamos escribir un programa que permita calcular un promedio. Vamos escribir un comando que nos permita crear una nueva variable que contenga los valores promedio y que muestre el resultado en la pantalla. Esto sería igual que escribir:Podemos evitar la repetición de estos dos comandos armando un programa:Noten que hemos utilizado `1'. Este nos indica cualquier variable que este en la primera posición. Si incluimos más de una variable. Solo va considerar la primera variable.Ejercicio 3.5.1: PreguntasEscriba un programa que permita ver todas las etiquetas (labels) de una base de datos.Aplique este programa la base auto.dta.","code":"    sysuse auto, clear\n    egen mimedia_mpg = mean(mpg)\n    tab mean_mpg program drop _all \ncapture program drop mymean\nprogram mymean \n    egen media_`1' = mean(`1')\n    tab media_`1'\nend \n\n* Aplicamos este programa \nsysuse auto, clear\nmimedia mpg"},{"path":"análisis-de-datos-con-stata.html","id":"programa-3","chapter":"2 Análisis de datos con Stata","heading":"2.4.3.3 Programa 3","text":"Vamos reescribir el programa para permitir un número arbitrario de variables. La macro ‘0’ contiene toda la cadena, ‘1’ el primer elemento, ‘2’ el segundo, etc. Podemos hacer una iteración sobre todos los elementos sin saber cuántos hay utilizando la técnica de desplazamiento incremental que implementaremos con macro_shift.El comando macro shift sirve como incremental. Termina cuando encuentra un vacio, lo que explica la presencia del . Notar que \"1’“` habla de la posición. Es una buena tecnica para garantizar que el iterador seguirá cuando este vacio.","code":"capture program drop mimedia \nprogram define mimedia \n    while \"`1'\"!=\"\" { \n        egen mean_`1'=mean(`1') \n        tab mean_`1' \n        macro shift\n    }\nend\n\nsysuse auto, clear\nmimedia price mpg rep78 "},{"path":"análisis-de-datos-con-stata.html","id":"programa-4","chapter":"2 Análisis de datos con Stata","heading":"2.4.3.4 Programa 4","text":"Modificamos un poco el programa para que despliegue los resultados en la consola de Stata. Adicionalmente, agregamos un quietly.","code":"capture program drop mimedia \nprogram define mimedia \n    while \"`1'\"!=\"\" { \n        qui: egen `1'_mean = mean(`1') \n        display \"Media de `1' = \" `1'_mean \n        macro shift\n    }\nend\n\nsysuse auto, clear\nmimedia price mpg rep78 "},{"path":"análisis-de-datos-con-stata.html","id":"programa-5","chapter":"2 Análisis de datos con Stata","heading":"2.4.3.5 Programa 5","text":"El comando macro shift es útil, pero puede ser lento. Agregando variables locales usuales y un incremental es mucho mejor. Ojo con las dobles comillas.","code":"capture program drop mimedia \nprogram define mimedia \n    local i = 1\n    while \"``i''\"~=\"\" { \n        qui: egen ``i''_mean = mean(``i'') \n        display \"Media de `i' = \" ``i''_mean \n        local ++i\n    }\nend"},{"path":"análisis-de-datos-con-stata.html","id":"programa-con-distintos-argumentos","chapter":"2 Análisis de datos con Stata","heading":"2.4.4 Programa con distintos argumentos","text":"El programa de los ejemplos anteriores soporta un solo argumento. Ahora vamos ver un programa que considere explícitamente que los argumentos de un programa pueden tomar roles distintos.tempvar crea una variable temporal que existe mientras el programa se ejecuta pero que se elimina automáticamente una vez que el programa termina su ejecución. Es importante estar seguros() de que cualquier string están en comillas dobles.Ejercicio 3.5.2:PreguntasEscriba un programa que reporte la mediana de la diferencia entre dos variables.Aplique este programa la base auto.dta.","code":"program drop _all \ncapture program drop show \nprogram define show\n    tempvar obs \n    quietly gen `obs' = `1' ///\n    if (ctycode == \"`2'\" & year ==`3')\n    sort `obs'\n    display \"`1' of country `2' in `3' is: \" `obs' \nend"},{"path":"análisis-de-datos-con-stata.html","id":"opción-syntax","chapter":"2 Análisis de datos con Stata","heading":"2.4.5 Opción Syntax","text":"Renombrando argumentos:De momento hemos escrito los programas utilizando '1', '2', '3' con el fin de introducir el uso de programas en Stata.Sin embargo, esta notación puede ser un poco confusa y provocar errores en la codificación. Podemos asignar nombres de mayor significado los argumentos del programa.El comandoargs asigna las variables locales var, cty, yr los valores de '1', '2', '3'. Noten que si llaman al programa con cuatro argumentos retorna un error. Un método mucho más robusto y mejor para llamar los argumentos de un programa es utilizar syntax. En vez de referirnos cada elemento de un programa por su posición, vamos especificar la “gramática” del programa.La sintaxis de Stata es:varlist denota la lista de variables, command el comando ejecutar, exp denota una expresión algebraica, range denota un rango para las observaciones mientras que ,options denota la lista de opciones propias de un comando. Utilizar syntax en un programa hace que Stata verifique si un programa satisface la sintaxis. En caso de que la cumpla, arrojara un error.Syntax\n* El comando syntax almacena en macros locales todos los elementos típicos de un comando en Stata.\n* Por ejemplo, syntax también puede definir condicionales como o .Si quieren hacer programas más complejos, con otras características es importante revisar syntax.Uno de los primeros elementos de syntax es varlist. Es posible indicar el mínimo o máximo de variables.\n* Por ejemplo: varlist(min = 2 max = 2).\n* Si tienes solo una variable puedes utilizar varname.\n* Es equivalente varlist(min = 1 max = 1).\n* La macro que guarda las variables siempre se llama varlist.Ejemplo 1: programa para calcular percentilesEl programa anterior nos permite obtener los percentiles de alguna variable al mismo tiempo que los muestra en la consola. Noten que tambíen incluido que tipo de comando es. En este caso es un comando r-class. program es quien determina el nombre del programa. syntax permite determinar los elementos de tu programa. En el ejemplo define el tipo y el límite de variables. También puede definir condicionales como o .Los escalares definidos durante el programa se pueden utilizar. Esto siempre es conveniente. Como recomendación es bueno guardar los programas como variables temporales.Ejemplo 2: programa para calcular percentiles con variables locales","code":"program drop _all \ncapture program drop show \nprogram define show\n    args var cty yr\n    tempvar obs \n    quietly gen `obs' = `var' ///\n    if (ctycode == \"`cty'\" & year ==`yr')\n    sort `obs'\n    display \"`1' of country `2' in `3' is: \" `obs' \nend[by varlist:] command [varlist] [=exp] [in range] [, options]    program ... \n        syntax varlist(min = 2) [if] [in]program pctrange, rclass \nversion 17 \n    syntax varlist(max = 1 numeric)\n    quietly summarize `varlist', detail \n    scalar range = r(max) - r(min)\n    scalar p7525 = r(p75) - r(p25)\n    scalar p9010 = r(p90) - r(p10)\n    display as result _n \"Rangos de percentiles para `varlist'\"\n    display as txt \"75-25 : \" p7525\n    display as txt \"90-10:  \" p9010 \n    display as txt \"Range: \" range\nend program pctrange, rclass \nversion 17 \n    syntax varlist(max = 1 numeric)\n    local res \"range p7525 p9010\"\n    tempname `res'    \n    display as result _n \"Rangos de percentiles para `varlist'\"\n    quietly summarize `varlist', detail \n    scalar `range' = r(max) - r(min)\n    scalar `p7525' = r(p75) - r(p25)\n    scalar `p9010' = r(p90) - r(p10)\n    display as txt \"75-25 : \" `p7525'\n    display as txt \"90-10:  \" `p9010'\n    display as txt \"Range: \" `range'"},{"path":"análisis-de-datos-con-stata.html","id":"return","chapter":"2 Análisis de datos con Stata","heading":"2.4.6 Return","text":"Una característica importante de los comandos de Stata es su capacidad de reportar los resultados de forma tal de que los usuarios y usuarias podamos utilizarlos posteriormente.El comando return nos permite guardar los escalares y hacerlos accesibles, sin tener el problema que vimos en el ejemplo anterior.Notar que el lado izquierdo del escalar de retorno se refiere al nombre de la macro, el lado derecho debe hacer referencia la macro una vez más para extraer el valor almacenado en ese nombre, por lo que debe utilizar dos comillas.Ejemplo 3: programa para calcular percentiles con return","code":"program pctrange, rclass \nversion 17 \n    syntax varlist(max = 1 numeric)\n    local res \"range p7525 p9010\"\n    tempname `res'    \n    display as result _n \"Rangos de percentiles para `varlist'\"\n    quietly summarize `varlist', detail \n    scalar `range' = r(max) - r(min)\n    scalar `p7525' = r(p75) - r(p25)\n    scalar `p9010' = r(p90) - r(p10)\n    display as txt \"75-25 : \" `p7525'\n    display as txt \"90-10:  \" `p9010 '\n    display as txt \"Range: \" `range'\n    foreach r of local res {\n        return scalar `r' = ``r''\n        }\nend "},{"path":"análisis-de-datos-con-stata.html","id":"implementar-opciones-al-programa","chapter":"2 Análisis de datos con Stata","heading":"2.4.7 Implementar opciones al programa","text":"Podemos agregar distintas opciones al programa. Una opción es agregar como opcional que el programa de un resultado en la consola. Al incluir \\([ ]\\) en syntax significa un componente opcional en el comando.Ejemplo 4: implementar opciones al programa (imprimir por defecto)Ejemplo 5: implementar opciones al programa (imprimir por defecto)","code":"program pctrange, rclass \nversion 17 \n    syntax varlist(max = 1 numeric) [, PRINT]\n    local res \"range p7525 p9010\"\n    tempname `res'    \n    display as result _n \"Rangos de percentiles para `varlist'\"\n    quietly summarize `varlist', detail \n    scalar `range' = r(max) - r(min)\n    scalar `p7525' = r(p75) - r(p25)\n    scalar `p9010' = r(p90) - r(p10)\n    if \"`print'\" == \"print\" {\n    display as txt \"75-25 : \" `p7525'\n    display as txt \"90-10:  \" `p9010 '\n    display as txt \"Range: \" `range'\n    }\n    foreach r of local res {\n        return scalar `r' = ``r''\n        }\nend program pctrange, rclass \nversion 17 \n    syntax varlist(max = 1 numeric) [, noPRINT]\n    local res \"range p7525 p9010\"\n    tempname `res'    \n    display as result _n \"Rangos de percentiles para `varlist'\"\n    quietly summarize `varlist', detail \n    scalar `range' = r(max) - r(min)\n    scalar `p7525' = r(p75) - r(p25)\n    scalar `p9010' = r(p90) - r(p10)\n    if \"`print'\" != \"noprint\" {\n    display as txt \"75-25 : \" `p7525'\n    display as txt \"90-10:  \" `p9010 '\n    display as txt \"Range: \" `range'\n    }\n    foreach r of local res {\n        return scalar `r' = ``r''\n        }\nend "},{"path":"análisis-de-datos-con-stata.html","id":"incluir-ifin-al-programa","chapter":"2 Análisis de datos con Stata","heading":"2.4.8 Incluir if/in al programa","text":"Incluir un subconjunto de observacionesCualquier comando debiese incluir o range.Nuevamente, estas opciones son manejadas dentro del comando syntax. Para incluir estas opciones hay que agregar [] y [].Con estos comandos puedo ejecutar el programa para sub-muestras. Es importante asegurar que la sub-muestra es vacía. Para ello es importante calcular r(N), chequear que sea distinto de cero y agregar un título que lo indique.El comando marksample touse utiliza la información provista por o en caso de que estos sean indicados en el programa. Este comando genera una variable local touse que es igual 1 si las variables entran en el calculo que hace el programa y 0 en caso contrario.Utilizaremos 'touse' para calcular el número de observaciones que se utilizan después de aplicar los condicionales. Es necesario agregar 'touse' en cada parte del programa que trabaje con la variable de input.Ejemplo 6: Incluir un subconjunto de observaciones","code":"program pctrange, rclass \nversion 17 \n    syntax varlist(max = 1 numeric) [, noPRINT]\n    local res \"range p7525 p9010\"\n    tempname `res'    \n    display as result _n \"Rangos de percentiles para `varlist'\"\n    quietly summarize `varlist', detail \n    scalar `range' = r(max) - r(min)\n    scalar `p7525' = r(p75) - r(p25)\n    scalar `p9010' = r(p90) - r(p10)\n    if \"`print'\" != \"noprint\" {\n    display as txt \"75-25 : \" `p7525'\n    display as txt \"90-10:  \" `p9010 '\n    display as txt \"Range: \" `range'\n    }\n    foreach r of local res {\n        return scalar `r' = ``r''\n        }\nend "},{"path":"análisis-de-datos-con-stata.html","id":"generalizar-el-comando-para-incluir-múltiples-variables","chapter":"2 Análisis de datos con Stata","heading":"2.4.9 Generalizar el comando para incluir múltiples variables","text":"Algunas consideracionesSi quiero ejecutar el programa sobre múltiples variables, es necesario ajustar un poco el programa.Tengo que indicarle syntax que hay más de una variable. Además, tengo que indicarle al programa que en caso de que existan más variables muestre los resultados en una tabla.Guardaremos los resultados en matrices (escalares) y vamos aplicar una función de macro extendida con el fin de contar el número de filas que esta matriz debiese tener.Agregaremos también una la opción para cambiar el formato y la opción mat que permite la matriz ser guardada automáticamente con el nombre indicado.Ejemplo 7","code":"program drop _all \nprogram pctrange, rclass\nversion 17 \n    syntax varlist(min = 1 numeric ts) [if] [in] [, noPRINT FORmat(passthru) MATrix(string)] \n    marksample touse \n    quietly count if `touse'\n    if `r(N)' == 0 {\n        error 2000\n    }\n    local nvar: word count `varlist'\n    if `nvar' == 1 {\n        local res range p7525 p9010\n        tempname `res'    \n    \n        quietly summarize `varlist' if `touse', detail \n        scalar `range' = r(max) - r(min)\n        scalar `p7525' = r(p75) - r(p25)\n        scalar `p9010' = r(p90) - r(p10)\n        if \"`print'\" != \"noprint\" {\n            display as result _n \"Rangos de percentiles para `varlist', N = `r(N)'\"\n            display as txt \"75-25 : \" `p7525'\n            display as txt \"90-10:  \" `p9010 '\n            display as txt \"Range: \" `range'\n    }\n    \n    foreach r of local res {\n        return scalar `r' = ``r''\n    }\n    return scalar N = r(N)\n    }\n    else {\n    tempname rmat \n      matrix `rmat' = J(`nvar', 3, .)\n      local i 0 \n        foreach v of varlist `varlist'{\n        local ++i \n        quietly summarize `v' if `touse', detail \n        matrix `rmat'[`i' ,1] = r(max) - r(min)\n        matrix `rmat'[`i', 2] = r(p75) - r(p25)\n        matrix `rmat'[`i', 3] = r(p90) - r(p10)\n        local rown `rown' `v'\n    }\n      \n      matrix colnames `rmat' = Range P75-P25 P90-P10 \n      matrix rownames `rmat' = `rown' \n\n      if \"`print'\" != \"noprint\" {\n          local form \", noheader\"\n          if \"`format'\" != \"\" {\n                local form \"`form' `format'\" \n          }\n          matrix list `rmat' `form'\n                                }\n\n      if \"`matrix'\" != \"\" {\n            matrix `matrix' = `rmat'\n      }\n      return matrix rmat = `rmat'\n      }\n      return local varname `varlist'\nend "},{"path":"análisis-de-datos-con-stata.html","id":"agregar-prefijos-a-los-programas","chapter":"2 Análisis de datos con Stata","heading":"2.4.10 Agregar prefijos a los programas","text":"Prefijo byAhora vamos hacer que nuestro programa pueda utilizar el prefijo .Para agregar esta opción simplemente hay qyue modificar program.También podemos permitir que la lista de variables incluya operadores de series de tiempo (ej. L.pib, D.ingreso). Para incorporar estos elementos tenemos que modificar syntax.","code":"program pctrange, rclass byable(recall)    syntax varlist(min = 1 numeric ts) [if] [in] ///\n    [, noPRINT  FORmat(passthru) MATrix(string)]"},{"path":"análisis-de-datos-con-stata.html","id":"programas-para-complementar-función-egen","chapter":"2 Análisis de datos con Stata","heading":"2.4.11 Programas para complementar función egen","text":"Es posible programar funciones adicionales de egen. El nombre de estos programas deben empezar con _g. Una diferencia importante entre este tipo de programas y los que ya hemos escrito guarda relación con el hecho de que hay que tener en cuenta la nueva variable que se va crear. La sintaxis es la siguiente:El cambio que haremos en la sintaxis del programa será que incluiremos un touse para hacer la nueva variable.Ejemplo 8: programa función egenProgramas con funciones de egen con prefijo byAgregamos [, *] que corresponde las opciones. En egen el prefijo es una opción.Con el fin de permitirle al programa que pueda producir un rango de percentil separado para cada grupos utilizaremos pctile en vez de summarize.El cambio que haremos en la sintaxis del programa será que incluiremos un touse para hacer la nueva variable.Ejemplo 9: programa función egen con prefijo byGeneralización de la función egen para soportar todos los pares de cuantilesHemos desarrollado una función de egen que permite calcular un rango entre percentiles para una lista de variables especifica.Puede ser util tomar ventaja de egen pctile() para poder calcular cualquier percentil de la lista de variables especificadas.Vamos agregar dos opciones la función egen : lo() y hi(). En caso de que especifiquemos, por defecto se calcula el rango interquartil. La función de egen ahora se llamará _gpctrange.ado.Ejemplo 10: función egen más general","code":"egen [type] newvarname = fcn(arguments) [if] [in] [, options]* Programas de egen \nprogram drop _all\nprogram _gpct9010\n    syntax newvarname =/exp [if] [in] \n    tempvar touse \n    mark `touse' `if' `in' \n    quietly summarize `exp' if `touse', detail \n    quietly generate `typlist' `varlist' = r(p90) - r(p10) if `touse'\nend\n\n* Aplicación del programa\nsysuse auto, clear\negen rango9010 = pct9010(price)* Programa con opción by. \nprogram drop _all\nprogram _gpct9010\nsyntax newvarname =/exp [if] [in] [, *] \ntempvar touse p90 p10 \nmark `touse' `if' `in' \nquietly {\n          egen double `p90' = pctile(`exp') if `touse', `options' p(90) \n          egen double `p10' = pctile(`exp') if `touse', `options' p(10)\n          generate `typlist' `varlist' = `p90' - `p10' if `touse' } \nend\n\n* Aplicación del programa\nsysuse auto, clear\negen rango9010 = pct9010(price)\nbysort rep78 foreign: egen rango9010_prefijoby = pct9010(price)* Programa con opción by. \nprogram drop _all\nprogram _gpctrange\nsyntax newvarname =/exp [if] [in] [, LO(integer 25) HI(integer 75) *] \n\nif `hi' > 99 | `lo' < 1 {\n    display as error ///\n        \"Percentiles `lo' `hi' deben estar entre 1 y 99.\" \n    error 198 \n}\nif `hi' <= `lo' {\n    display as error ///\n            \"Percentiles `lo' `hi' deben estar en orden ascendente\"\n    error 198 \n}\ntempvar touse phi plo \nmark `touse' `if' `in' \nquietly {\n          egen double `phi' = pctile(`exp') if `touse', `options' p(`hi') \n          egen double `plo' = pctile(`exp') if `touse', `options' p(`lo')\n          generate `typlist' `varlist' = `phi' - `plo' if `touse' \n          } \nend\n\nsysuse auto, clear\nbysort rep78: egen iqr = pctrange(price) if inrange(rep78,3,5)\nbysort rep78: egen p8020 = pctrange(price) if inrange(rep78,3,5), hi(80) lo(20)\ntabstat iqr if inrange(rep78, 3, 5), by(rep78)\ntabstat p8020 if inrange(rep78, 3, 5), by(rep78)"},{"path":"análisis-de-datos-con-stata.html","id":"programar-ado---files-parte-ii","chapter":"2 Análisis de datos con Stata","heading":"2.5 Programar ado - files (Parte II)","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"syntax","chapter":"2 Análisis de datos con Stata","heading":"2.5.1 Syntax","text":"Algunas consideracionesComo hemos visto hay dos formas en los que un programa de Stata puede interpretar lo que ingresamos.Por posición tal como lo hace args o como lo hicimos con los números entre las comillas.De acuerdo la gramática del programa utilizando syntax.syntax guarda los componentes en macros locales particulares las cuales podemos acceder posteriormente.Por ejemplo '' '' 'varlist' son macros locales las que podemos acceder tal como vimos la clase pasada.Ahora vamos ver algunas opciones de syntax que nos permitirán tener más herramientas para escribir nuestros programas.Al utilizar dentro de un programa paréntesis cuadrados estoy indicando que esas partes son opcionales.Por ejemplo, estas dos versiones son equivalentes, salvo que en la segunda linea todo es opcional:Vamos mirar las macros generadas por syntax:Vamos aplicar lo aprendido en un ejemplo sencillo:marksample y touse: Un error común es utilizar una muestra en una parte del programa y otra distinta en otra parte. La solución es crear una variable que contiene un 1 si la observación fue utilizada y un 0 en caso contrario.","code":"    * Nada opcional\n    syntax varlist if in title(string) adjust(real 1) \n    \n    * Todo opcional\n    syntax [varlist] [if] [, adjust (real 1) title(string)]capture program drop myprog\nprogram myprog \nsyntax varlist [if] [in] [, adjust(real 1) title(string)] \n    display \"varlist contiene |`varlist'|\" \n    display \"if contiene |`if'|\" \n    display \"in contiene |`in'|\" \n    display \"adjust contiene |`adjust'|\" \n    display \"title contiene |`title'|\" \nendcapture program drop miprograma\nprogram miprograma\n    syntax varlist [if] [in] [, adjust(real 1) title(string)]\n    display \n    if \"`title'\" != \"\" {\n        display \"`title':\"\n    }\n    foreach var of local varlist{\n        quietly summarize `var' `if' `in'\n        display \"`var'\" \" \"%9.0g r(mean)*`adjust'\n    }\nendcapture program drop miprograma\nprogram miprograma\n    syntax varlist [if] [in] [, adjust(real 1) title(string)]\n    marksample touse\n    display \n    if \"`title'\" != \"\" {\n        display \"`title':\"\n    }\n    foreach var of local varlist{\n        quietly summarize `var' `if' `touse'\n        display \"`var'\" \" \" r(mean)*`adjust'\n    }\nend"},{"path":"análisis-de-datos-con-stata.html","id":"varlist","chapter":"2 Análisis de datos con Stata","heading":"2.5.2 Varlist","text":"varlist específica la macro que contiene las variables que van ingresar al programa como inputs. Las opciones de varlist son:\n* default = none. Especifica como la varlist se va llenar. Por defecto se llena con todas las variables.\n* min, max especifica el número de variables permitidas.\n* numeric, string especifican que criterio deben cumplir todas las variables que ingresas al programa.\n* ts permite que la varlist contenga operadores de series de tiempo.\n* fv permite que la varlist contenga variables categóricas.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"opciones","chapter":"2 Análisis de datos con Stata","heading":"2.5.3 Opciones","text":"Las opciones permiten hacer requeridos o opcionales. Por ejemplo, regress, noconstant. Las opciones pueden ser una numlist, una varlist (ej. (varlist) option, una namelist tal como el nombre de una matriz o de una nueva variable. Como regla general, cualquier característica que pudieran encontrar en un comando de Stata, la pueden agregar en un programa. Para las opciones es importante recordar que las mayúsculas indican la menor abreviación posible.replace, detail, constant son opciones de .noreplace, nodetail, noconstant son opciones de . Ojo las macros que retornan tienen los mismos nombres que en el caso anterior.title y adjust también son otros opcionales. El primero permite ingresar un título al comando mientras que el segundo permite ajustar los resultados por algún escalar.Hay muchas otras. Veamos un ejemplo…","code":"capture program drop miprograma\nprogram miprograma\n    syntax varlist [if] [in] [, adjust(real 1) title(string)]\n    display \n    if \"`title'\" != \"\" {\n        displa \"`title':\"\n    }\n    foreach var of local varlist{\n        quietly summarize `var' `if' `in'\n        display \"`var'\" \" \"%9.0g r(mean)*`adjust'\n    }\nend"},{"path":"análisis-de-datos-con-stata.html","id":"programa-para-calcular-percentiles","chapter":"2 Análisis de datos con Stata","heading":"2.5.4 Programa para calcular percentiles","text":"Una versión simple para una variable:Algunas consideracionesEl programa anterior nos permite obtener los percentiles de alguna variable al mismo tiempo que los muestra en la consola.Noten que también incluido que tipo de comando es. En este caso es un comando r-class.Los escalares definidos en el programa se pueden utilizar. Esto siempre es conveniente.Como recomendación es bueno guardar los resultados esperados de los programas como variables temporales.Versión que incluye variables guardadas localmente:","code":"program pctrange, rclass \nversion 17 \n    syntax varlist(max = 1 numeric)\n    quietly summarize `varlist', detail \n    scalar range = r(max) - r(min)\n    scalar p7525 = r(p75) - r(p25)\n    scalar p9010 = r(p90) - r(p10)\n    display as result _n \"Rangos de percentiles para `varlist'\"\n    display as txt \"75-25 : \" p7525\n    display as txt \"90-10:  \" p9010 \n    display as txt \"Range: \" range\nend program pctrange, rclass \nversion 17 \n    syntax varlist(max = 1 numeric)\n    local res \"range p7525 p9010\"\n    tempname `res'    \n    display as result _n \"Rangos de percentiles para `varlist'\"\n    quietly summarize `varlist', detail \n    scalar `range' = r(max) - r(min)\n    scalar `p7525' = r(p75) - r(p25)\n    scalar `p9010' = r(p90) - r(p10)\n    display as txt \"75-25 : \" `p7525'\n    display as txt \"90-10:  \" `p9010'\n    display as txt \"Range: \" `range'"},{"path":"análisis-de-datos-con-stata.html","id":"programa-con-opción-return","chapter":"2 Análisis de datos con Stata","heading":"2.5.5 Programa con opción return","text":"Una característica importante de los comandos de Stata es su capacidad de reportar los resultados de forma tal de que los usuarios y usuarias podamos utilizarlos posteriormente. El comando return nos permite guardar los escalares y hacerlos accesibles, sin tener el problema de los escalares que vimos en los ejemplos anteriores.Programa para calcular percentiles con return:Sobre la forma en que llamamos return:Notar que el lado izquierdo de scalar('r') se refiere al nombre de los elementos de la macro res. El lado derecho hace referencia la macro una vez más para extraer el valor almacenado en ese nombre. En este caso es importante notar que se deben utilizar dos comillas (ej. \"range\"). Noten también que si utilizamos scalar list hay resultados, sin embargo, al utilizar la opción return ahora podemos rescatar los resultados con return list.Ejercicio 3.6.3: PreguntasEscriba un programa llamado misuma que sea del tipo r-class.Este programa debe entregar en la lista de return list el número total de observaciones, la suma total y el promedio de la variable.Aplicarla en auto.dta.","code":"program pctrange, rclass \nversion 17 \n    syntax varlist(max = 1 numeric)\n    local res \"range p7525 p9010\"\n    tempname `res'    \n    display as result _n \"Rangos de percentiles para `varlist'\"\n    quietly summarize `varlist', detail \n    scalar `range' = r(max) - r(min)\n    scalar `p7525' = r(p75) - r(p25)\n    scalar `p9010' = r(p90) - r(p10)\n    display as txt \"75-25 : \" `p7525'\n    display as txt \"90-10:  \" `p9010 '\n    display as txt \"Range: \" `range'\n    foreach r of local res {\n        return scalar `r' = ``r''\n        }\nend     foreach r of local res {\n        return scalar `r' = ``r''\n    }"},{"path":"análisis-de-datos-con-stata.html","id":"agregar-opciones-al-programa","chapter":"2 Análisis de datos con Stata","heading":"2.5.6 Agregar opciones al programa","text":"Podemos agregar distintas opciones al programa. Para este ejemplo vamos agregar como opcional que el programa de un resultado en la consola. Recordemos que incluir \\([ ]\\) en syntax significa un componente opcional en el comando.Implementar opciones al programa (imprimir por defecto):Implementar opciones al programa (imprimir por defecto):Incluir un subconjunto de observacionesCualquier comando debiese incluir o range.Nuevamente, estas opciones son manejadas dentro del comando syntax. Para incluir estas opciones hay que agregar [] y [].Con estos comandos puedo ejecutar el programa para sub-muestras. Es importante asegurar que la sub-muestra este vacía.Para ello es importante calcular r(N), chequear que sea distinto de cero y agregar un título que lo indique.El comando marksample touse utiliza la información provista por o en caso de que estos sean indicados en el programa.Este comando genera una variable local touse que es igual 1 si las variables entran en el calculo que hace el programa y 0 en caso contrario.Utilizaremos `touse' para calcular el número de observaciones que se utilizan después de aplicar los condicionales.Es necesario agregar `touse' en cada parte del programa que trabaje con la variable de input.Incluir un subconjunto de observaciones:Ejercicio 3.6.2: PreguntasAjuste el programa del ejercicio 1 con el fin de incluir la opción . Guárdelo como misuma2.Aplicarla en auto.dta.","code":"program pctrange, rclass \nversion 17 \n    syntax varlist(max = 1 numeric) [, PRINT]\n    local res \"range p7525 p9010\"\n    tempname `res'    \n    display as result _n \"Rangos de percentiles para `varlist'\"\n    quietly summarize `varlist', detail \n    scalar `range' = r(max) - r(min)\n    scalar `p7525' = r(p75) - r(p25)\n    scalar `p9010' = r(p90) - r(p10)\n    if \"`print'\" == \"print\" {\n    display as txt \"75-25 : \" `p7525'\n    display as txt \"90-10:  \" `p9010 '\n    display as txt \"Range: \" `range'\n    }\n    foreach r of local res {\n        return scalar `r' = ``r''\n        }\nend program pctrange, rclass \nversion 17 \n    syntax varlist(max = 1 numeric) [, noPRINT]\n    local res \"range p7525 p9010\"\n    tempname `res'    \n    display as result _n \"Rangos de percentiles para `varlist'\"\n    quietly summarize `varlist', detail \n    scalar `range' = r(max) - r(min)\n    scalar `p7525' = r(p75) - r(p25)\n    scalar `p9010' = r(p90) - r(p10)\n    if \"`print'\" != \"noprint\" {\n    display as txt \"75-25 : \" `p7525'\n    display as txt \"90-10:  \" `p9010 '\n    display as txt \"Range: \" `range'\n    }\n    foreach r of local res {\n        return scalar `r' = ``r''\n        }\nend program drop _all \nprogram pctrange, rclass \nsyntax varlist(max = 1 numeric) [if] [in] [, noPRINT]\n    marksample touse \n    quietly count if `touse'\n    if `r(N)' == 0 {\n        error 2000\n    }\n    local res range p7525 p9010\n    tempname `res'    \n    \n    quietly summarize `varlist' if `touse', detail \n    scalar `range' = r(max) - r(min)\n    scalar `p7525' = r(p75) - r(p25)\n    scalar `p9010' = r(p90) - r(p10)\n    if \"`print'\" != \"noprint\" {\n        display as result _n \"Rangos de percentiles para `varlist', N = `r(N)'\"\n        display as txt \"75-25 : \" `p7525'\n        display as txt \"90-10:  \" `p9010 '\n        display as txt \"Range: \" `range'\n    }\n    foreach r of local res {\n        return scalar `r' = ``r''\n        }\n    return scalar N = r(N)\n    return local varname `varlist'\n\nend "},{"path":"análisis-de-datos-con-stata.html","id":"generalizar-el-comando-para-incluir-múltiples-variables-1","chapter":"2 Análisis de datos con Stata","heading":"2.5.7 Generalizar el comando para incluir múltiples variables","text":"Algunas consideracionesSi quiero ejecutar el programa sobre múltiples variables, es necesario ajustar un poco el programa.Tengo que indicarle syntax que hay más de una variable. Además, tengo que indicarle al programa que en caso de que existan más variables muestre los resultados en una tabla.Guardaremos los resultados en matrices (escalares) y vamos aplicar una función de macro extendida con el fin de contar el número de filas que esta matriz debiese tener.Agregaremos también una la opción format para cambiar el formato y la opción mat que permite la matriz ser guardada automáticamente con el nombre indicado.","code":"program drop _all \nprogram pctrange, rclass\nversion 17 \n    syntax varlist(min = 1 numeric ts) [if] [in] [, noPRINT FORmat(passthru) MATrix(string)] \n    marksample touse \n    quietly count if `touse'\n    if `r(N)' == 0 {\n        error 2000\n    }\n    local nvar: word count `varlist'\n    if `nvar' == 1 {\n        local res range p7525 p9010\n        tempname `res'    \n    \n        quietly summarize `varlist' if `touse', detail \n        scalar `range' = r(max) - r(min)\n        scalar `p7525' = r(p75) - r(p25)\n        scalar `p9010' = r(p90) - r(p10)\n        if \"`print'\" != \"noprint\" {\n            display as result _n \"Rangos de percentiles para `varlist', N = `r(N)'\"\n            display as txt \"75-25 : \" `p7525'\n            display as txt \"90-10:  \" `p9010 '\n            display as txt \"Range: \" `range'\n    }\n        foreach r of local res {\n        return scalar `r' = ``r''\n    }\n    return scalar N = r(N)\n    }\n    else {\n    tempname rmat \n      matrix `rmat' = J(`nvar', 3, .)\n      local i 0 \n        foreach v of varlist `varlist'{\n        local ++i \n        quietly summarize `v' if `touse', detail \n        matrix `rmat'[`i' ,1] = r(max) - r(min)\n        matrix `rmat'[`i', 2] = r(p75) - r(p25)\n        matrix `rmat'[`i', 3] = r(p90) - r(p10)\n        local rown `rown' `v'\n        }\n      matrix colnames `rmat' = Range P75-P25 P90-P10 \n      matrix rownames `rmat' = `rown' \n\n      if \"`print'\" != \"noprint\" {\n          local form \", noheader\"\n          if \"`format'\" != \"\" {\n                local form \"`form' `format'\" \n          }\n          matrix list `rmat' `form'\n                                }\n\n      if \"`matrix'\" != \"\" {\n            matrix `matrix' = `rmat'\n      }\n      return matrix rmat = `rmat'\n      }\n      return local varname `varlist'\nend"},{"path":"análisis-de-datos-con-stata.html","id":"agregar-prefijos-a-los-programas-1","chapter":"2 Análisis de datos con Stata","heading":"2.5.8 Agregar prefijos a los programas","text":"prefijo : Ahora vamos hacer que nuestro programa pueda utilizar el prefijo . Para agregar esta opción simplemente hay que modificar program.También podemos permitir que la lista de variables incluya operadores de series de tiempo (ej. L.pib, D.ingreso).","code":"program pctrange, rclass byable(recall)syntax varlist(min = 1 numeric ts) "},{"path":"análisis-de-datos-con-stata.html","id":"programas-para-complementar-función-egen-1","chapter":"2 Análisis de datos con Stata","heading":"2.5.9 Programas para complementar función egen","text":"Es posible programar funciones adicionales de egen (extended generate). El nombre de estos programas deben empezar con _g. Una diferencia entre este tipo de programas y los ya hechos es que en estos hay que tener en cuenta la nueva variable que se va crear. La sintaxis es la siguiente:El cambio que vamos hacer en la sintaxis del programa será que incluiremos un touse para hacer la nueva variable.Vamos escribir un programa para calcular un rango en particular:Programas con funciones de egen con prefijo :Agregamos [, *] que corresponde las opciones. En egenel prefijo es una opción.Con el fin de permitirle al programa que pueda producir un rango de percentil separado para distintos grupos utilizaremos pctile en vez de summarize.","code":"egen [type] newvarname = fcn(arguments) [if] [in] [, options]* Programas de egen \nprogram drop _all\nprogram _gpct9010\n    syntax newvarname =/exp [if] [in] \n    tempvar touse \n    mark `touse' `if' `in' \n    quietly summarize `exp' if `touse', detail \n    quietly generate `typlist' `varlist' = r(p90) - r(p10) if `touse'\nend\n\n* Aplicación del programa\nsysuse auto, clear\negen rango9010 = pct9010(price)* Programa con opción by. \nprogram drop _all\nprogram _gpct9010\nsyntax newvarname =/exp [if] [in] [, *] \ntempvar touse p90 p10 \nmark `touse' `if' `in' \nquietly {\n          egen double `p90' = pctile(`exp') if `touse', `options' p(90) \n          egen double `p10' = pctile(`exp') if `touse', `options' p(10)\n          generate `typlist' `varlist' = `p90' - `p10' if `touse' } \nend\n\n* Aplicación del programa\nsysuse auto, clear\negen rango9010 = pct9010(price)\nbysort rep78 foreign: egen rango9010_prefijoby = pct9010(price)"},{"path":"análisis-de-datos-con-stata.html","id":"generalización-de-la-función-egen","chapter":"2 Análisis de datos con Stata","heading":"2.5.10 Generalización de la función egen","text":"Hemos desarrollado una función de egen que permite calcular un rango entre percentiles para una lista de variables especifica. Puede ser útil tomar ventaja de egen pctile() para poder calcular cualquier percentil de la lista de variables especificadas. Vamos agregar dos opciones la función egen : lo() y hi(). En caso de que especifiquemos, por defecto se calcula el rango interquartil. La función de egen ahora se llamará _gpctrange.ado.Función egen más general para percentiles:","code":"* Programa con opción by. \nprogram drop _all\nprogram _gpctrange\nsyntax newvarname =/exp [if] [in] [, LO(integer 25) HI(integer 75) *] \n\nif `hi' > 99 | `lo' < 1 {\n    display as error ///\n        \"Percentiles `lo' `hi' deben estar entre 1 y 99.\" \n    error 198 \n}\nif `hi' <= `lo' {\n    display as error ///\n            \"Percentiles `lo' `hi' deben estar en orden ascendente\"\n    error 198 \n}\ntempvar touse phi plo \nmark `touse' `if' `in' \nquietly {\n          egen double `phi' = pctile(`exp') if `touse', `options' p(`hi') \n          egen double `plo' = pctile(`exp') if `touse', `options' p(`lo')\n          generate `typlist' `varlist' = `phi' - `plo' if `touse' \n          } \nend\n\nsysuse auto, clear\nbysort rep78: egen iqr = pctrange(price) if inrange(rep78,3,5)\nbysort rep78: egen p8020 = pctrange(price) if inrange(rep78,3,5), hi(80) lo(20)\nbysort rep78: egen p8020 = pctrange(price) if inrange(rep78,3,5) ///\n& foreign==1, hi(80) lo(20)\n\n* Utilizar estas nuevas variables con otros comandos\ntabstat iqr if inrange(rep78, 3, 5), by(rep78)\ntabstat p8020 if inrange(rep78, 3, 5), by(rep78)"},{"path":"análisis-de-datos-con-stata.html","id":"documentar-tu-programa","chapter":"2 Análisis de datos con Stata","heading":"2.5.11 Documentar tu programa","text":"Escribir un helpEs necesario y recomendado mantener una documentación de los programas que se escriban para un proyecto.Esta documentación debe estar actualizada e incluir cualquier modificación. Importante hacerlo mientras se hace el programa y al final.Vamos aprender un poco de SMCL (Stata Markup Control Language file). Básicamente es el lenguaje con el que se escriben los help en Stata. También es el lenguaje con el que se muestran los resultados de display.Los archivos se pueden escribir en cualquier procesador de texto, pero deben ser guardados en formato .smcl. También deben ser guardados en la misma carpeta en donde se encuentra el ado-file relacionado con el archivo.Hay que empezar los códigos con \\(\\{smcl\\}\\) con el fin de indicarle Stata que el texto que viene será en formato SMCL.Las etiquetas de SMCL van entre llaves (\\(\\{\\}\\)) y se pueden leer de dos formas principalmente:\n\\(\\{tag:text\\}\\) etiquetar el texto que se esta escribiendo.\n\\(\\{tag\\}\\) etiquetar todo lo que viene hasta que se cambie en otra parte del texto.\n\\(\\{tag:text\\}\\) etiquetar el texto que se esta escribiendo.\\(\\{tag\\}\\) etiquetar todo lo que viene hasta que se cambie en otra parte del texto.Por ejemplo, si quiero poner texto en itálica tengo que ocupar la etiqueta :Etiquetas de SMCLTexto: {}, {bf}, {sf}, {ul}. Itálica, negrita, texto normal, subrayado, repectivamente.Texto en formato Stata: {cmd}, {error}, {result}, {text}.{Destacar una referencia: {hi}.Opciones de comando: {opt}.Insertar linea horizontal: {hline}.Volver dejar el texto su estado normal: {reset}.Formato de documento: {title:text}, {center}, {ralign}, {lalign}, {tab}.Párrafos: Hay dos opciones para escribirlos.\n{p #1 #2 #3 #4}.\n{p} = {p 0 0 0 0}\n{p #1 #2 #3 #4}.{p} = {p 0 0 0 0}Los números indican los siguientes elementos de un párrafo:\nEl primer número (#1) es cuántos caracteres hay que sangrar en la primera línea.\nEl segundo número (#2) es cuántos caracteres hay que sangrar en la segunda y tercera línea.\nEl tercer número (#3) es cuán lejos de la derecha debe estar el margen.\nEl cuarto número (#4) es para el ancho total del párrafo.\n{phang}: es equivalente {p 4 8 2}.\n{pstd}: es equivalente {p 4 4 2}.\n{phang2}: es equivalente {p 8 12 2}.\n{p2col}: Para separar el texto en dos columnas.\n{p_end}: Para terminar un párrafo. Útil cuando tienes dos parrafos en formatos distintos.\nEl primer número (#1) es cuántos caracteres hay que sangrar en la primera línea.El segundo número (#2) es cuántos caracteres hay que sangrar en la segunda y tercera línea.El tercer número (#3) es cuán lejos de la derecha debe estar el margen.El cuarto número (#4) es para el ancho total del párrafo.{phang}: es equivalente {p 4 8 2}.{pstd}: es equivalente {p 4 4 2}.{phang2}: es equivalente {p 8 12 2}.{p2col}: Para separar el texto en dos columnas.{p_end}: Para terminar un párrafo. Útil cuando tienes dos parrafos en formatos distintos.","code":"* Una palabra/frase en particular\n{it:este texto aparecerá en itálica}\n\n* Todo el bloque de texto\n{it} Todo lo que este aquí aparecerá en itálica. ///\nEsto va a ocurrir hasta que aparezca un nuevo ///\ntipo de etiqueta. "},{"path":"análisis-de-datos-con-stata.html","id":"escribir-programas-e-class","chapter":"2 Análisis de datos con Stata","heading":"2.5.12 Escribir programas e-class","text":"Vamos aprender algunos elementos que nos van permitir escribir nuestros propios comandos de estimación en Stata. Muchos de los conceptos que hemos visto aplican también para este tipo de comandos. Es necesario recordar algunas convenciones que nos van ser útiles para poder escribir nuestros programas.Los resultados se guardan en |e() y se puede acceder ellos con ereturn list.El número de observaciones es e(N) y para identificar que observaciones fueron incluidas en la estimación es necesario utilizar la función e(sample).Los coeficientes estimados se guardan en un vector e(b) y la matriz de varianza covarianza se guarda en e(V).El comando ereturn name = exp retorna un escalar, mientras que ereturn local name value y ereturn matrix name matname retorna una macro y una matriz respectivamente.El comando ereturn post envía las estimaciones de b y V sus ubicaciones oficiales.Para devolver el vector de coeficientes y su matriz de varianza, es necesario crear el vector de coeficientes, digamos \\(beta\\), y su matriz de varianza-covarianza, digamos \\(vce\\).También podemos definir la muestra de estimación incluida en la estimación con touse. Ahora es posible guardar los elementos en e(). Por ejemplo, es posible utilizar ereturn scalar, ereturn local o ereturn matrix.Es conveniente utilizar los nombres típicamente asignados para guardar resultados de los programas e(df_m) o e(df_r). Sin embargo, se pueden nombrar como deseen.","code":"ereturn post `beta' 'vce', esample(`touse')"},{"path":"análisis-de-datos-con-stata.html","id":"programar-ado---files-parte-iii","chapter":"2 Análisis de datos con Stata","heading":"2.6 Programar ado - files (Parte III)","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"marksample-mark-y-markout","chapter":"2 Análisis de datos con Stata","heading":"2.6.1 Marksample, Mark y Markout","text":"marksample y mark son alternativas. mark es muy utilizado. Ambos comandos crean un indicador que marcan que observaciones será utilizadas. Los ocupadmos en los programas en Stata. La idea es indicarle al programa la muestra relevante. markout marca la variable con un indicador igual 0 si cualquier variable en varlist indicada contiene un missing.Marksamplemarksample se utiliza en programas en los que los argumentos se analizan mediante el comando syntax.Crea una variable temporal, almacena el nombre de la variable temporal en un local, y rellena la variable temporal con 0 y 1 según si la observación debe ser utilizada.Markmark utiliza la variable temporal touse basada en las expresiones de e .Si hay expresiones de e , touse será 1 para cada observación en los datos.Si indico una condición, solo las observaciones que cumplan esta condición tendrán un 1 en touse.Mark actualiza touse de forma tal de que revisa missing.Mark y Markoutmark parte con una variable temporal previamente creada.markout modifica la variable creada por mark poniéndola cero en las observaciones que tienen valores perdidos registrados para cualquiera de las variables en varlist.Marksample vs. Markoutmarksample es mejor que mark. Disminuye la probabilidad de que se olvide alguna restricción.markout puede ser utilizados después de mark o bien marksample.markout también puede ser usado con marksample:Ejemplo Marksample y Markout:","code":"program ....\nsyntax ...\nmarksample touse\nrest of code .... if `touse'\nendprogram ....\ntempvar touse\nmark `touse' ...\nmarkout `touse' ...\nrest of code ... if `touse'\nendprogram ...\ntempvar touse\nmark `touse' ...\nmarkout `touse' ...\nrest of code ... if `touse'\nend\n\nprgraom myprog\nsyntax varlist [if] [in]\nmarksample touse\n...\nend\n\n* Equivale a: \nprogram myprog\nversion 17.0\nsyntax varlist [if] [in]\ntempvar touse\nmark `touse' `if' `in'\nmarkout `touse' `varlist'\n...\nendprogram ...\nsyntax ... [, Denom(varname) ... ]\nmarksample touse\nmarkout `touse' `denom'\nrest of code ... if `touse'\nendprogram cwsumm\nsyntax [varlist(fv ts)] [if] [in] [aweight fweight] [, Detail noFormat]\nmarksample touse\nsummarize `varlist' [`weight'`exp'] if `touse', `detail' `format'\nend"},{"path":"análisis-de-datos-con-stata.html","id":"sortpreserve","chapter":"2 Análisis de datos con Stata","heading":"2.6.2 Sortpreserve","text":"Si está escribiendo un programa de Stata que cambia temporalmente el orden de los datos y quieres que los datos se ordenen en su orden original al final de la ejecución, puede ahorrar un poco de programación incluyendo sortpreserve. Para ellos debemos escribir: program miprograma, sortpreserve. Stata automáticamente reordenara las variables como estaban originalmente. Al agregar esta opción se genera una variable temporal llamada _sortindex la que contiene el orden original de los datos.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"mata","chapter":"2 Análisis de datos con Stata","heading":"2.6.3 Mata","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"qué-es-mata","chapter":"2 Análisis de datos con Stata","heading":"2.6.3.1 ¿Qué es Mata?","text":"Esta introducción esta basada en la guía de Asjad Naqvi.Mata es un lenguaje de programación matricial.Es más rápido que Stata, pero necesita más precisión (ej. dimensiones de las matrices).Muchos de los operadores de Mata son similares R o Matlab. Adicionalmente, incluye sus propios optimizadores y funciones útiles.Esta sección será una pequeña introducción al lenguaje. Tiene como objetivo mostrarles el abanico de herramientas que Mata posee con el fin de que puedan utilizarlo para hacer sus propios programas.La sintaxis básica de MataSi son utilizados dos puntos y ocurre un error, Mata será abortado, volverá Stata y aparecerá un mensaje de error.Para buscar ayuda, podemos hacer:Comandos básicos:Al igual que Stata, Mata posee sus propios comandos. Algunos útiles de recordar son:Para hacer comentarios en Mata hay que utilizar //. funcionan los asteriscos como en Stata. Todo los que se genera en Mata queda en la memoria menos que Stata se cierre, se use clear allen Stata o bien mata: mata clear. Todas las matrices y funciones definidas se mantienen en el espacio de trabajo de Mata espacio de trabajo cuando se termina mata y se puede acceder ellas cuando se vuelve entrar en\nmata.","code":"* Opción 1 \nmata \n\n< comando de mata 1 > \n< comando de mata 2 >\n< y así .... > \nend \n\n* Opción 2 \nmata <un comando de mata>\n \n* Opción 3 : la versión estricta\nmata: <un comando de mata> \n  * Ejemplo 1\nmata \nemat = 7 + 3\nemat \nend\n\n* Ejemplo 2\nmata \nemat = (\"Josefa\", \"Perez\")\nemat = (21\\8)\nmmat = (17\\6)\nvmat = (25,3\\3,11)\nemat, mmat, vmat \nend* Ejemplo 1\nhelp mata comando\nhelp mata cholesky()mata describe \nmata clear \nmata rename nombre\nmata drop nombre1 nombre2\nmata stata\n\n* Ejemplo\nmata \nmata clear \nemat = (\"Josefa\", \"Perez\")\nemat = (21\\8)\nmmat = (17\\6)\nvmat = (25,3\\3,11)\nmata describe \nemat, mmat, vmat\nmata rename vmat vmat_renombrada\nmata drop mmat\nemat, vmat_renombrada\nend"},{"path":"análisis-de-datos-con-stata.html","id":"matrices","chapter":"2 Análisis de datos con Stata","heading":"2.6.3.2 Matrices","text":"Una forma común de generar una matriz en Mata es importándola desde los datos de Stata.Definimos la matriz X, que tiene todas las observaciones (filas) y dos columnas var1 y var2. st_ permite Mata interactuar con la interfaz de Stata con el fin de pasar información de un lado otro. Revisar help m4_stata.Otra opción es definir matrices dentro de Mata.Definimos la matriz , la cual podemos ver escribiendo mata . Veremos una matriz cuadrada de 2x2. Notar que la coma separa elementos entre columnas mientras que el slash mueve elementos entre filas. El uso de paréntesis es opcional en Mata, pero es más conveniente y es una buena práctica de estilo utilizarlos. También se pueden definir matrices especiales.Finalmente, uno puede generar matrices similar lo que se hace en Stata.Este comando genera una matriz de 2x2 rellena de unos. La sintaxis genérica es: mata J(filas, columnas, constante). Para definir una matriz identidad: mata (5).Otro operador útil es range:Crea un vector que empieza en 1 y termina en 7 saltándose de 2 en 2 (es decir, (1,3,5,7)). Si quiero generar una matriz con números aleatorios provenientes de una distribución uniforme (0,1) : mata runiform(3,3).Accediendo los elementos de una matrizPodemos acceder los elementos de una matriz.\nmata [1,2]: fila 1, columna 2.\nmata [1,.]: Todas las columnas de la fila 1.\nmata [.,2]: Todas las filas de la columna 2.\nmata [1,2]: fila 1, columna 2.mata [1,.]: Todas las columnas de la fila 1.mata [.,2]: Todas las filas de la columna 2.También podemos extraer sub-conjuntos de elementos:Pegando elementos de matrices:,B las pega horizontalmente, es decir por columnas (filas son las mismas). \\B las pega vertical, es decir por filas (columnas son las mismas).Operaciones básicas entre matrices y por elementos: Una vez definidas las matrices, también se dedica bastante tiempo sumar, restar, multiplicar y dividir matrices entre sí. Vamos ver algunas operaciones entre matrices y también entre elementos.* B es una operación entre matrices, de forma tal que el número de filas de debe ser igual al número de columnas de B. Si queremos que cada elemento de sea multiplicado por el mismo elemento en B, es necesario trasponer alguna matriz y cambiar el operador.En el primer caso la matriz resultante corresponde una matriz de 3x2, en el segundo caso es una matriz de 2x3.Operadores lógicos y funciones sobre escalares: Las matrices también pueden ser comparadas través de operadores lógicos. == B chequea si dos matrices son iguales. Esto también puede hacerse elemento por elemento (por ejemplo :>=B). Tambien se puede utilizar !=.Mata también tiene funciones sobre escalares:Algunas funciones para operar en matrices son:Mata contiene varias funciones para extraer propiedades de las matrices:Mata contiene varias funciones para operar o manipular dos matrices:Al igual que Stata, Mata puede utilizar iteradores. loop:Loops:Los valores iniciales y finales pueden extraerse de algunas declaraciones condicionales como las dimensiones de las matrices. Mata sólo permite incrementos de 1.Notar que aquí es bien distinto Stata:/else son:Mata también permite abreviar la sintaxis en caso de que existan dos o mas condiciones.“” es la condición, “b” es el valor en caso de que sea verdadero y “c” en caso de que sea falsa. Para el ejemplo, la condición sería: (x > ? 1 : 0).","code":"mata: X = st_data(.,(\"var1\", \"var2\"))* Ejemplo 4: confeccionar matrices en base a mata\nsysuse auto.dta\nmata\nmata clear \nmata: X = st_data(.,(\"price\", \"mpg\"))\nX\nmata describe\nend mata A = (1,2 \\ 3,4)* Vector fila o Vector columna\nmata 1,2,3\nmata 1\\2\\3\n\n* Vector fila o Vector columna del 1 al 4\nmata 1..4\nmata 1::4mata J(2,2,1)mata range(1,7,2)* Empezar de fila 2 columna 1 hasta fila 3 columna 3\nmata A[|2,1\\3,3|]       \n* Tomar filas 2 y 3 y columnas de la 1 a la 3.\nmata A[(2::3),(1..3)]   mata\nA = runiform(1,2)\nB = runiform(1,2)\n\n* Opción 1 : pegar horizontalmente\nA,B   \n* Opción 2 : pegar verticalmente\nA\\B   \nendmata\n A = (1,2,3\\4,5,6)\n B = (2,3\\4,5\\6,7)\n A * B\nendmata\n A = (1,2,3\\4,5,6)\n B = (2,3\\4,5\\6,7)\n  A' :* B\n  A  :* B'\nendmata\n  X = (-2, 1 \\ 0, 5)\n  abs(X)   // valor absoluto de cada elemento\n  sign(X)  // signo de cada elemento\n  exp(X)   // exponencial de cada elemento\n  sqrt(X)  // raíz cuadrada de cada elemento\n  sin(X)   // seno de cada elemento\nendmata\nA = (5,4\\6,7)\nB = (1,6\\3,2)\nend\n\n* Número de filas y columnas \nmata rows(A)\nmata cols(A)\n\n* Suma de las filas/columnas\nmata rowsum(B)\nmata colsum(B)\n\n* Calcular el promedio (retorna un vector fila)\nmata mean(B')' \n\n* Seleccionar todas las columnas sin ceros\nmata D = (1,0,2,3,0)\nmata selectindex(D) \n\n* Select para condiciones más flexibles\nselect(B, B[.,1]:>2)\n\n* Ordenar matrices \nmata sort(B,2)  // Ordena según la columna 2 de B\nmata jumble(B) // Aleatoriza las filas de Bmata\nA = (5,4\\6,7)\ndet(A)         // Determinante de A\ninvsym(A)      // Ibversa de A\ntrace(A)       // Traza de A\nrank(A)        // Rango de A\nnorm(A)        // Norma de A\nX=.            // Vectores propios\nL=.            // Valores propios\nendmata\nA = (5,4\\6,7)\nB = (1,6\\3,2)\nA' * B            // A x B\ncross(A,B)        // A x B using a solver (faster)\nendmata\n  x = 1                  // Valor inicial\n  X = 4                  // Valor final\n  while (x <= X) {       // Iniciar condición del while\n  printf(\"\\%g \\n\", x)     // Alguna operación de Mata aquí\n  x++                    // Incremental\n  }                      // Terminar el while\nend* Este for\nfor (expr1; expr2; expr3) {\nstmts\n}\n* Es equivalente a \nexpr1\nwhile (expr2) {\nstmt\nexpr3\n}mata\n   N = 4                      // Valor final\n   for (i=1; i<=N; i++) {     // for loop \n   printf(\"%g \\n\", i)         // some Mata operation here\n   }                          // end for loop\nendmata\n x = 3                       // Valor de x\n   \n  for (i=1; i<=5; i++) {     // Empezar el loop\n    if (x > i) {             // if\n      printf(\"\\%g\\n\", 0)      // Comando de mata si la condición se cumple\n      }\n    else {                   //  en caso contrario\n      printf(\"\\%g\\n\", 1)      // ejecutar este comando de mata\n      }\n  }\nend(a ? b : c)"},{"path":"análisis-de-datos-con-stata.html","id":"de-stata-a-mata","chapter":"2 Análisis de datos con Stata","heading":"2.6.3.3 De Stata a Mata","text":"Estimar un MCO: Un ejemplo estándar es hacer un simple OLS en Mata.LoopsEn Mata, la variable dependiente se importa como el vector y las variables independientes se importan como la matriz X. esta matriz X se le añade un vector columna de unos para el intercepto.Como el vector de unos debe tener el mismo número de filas que la matriz X, nótese el uso del operador J().En el último paso, las betas y los errores estándar se exportan Stata como matrices de Stata.","code":"sysuse auto, clear\nmata\n y = st_data(.,\"price\")\n X = st_data(.,(\"mpg\", \"weight\"))\n X = X, J(rows(X),1,1)\n    beta   = invsym(cross(X,X))*cross(X,y)\n    esq    = (y - X*beta) :^ 2\n    V      = (sum(esq)/(rows(X)-cols(X)))*invsym(cross(X,X))\n    stderr = sqrt(diagonal(V))\n      st_matrix(\"b\", beta)\n      st_matrix(\"se\", stderr)\nend"},{"path":"análisis-de-datos-con-stata.html","id":"funciones-en-mata","chapter":"2 Análisis de datos con Stata","heading":"2.6.3.4 Funciones en Mata","text":"Vector: Un ejemplo estándar es hacer un simple OLS en Mata.Matriz:Hacer opcionales:Guardar:Dos referencias recomendadas para profundizar en Mata:Introduction Stata Programming, Second Edition ()Mata Book: Book Serious Programmers Want ()","code":"* Generar un vector \nmata \nfunction zeros(c)\n{\n    a = J(c, 1, 0)\n    return(a)\n}\nb = zeros(3)\nb\nend * Generar una matriz\nmata \nfunction zerosv1(real scalar c, real scalar r)\n{\nreal matrix A \nA = J(c,r,0)\nreturn(A)\n}\nb = zerosv1(3,2)\nb\nend mata \nfunction zerosv2(real scalar c,| real scalar r)\n{\nreal matrix A\nif (args()==1) r = 1\nA = J(c, r, 0)\nreturn(A)\n}\nend \n\nmata \nzerosv2(3,2)\nend\n\nhelp m2 syntaxmata \nfunction zerosfinal(real scalar c,| real scalar r)\n{\nreal matrix A\nif (args()==1) r = 1\nA = J(c, r, 0)\nreturn(A)\n}\n\nmata stata cd \"\\$ejercicios\"\nmata mosave zerosfinal(), replace\n\nend "},{"path":"análisis-de-datos-con-stata.html","id":"exportar-información","chapter":"2 Análisis de datos con Stata","heading":"2.7 Exportar Información","text":"Exportar información es parte importante del proceso de análisis de datos. En esta sección veremos algunas herramientas que permiten conectar los resultados del análisis hecho en Stata con los reportes que queremos crear en Word.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"stata-markdown","chapter":"2 Análisis de datos con Stata","heading":"2.7.1 Stata Markdown","text":"Herramienta para crear informes que sean reproducibles y en donde los datos, códigos y operaciones están conectadas.Básicamente una intersección entre texto narrativo yEs posible generar informes en distintos formatos (ej. html, docx, pdf). Hoy veremos como generar un informe en Word y una presentación en HTML.Stata Markdown es especialmente útil para:\nInformes rutinarios: Informe semanas/mensual sobre un conjunto de datos que se actualizan constantemente.\nDocumentar análisis: Es posible integrar reportes intermedios en un trabajo de análisis de datos. Estos informes pueden ser de utilidad para detectar errores y para supervisión en equipos de trabajo.\nInformes rutinarios: Informe semanas/mensual sobre un conjunto de datos que se actualizan constantemente.Documentar análisis: Es posible integrar reportes intermedios en un trabajo de análisis de datos. Estos informes pueden ser de utilidad para detectar errores y para supervisión en equipos de trabajo.Stata Markdown y otras herramientas similares son claves para mejorar en términos de . Algunos argumentos basados en :Ayuda documentación: En la fase de procesamiento de datos podemos describir todos los pasos utilizados para convertir los datos brutos en variables de análisis, produciendo un documento con un buen formato, más claro y legible. Es posible pensar en estos informes como productos intermedios.En la fase de análisis de los datos, podemos incluir el código, explicar las razones para probar determinados modelos, incluir los resultados, las tablas y las figuras, y comentar los resultados, todo ello sin tener que cortar y pegar de forma tediosa y propensa errores.En la fase de presentación, podemos elaborar un informe centrado en los resultados, con la opción de ocultar los comandos reales utilizados para que aparezcan en el documento final.Algunos conceptosMarkdown: Es un lenguaje que permite escribir documentos en texto plano. Los archivos escritos en Markdown tienen la extensión md.Stata Markdown: Es la variación especifica para Stata. Se implementa través del comando markstat hecho por Germán Rodriguez. Estos archivos tiene extensión .stmd.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"instalación","chapter":"2 Análisis de datos con Stata","heading":"2.7.1.1 Instalación","text":"En Stata, ejecuta estos comandos:ssc install markstatssc install whereisInstalar padcoc desde pandoc.org/installingDecirle markstat donde encontrar pandoc. En mi caso es:","code":"whereis pandoc \"C:\\Users\\nicol\\AppData\\Local\\Pandoc\\pandoc.exe\""},{"path":"análisis-de-datos-con-stata.html","id":"funcionalidades","chapter":"2 Análisis de datos con Stata","heading":"2.7.1.2 Funcionalidades","text":"Algunos elementos que vamos utilizar en Stata Markdown:Ecuaciones y notación matemática utilizando (para los que lo sepan utilizar).Hacer títulos y encabezados.Enfatizar texto (negritas e itálicas).Armas listas numeradas y numeradas.Poder mostrar líneas de código, resultados directamente de Stata. Esto incluye Mata.Insertar quiebres de páginas: \\newpage.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"generar-un-documento","chapter":"2 Análisis de datos con Stata","heading":"2.7.1.3 Generar un documento","text":"Como mencionamos anteriormente es posible generar un documento de word, pdf o html que contenga todos los códigos, resultados, tablas y figuras hechas en Stata. Para generar un documento es necesario:Escribir en tu editor de códigos preferido un archivo en formato stmd. En nuestro caso escribiremos un archivo que se llama ejemplo1.stmd. Guardar el archivo en tu carpeta de trabajo.Ejecutar el comando markstat según el tipo de archivo que desee generar. En nuestro caso será:","code":"markstat using ejemplo1, strict docx"},{"path":"análisis-de-datos-con-stata.html","id":"putdocx","chapter":"2 Análisis de datos con Stata","heading":"2.7.2 Putdocx","text":"La ventaja de putdocx radica en que es posible personalizar un poco más las tablas. Esto permite conectar el informe final con el trabajo de análisis de datos.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"algunos-comandos-útiles","chapter":"2 Análisis de datos con Stata","heading":"2.7.2.1 Algunos comandos útiles","text":"Crear, pegar y guardar documentos:putdocx begin: Crea un archivo docx para exportar.putdocx describe: Describe los contenidos de archivo.putdocx save: Guarda y cierra el archivo.putdocx clear: Cierra el archivo sin guardar.putdocx append: Combina el contenido de múltiples archivos.Insertar quiebres de páginas:\n* putdocx pagebreak: Agrega una nueva página.\n* putdocx sectionbreak: Agrega una nueva sección.Agregar párrafos con texto e imágenes:\n* putdocx paragraph: Agrega un nuevo párrafo.\n* putdocx text: Agrega un bloque de texto un párrafo.\n* putdocx image: Agrega una imagen al párrafo.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"tablas","chapter":"2 Análisis de datos con Stata","heading":"2.7.2.2 Tablas:","text":"putdocx table: Crea una nueva tabla en el documento la que puede contener resultados de estimaciones, estadística descriptiva o datos.\nputdocx sectionbreak: Agrega una nueva sección.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"manejo-de-grandes-bases-de-datos-en-stata","chapter":"2 Análisis de datos con Stata","heading":"2.8 Manejo de grandes bases de datos en Stata","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"estilo-de-codificación-mejorar-velocidad-y-eficiencia","chapter":"2 Análisis de datos con Stata","heading":"2.8.1 Estilo de codificación: mejorar velocidad y eficiencia","text":"Esta introducción esta basada en Suggestions Stata programming style de Nicholas J. Cox.Un buen estilo de codificación es por sobre todo claridad. Lo más importante es tener una estrategia y seguirla. En esta sección nos enfocaremos en algunos consejos de codificación que nos van permitir mejorar la velocidad y eficiencia en el uso de Stata. Este punto es especialmente relevante cuando se trabaja con grandes bases de datos. Una lista de formas básicas de aumentar la velocidad y eficiencia al manejar grandes bases de datos:Testear siempre las condiciones claves. Hacerlo lo antes posible.Utilizar summarize, meanonly cuando solo necesite este valor. Como regla general siempre de preguntarme si lo que estoy obteniendo es útil o .Preferir foreach y forvalues sobre . Son más rápidos.Evitar el uso de macro shift. Con muchas variables, se vuelve muy lento. Mejor ocuapar un forvalues.Evitar siempre que sea posible iterar sobre observaciones. Mata puede ser útil en este aspecto.Evite usar preserve si es posible. Es atractivo para el programar pero puede ser costoso en tiempo cuando se utilizan grandes bases de datos. Es bueno profundizar en el uso de marksample con el fin de hacer programas efectivos.Las variables temporales se eliminarán automáticamente al final de un programa, pero también considere la posibilidad de eliminarlas cuando ya sean necesarias para minimizar la sobrecarga de memoria y reducir las posibilidades de que su programa se detenga porque hay espacio para añadir más variables.Especifique el tipo de las variables temporales para minimizar la sobrecarga de memoria. Si se puede utilizar una variable de bytes, especifique: generate bytes 'myvar' en lugar de dejar que se utilice el tipo por defecto, que desperdiciaría espacio de almacenamiento.Evite utilizar una variable para mantener una constante; una macro o un escalar suele ser todo lo que se necesita.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"cargar-grandes-bases-de-datos","chapter":"2 Análisis de datos con Stata","heading":"2.8.2 Cargar grandes bases de datos","text":"Cuatro aspectos que considerar siempre que se desee cargar en Stata alguna base de datos de un tamaño considerable:¿Necesita todas las variables del conjunto de datos? Si es así, cargue sólo las variables que necesite:¿Necesita todas las observaciones del conjunto de datos? Si es así, importe sólo las observaciones que necesite:¿Su conjunto de datos ocupa más espacio de almacenamiento del necesario?:Intenta leer tu conjunto de datos poco poco y optimizarlo.Además de solo importar determinadas observaciones o variables, se optimiza el espacio de almacenamiento utilizado compress.Es posible inspeccionar la base de datos sin cargarla.¿Su conjunto de datos contiene muchas observaciones idénticas?: Debe transformar el conjunto de datos en un conjunto de datos ponderado por frecuencia.","code":"use var1 var2 var3 var4 using data1, clearuse data1 if state <= 9, cleardescribe using data.1.dta"},{"path":"análisis-de-datos-con-stata.html","id":"reducir-el-uso-de-memoria","chapter":"2 Análisis de datos con Stata","heading":"2.8.3 Reducir el uso de memoria","text":"Cuando usted trabaja con un conjunto de datos en Stata, Stata debe cargar todo el conjunto de datos en la memoria de la computadora (RAM). Afortunadamente, las computadoras portátiles de hoy tienen más memoria que la mayoría de los servidores de hace 20 años, y la mayoría de la gente nunca tiene que preocuparse por la cantidad de memoria que Stata está utilizando.¿tengo que preocupar de la memoria?Sólo tienes que preocuparte por la memoria si el tamaño de tu conjunto de datos se aproxima la cantidad de memoria del ordenador que utilizas, y si es mayor, definitivamente tienes un problema.Si usted trabaja con grandes conjuntos de datos, debe tener cuidado: tratar de usar más memoria de la que tiene terminará mal.¿Cuando es mucho?: un Laptop tipico tiene 16gb.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"reducir-el-tamaño-de-la-base-de-datos","chapter":"2 Análisis de datos con Stata","heading":"2.8.4 Reducir el tamaño de la base de datos","text":"Elimina datos innecesarios. Utiliza tipos de variables pequeños: help datatypes. Siempre que crees una variable es una buena practica especificar el tipo de dato. Acortar cadenas o codificarlas: strings requieren un byte por caracteres.Sin embargo, para las observaciones todas tienen el mismo tamaño. Si tengo una variable que contiene: “Si”, “”, “lo se”. La variable utilizara 8 bytes por observación tal como si solo tuviese “lo se”. Si tu cambias “lo se” por “ns”. Ahora solo se utilizaran 2 bytes por observacion. Si tu cambias : “S”, “N”, “” solo utilizara un byte por observación.Codificar la variable de string como una variable númerica tambien reduce el espacio en memerio un byte por observación. Se recomiendo agregar labels y trabajar los string de esta forma cuando sea posible.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"eliminar-siempre-resultados-intermedios-incluso-temporales","chapter":"2 Análisis de datos con Stata","heading":"2.8.5 Eliminar siempre resultados intermedios, incluso temporales","text":"Elimina resultados intermedios. Si creas variables para almacenar resultados intermedios, elimínelas tan pronto como haya terminado con ellas.Por ejemplo, el siguiente código crea una variable llamada incomePovertyRatio sólo para poder crear una variable indicadora lowIncome que identifica los sujetos cuyos ingresos son inferiores al 150% del nivel de pobrezaDebes eliminar la variable que utilizas. Hacer esto siempre.","code":"gen incomePovertyRatio = income/povertyLevel\ngen lowIncome = (incomePovertyRatio < 1.5)\ndrop incomePovertyRatio"},{"path":"análisis-de-datos-con-stata.html","id":"dividir-en-trozos-cuando-sea-posible","chapter":"2 Análisis de datos con Stata","heading":"2.8.6 Dividir en trozos cuando sea posible","text":"Si un conjunto de datos es demasiado grande para cargarlo en la memoria, para algunas tareas puede dividirlo en un conjunto de conjuntos de datos más pequeños y trabajar con ellos de uno en uno. Puede haber una variable categórica en el conjunto de datos de tal manera que un conjunto de datos separado para cada categoría funcionaría bien, o puede dividirlo por número de observación.Dividir el conjunto de datos en trozos más pequeños probablemente sólo tiene sentido si puedes reducir el tamaño de cada trozo para que al final puedas combinarlos todos en un único conjunto de datos que pueda cargarse en la memoria.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"sort","chapter":"2 Análisis de datos con Stata","heading":"2.8.7 Sort","text":"sort en Stata es razonablemente eficiente: un millón de valores aleatorios pueden ponerse en orden creciente en menos de 3 segundos con sort x. Sin embargo, el comando tiene una opción inversa para ordenar de mayor menor.gsort hace una ordenación decreciente de forma ineficiente - ordena de forma creciente en x, y luego ordena de forma creciente en menos _n. Esencialmente está haciendo:Es mejor negar por usted mismo antes de una ordenación creciente:","code":"  sort x\n  gen long sortvar = -_n\n  sort sortvar\n  drop sortvargenerate negx = -x\n  sort negx"},{"path":"análisis-de-datos-con-stata.html","id":"selección-de-muestra","chapter":"2 Análisis de datos con Stata","heading":"2.8.8 Selección de muestra","text":"Separar la selección de variables de la inclusión. Para minimizar la cantidad de memoria utilizada, necesitamos separar la decisión de selección de la muestra de la decisión de inclusión de la variable.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"precaución-con-reshape","chapter":"2 Análisis de datos con Stata","heading":"2.8.9 Precaución con reshape","text":"El comando reshape es inexplicablemente lento. 13 segundos por millón de observaciones en mi computadora. Es importante pensar en codificación y buscar más opciones para hacer reshape. Se puede escribir un archivo separado para cada año de datos, y luego concatenarlos en un largo conjunto de datos en unos 2 segundos.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"subexpresiones-comunes","chapter":"2 Análisis de datos con Stata","heading":"2.8.10 Subexpresiones comunes","text":"menudo, varias sentencias generate o replace tendrán subexpresiones comunes.Una mejor opcion es precalcularlo.","code":"generate y = a if c==d & e==f\ngenerate x = b if c==d & e==fgenerate smpl = c==d & e==f\ngenerate y = a if smpl\ngenerate x = b if smpl"},{"path":"análisis-de-datos-con-stata.html","id":"recomendaciones-adicionales","chapter":"2 Análisis de datos con Stata","heading":"2.8.11 Recomendaciones Adicionales","text":"","code":""},{"path":"análisis-de-datos-con-stata.html","id":"collapse","chapter":"2 Análisis de datos con Stata","heading":"2.8.11.1 Collapse","text":"collapse es muy rápido. El autor, sin duda, supuso que aunque se utilizara con grandes conjuntos de datos, estaría dentro de una iteración. Pero veces lo está, y puede convertirse en el paso limitante de la velocidad en un programa de larga duración. Se puede reemplazar fácilmente con código más rápido, pero el beneficio total es tan grande como uno esperaría. Mejor ocupar gtools.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"egen","chapter":"2 Análisis de datos con Stata","heading":"2.8.11.2 Egen","text":"egen tambien puede ser adecuado para que funcione más rapido. Vamos ver un ejemplo calculando el máximo de una variable.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"regresiones-en-sub-grupos","chapter":"2 Análisis de datos con Stata","heading":"2.8.11.3 Regresiones en sub-grupos","text":"Exiten varias opciones para calcular regresiones según el tipo de datos que queramos incluir en nuestra muestra. Vamos ver distintas opciones y ver su desempeño en bases de datos grandes.","code":""},{"path":"análisis-de-datos-con-stata.html","id":"recode","chapter":"2 Análisis de datos con Stata","heading":"2.8.11.4 Recode","text":"recode puede ser modificado utilizando matrices. Otra opción es utilizar ggtools","code":""},{"path":"análisis-de-datos-con-stata.html","id":"resumen","chapter":"2 Análisis de datos con Stata","heading":"2.8.12 Resumen","text":"Utilizar compress.\nMantener solo las variables que se van utilizar.Mantener solo las observaciones que se van utilizar.Cargar solo las variables y observaciones necesarias.keepusing y nogen siempre para merge.ftools y gtools (más detalles sección final).Utilizar parallel (más detalles sección final).","code":""},{"path":"referencias.html","id":"referencias","chapter":"3 Referencias","heading":"3 Referencias","text":"","code":""}]
