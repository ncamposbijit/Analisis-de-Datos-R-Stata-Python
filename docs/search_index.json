[["análisis-de-datos-con-r.html", "2 Análisis de datos con R 2.1 Introducción a R y RStudio 2.2 Herramientas de programación 2.3 Manipulación de bases de datos (Parte I) 2.4 Manipulación de bases de datos (Parte II) 2.5 Manipulación de bases de datos (Parte III) 2.6 Análisis de datos 2.7 Visualización 2.8 Análisis de datos y generación de informes con R Markdown", " 2 Análisis de datos con R 2.1 Introducción a R y RStudio 2.1.1 ¿Por qué utilizar R como lenguaje de programación? Código abierto: Licencia no tiene costo. Versátil: análisis estadístico y econométrico + tareas de programación útiles (ej. web - scraping). Flexible y reproducible: garantiza reproducibilidad, es flexible ante cambios y detección de errores. Demandado: Lenguajes de programación de código abierto son solicitados cada vez más en el mercado laboral. 2.1.2 Términos clave y recurrentes a lo largo del curso RStudio: Interfaz Gráfica para el usuario. Esta diseñada para un uso más sencillo de R. Objetos: Cualquier cosa que guardes en R. Por ejemplo: bases de datos, variables, listas de nombres, gráficos. Funciones: Una operación producida por un código tal que acepta insumos y retorna productos. Paquetes: Es un conjunto de funciones agrupadas según su objetivo. Scripts/Códigos: Documento que contiene todos los comandos utilizados en un proceso de análisis de datos. 2.1.3 Recursos de Aprendizaje Hojas de resumen: material disponible con un resumen de los principales comandos/paquetes/funciones para distintos temas. Disponibles en: https://www.rstudio.com/resources/cheatsheets/ Foros y sitios web: Stackoverflow. Medium. El Blog de RStudio. Libros: R for Data Science. Recursos sobre R en español. Bookdown. 2.1.4 Interfaz RStudio 2.1.4.1 Cuatro secciones en Rstudio Las fundamentales son: Scripts, Console, Environment/Files/Help. Scripts: Donde desarrollaremos los códigos. Es un cuarderno. Console: Donde veremos los resultados. Environment: Donde veremos los datos y la información que vamos generando. Files: Donde veremos los archivos asociados a nuestros proyectos. Help: Donde desarrollaremos los códigos. Es un cuarderno. Para personalizar RStudio hay que ir a: Tools -&gt; Global Options. Allí pueden cambiar el color del ambiente, tipo de letra, orden. La idea es utilizar RStudio de la forma mas intuitiva posible. 2.1.4.2 Escribir comentarios Es muy importante escribir comentarios a lo largo de los códigos. Tambíen es importante saber escribir buenos comentarios. Una buena guía que habla un poco de eso y de muchas cosas más es: Code and Data for the Social Sciences: A Practitioner’s Guide. (#) para escribir comentarios en el script. Si quiero marcar varias lineas como comentario: ctrl + shift + c 2.1.4.3 Índices Es importante escribir índices para documentar sus códigos. Para observarlo debo escribir: ctrl + shift + o Los títulos pueden estar jerarquizados: # El mas importante ## Este es un poco menos importante ### Este es un poco menos importante que el anterior #### El menos importante Es importante actualizarlo constantemente para no perder funcionalidad. 2.1.5 Instalación de paquetes y ayuda Los paquetes son basicamente conjuntos de funciones. Los paquetes se instalan una vez, pero se llaman siempre que se vayan a utilizar. 2.1.5.1 Librerías Esto se puede hacer de dos maneras: Desde la pestaña packages en la esquina inferior derecha. Con comandos install.packages(&quot;dplyr&quot;) Varios paquetes a la vez: install.packages(c(&quot;dplyr&quot;,&quot;ggplot2&quot;,&quot;rio&quot;)) Error común: install.packages(&quot;dplyr&quot;, &quot;ggplot2&quot;) Por lo general es bueno instalarlas desde el inicio del trabajo dado que comúnmente usamos las mismas librerías al realizar análisis de datos. Con esta función le decimos a R que instale el paquete si este no está instalado (algo típico cuando cambiamos de computador): if(!require(dplyr)) {install.packages(&quot;dplyr&quot;)} Cargar librerías: library(dplyr) Si queremos ver que hay dentro de cada paquete: ls(&quot;package:dplyr&quot;, all = TRUE) #ls = list objects Importante: el paquete debe ser instalado una vez, pero cargado cada vez que se utilice. Muchas veces hay actualizaciones. Para revisar e instalarlas. update.packages() Alternativamente puedo conectar paquete con función utilizando ::. Si hago esto no es necesario llamar a la librería para utilizar esa función en particular. No obstante, lo recomendable es cargar todas las librerías de los paquetes que voy a utilizar al inicio. 2.1.5.2 Función de ayuda Sobre una función en particular: help(mean) ?mean mean #pulsar la tecla F1 sd Sobre un paquete en particular: help(&quot;dplyr&quot;) library(help=&quot;dplyr&quot;) 2.1.5.3 Shortcuts útiles Esc: interrumpir el comando actual Ctrl + s: guardar tab: autocompletar Ctrl + Enter: ejecutar línea Ctrl + Shift + C: comentar &lt;-: Alt + - / option + - %&gt;%: ctrl + shift + m (pipe) Ctrl + l: limpiar Ctrl + alt + b: ejecutar todo hasta aquí (flechas en la consola me permiten ver los últimos comandos utilizados). Shift + lineas: seleccionar varias lineas Ctrl + f: buscar/remplazar Ctrl + \"flecha arriba\" en la consola: ver comandos utilizados. 2.1.5.4 Limpiar “environment” en R Eliminar todos los objetos: rm(list=ls()) Eliminar sólo un objeto: rm(data1) Si quiero limpiar la consola tengo que apretar Ctrl + L. 2.1.5.5 Identificar el paquete de una función Hay ocasiones en que queremos saber de que paquete es una función determinada. Para ello, revisar: https://sebastiansauer.github.io/finds_funs/ 2.1.5.6 Error común Por ejemplo: x &lt;- &quot;hola&quot; Noten que en la consola aparece un signo +. En estos casos RStudio se detiene porque probablemente se les olvido un ) o bien un #. En estos casos hay que corregir el error para ejecutar nuevamente y luego apretar esc en la consola para seguir ejecutando los comandos. 2.1.6 Manipulación de objetos 2.1.6.1 Usar R como calculadora/ejecutar comandos De manera separada (seleccionar las ordenes+ctrl+Enter): 2+2 3*5^(1/2) Ejecutar todas las instrucciones: 2+2 ; 3*5^(1/2) 3+4 5*4 8/4 6^7 6^77 log(10) log(1) sqrt(91) # raiz cuadrada round(7.3) # redondear Incluso grandes operaciones: sqrt(91) + 4892788*673 - (log(4)*round(67893.9181, digits = 2)) Incluso uso de números imaginarios: 2i+5i+sqrt(25i) 2.1.6.2 Creacion de objetos: asignaciones y funciones con el signo &lt;- asignamos valores. También se puede utilizar =, pero no es recomendable, ya que confunde. y &lt;- 2 + 4 y Las asignaciones son MUDAS. Si no las llamo, no aparecen en la consola. Lo anterior es una operación sencilla, pero lo que queremos es generar asignaciones con funciones. Podemos utilizar funciones. Las funciones son la parte central del uso de R. Algunas funciones vienen instaladas en R. Otras funciones hay que obtenerlas desde paquetes. También es posible escribir tus propias funciones (). Las funciones estan por lo general escritas en paréntesis, por ejemplo filter(). Hay ocasiones en que las funciones estan relacionadas con un paquete específico dplyr::filter(). Ejemplo 1: función simple sqrt(49) Ejemplo 2: sobre una base de datos summary(mtcars$mpg) Nota: mtcars viene incluidad en R. Para ver mas: data() Otra función: x &lt;- 2 y &lt;- 3 z &lt;-c(x,y) z Uso de funciones aritméticas: mean(z) median(z) Relaciones entre objetos: w &lt;- mean(z) Creación de objetos por asignación: a &lt;- 3+10 b &lt;- 2*4 Comparar objetos: a &gt; b Notar que las asignaciones son silenciosas: a b # o altenativamente utilizar print print(a) print(b) Creación de objetos usando funciones: valores &lt;- c(a,b) promedio &lt;- mean(valores) print(promedio) promedio Podemos escribir un promedio aquí usando función mean(): a &lt;- 2 b &lt;- 5 valores1 &lt;- c(a,b) promedio1 &lt;-mean(valores1) print(promedio1) Limpiamos datos nuevamente: rm(list = ls()) rm(promedio) 2.1.6.3 Creacion de objetos y asignaciones Es importante espaciar codigos. Definimos dos vectores utilizando la función c() educ &lt;- c(8,12,8,11,16,14,8,10,14,12) ingreso &lt;- c(325,415,360,380,670,545,350,420,680,465) Calculamos promedio, desviación estándar y correlación mean(ingreso) promedioingreso &lt;- mean(ingreso) sd(ingreso) sdingreso &lt;- sd(ingreso) cor(educ, ingreso) coreduing &lt;- cor(educ,ingreso) Graficamos plot(educ, ingreso) Estimar una regresión lineal lm(ingreso ~ educ) Ejercicio 2.1.1: Nombrar objetos De los siguientes ejemplos, ¿Cuáles son nombres de variables válidas en R? # min_height # max.height # _age # .mass # MaxLength # Min-length # 2widths # Calsius2kelvin 2.1.7 Tipos de objetos 2.1.7.1 Vectores R opera componente por componente, por lo que es muy sencillo poder trabajar con vectores y matrices. Para crear un vector utilizamos la funcion c() x &lt;- c(1,2,3,4,5) #o bien y &lt;- c(6:8) Veamos los vectores z &lt;- x + y z Supongamos los siguientes vectores: x&lt;-c(1:4) y&lt;-c(1:3) ¿Cuál es su longitud? length(x) length(y) Si no tienen la misma longitud, ¿cual sería el resultado de x + y? z &lt;- x + y z IMPORTANTE: En este caso R realiza la operación de todos modos, pero nos indica que hay una advertencia de que sus dimensiones difieren. Lo relevante de los vectores es que sólo se puede concatenar elementos del mismo tipo, de lo contrario R nos arroja error. x &lt;- rep(1.5:9.5,4) #genera repeticiones de los valores definidos y &lt;- c(20:30) x1 &lt;- c(1,2) x2 &lt;- c(3,4) x3 &lt;- c(x1,x2) x4 &lt;- c(c(1,2), c(3,4)) Subconjunto de un vector y[3] # obtener el tercer elemento y[2:4] y[4:2] y[c(2,6)] y[c(2,16)] 2.1.7.2 Matrices 2.1.7.2.1 Definir matrices Sintaxis general mi.matriz &lt;- matrix(vector, ncol = num_columnas, nrow = num_filas, byrow = valor_logico, dimnames = list(vector_nombres_filas, vector_nombres_columnas) ) Para crear matrices utilizamos la función matrix() x &lt;- matrix (data = c(1,2,3,4), nrow = 2, ncol = 2) x1 &lt;- matrix(c(1,2,3,4), 2, 2) No es necesario poner data=, pero por orden mental es mejor hacerlo. x x1 Notar que por DEFECTO rellena columna por columna. Podemos explicitar que queremos realizar la matriz fila por fila y &lt;- matrix(data = c(1:4), nrow = 3, ncol = 2, byrow = TRUE) y Podemos saber cual es la dimensión de x dim(y) dim(y)[1] # cantidad de filas dim(y)[2] # cantidad de columnas y&lt;- matrix(c(1,2,3,4), nrow=2, ncol=2, byrow=2) y Los va a repetir! y &lt;- matrix(c(1,2,3,4), nrow=2, ncol=3, byrow= 2) y Notar que el orden en cualquier matrix es filas x columnas. Podemos también omitir la cantidad de filas o columnas en la matriz y obtenemos el mismo resultado y &lt;- matrix(c(1:4), 2, byrow=T) y En el caso de crear matrices vacías hay que definir las dimensiones y &lt;- matrix(nrow=3, ncol=3) y #útil para los loops Darle nombre a las filas y columnas y &lt;- matrix (c(1:4), 2, byrow = FALSE, dimnames=list(c(&quot;X1&quot;,&quot;X2&quot;),c(&quot;Y1&quot;, &quot;Y2&quot;))) y Se puede realizar desde las funciones colnames y rownames colnames(x) &lt;- c(&quot;Variable 1&quot;, &quot;Variable 2&quot;) rownames(x) &lt;- c(&quot;a1&quot;, &quot;a2&quot;) x Añadir filas o columnas a una matriz w &lt;- c(5,6) 2.1.7.2.2 Unir matrices Unir mediante filas (queda con el nombre del vector la observación) z &lt;- rbind(x,w) z Unir mediante columnas z &lt;- cbind(x,w) z ¿Y si tienen diferente cantidad de filas y/o columnas? repite el vector o observaci?n con menor longitud x &lt;- matrix(c(1:9),3) x y &lt;- c(5,6) y z&lt;-rbind(x,y) z Podemos pasar un vector a una matriz x&lt;-1:10 x dim(x)&lt;-c(2,5) x Trasponer matrices: x &lt;- matrix(c(1:9),3) xtraspuesta &lt;- t(x) Potencialmente se pueden hacer muchas más operaciones que involucren matrices. Por ejemplo, subconjuntos de una matriz: segundo y cuarto elemento de la segunda fila: M &lt;- matrix(1:8, nrow=2) M M[1,1] M[1,] M[,2] M[2,c(2,4)] 2.2 Herramientas de programación 2.2.1 Objetos adicionales 2.2.1.1 Arreglos Crear arreglos: La única diferencia con matrices es que acepta mas de dos dimensiones. Para generarlos: mi.arreglo &lt;-array(vector, dimensiones, dimnames = etiquetas_dim) Para nombrarlos definimos etiquetas y luego las agregamos. Es mucho mejor y mas ordenado hacerlo así: dim1 &lt;- c(&quot;A1&quot;, &quot;A2&quot;) dim2 &lt;- c(&quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;, &quot;B4&quot;) dim3 &lt;- c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;) Ejemplo de arreglo: Defino un arreglo de 3 matrices de 2 (filas) x 4 (columnas) x &lt;- array(1:24, c(2,4,3), dimnames = list(dim1, dim2, dim3)) x Notar la tercera dimensión! Subconjuntos de un arreglo: x[Fila,Columna, Matriz] x[1,2,3] # 1 fila, 2da columna, 3ra matriz x[,,3] # 3era matriz completa x[,4,] # 4ta columna de todas las matrices x[,-1,2] # Todas las filas, sin la primera columna, de la matriz 2. x[-1,c(1,2),3] # Todas las columnas, sin la fila 1, de la matriz 3. x[-1,1:2,3] # Columnas 1 y 2, sin la fila 1, de la matriz 3. x[,,1]*2 2.2.1.2 Listas Las listas contienen elementos de diferente tipo: matrices, objetos, dataframes, vectores, etc. x &lt;- list(c(1:8), &quot;R&quot;, TRUE, 2+3i, 5L) x #separa todo componente Para acceder a un objeto dentro de la lista se debe utilizar DOBLE CORCHETE: x[[5]] x[5] Veamos un ejemplo de cómo trabaja: x &lt;- list(Titulacion = c(&quot;Economia&quot;, &quot;Administracion&quot;, &quot;Politica&quot;), Edad =c(25,23,27)) x Al nombrar los componentes dentro de la lista, podemos llamarlos sin necesidad de los corchetes: x$Titulacion x[[1]] x[[&quot;Titulacion&quot;]] x$Edad x[[2]] Como los componentes dentro de las listas tienen definida una naturaleza, podemos hacer operaciones con ellas también: x[[&quot;Edad&quot;]]*3 x$Edad[c(1,3)]*3 Finalmente, tambien podemos crear listas vacias (útil para rellenar utilizando iteradores): x &lt;-vector(&quot;list&quot;, length = 10) Ejemplo de una lista: Definimos una lista milista &lt;- list( # Primer elemento sera un vector hospitales = c(&quot;Van Buren&quot;, &quot;Gustavo Fricke&quot;, &quot;Salvador&quot;), # Segundo elemento sera un dataframe direccion = data.frame( calle = c(&quot;San Ignacio&quot;, &quot;Av. Alvarez&quot;, &quot;Av. Salvador&quot;), ciudad = c(&quot;Valparaíso&quot;, &quot;Viña del Mar&quot;, &quot;Santiago&quot;) ) ) milista Llamar a subconjuntos # Retorna el elemento de la lista milista$hospitales milista[2] # Retorna el elemento, pero sin nombre y como vector milista[[1]] milista[[&quot;hospitales&quot;]] # Elementos particulares milista[[1]][3] milista[[2]][,1] milista[[2]][1,] milista[[2]][1,2] Notar que es importante saber el tipo de dato. 2.2.1.3 Dataframes Crear un dataframe: Es básicamente una matriz donde filas y columnas tienen significado. Contiene tanto valores numericos, carácteres, variables categóricas, etc. datos &lt;- data.frame(Titulacion = c(&quot;Economia&quot;, &quot;Administracion&quot;, &quot;Administracion&quot;), Edad =c(25,23,27), ocupacion = c(1,0,1)) datos Esto es lo mas cercano a una base de datos. Es uno de los objetos básicos que veremos muchas veces a lo largo del curso. Dimensiones de un dataframe: Para ver las dimensiones hay que utilizar nrow(), ncol() o bien dim(). nrow(datos) ncol(datos) dim(datos) Notar que nrow() y ncol() tambien sirven para matrices. Subconjuntos de un dataframe: Al igual que en las matrices, utilizamos [ ] para acceder a elementos dentro de la base. datos[1,1] datos[,1] datos[,-2] datos[, c(1:2)] datos[, c(&quot;Titulacion&quot;)] # Tambien puedo ocupar $ para llamar. datos$Titulacion # Ojo que esto lo puedo hacer con todo summary(datos[,2]) summary(datos[,2])[3] summary(datos[,2])[&quot;Max.&quot;] Tibbles: Una version mas moderna de dataframes. Es la misma idea: lista de vectores con nombres. Altura &lt;- c(168, 177, 177, 177, 178, 172, 165, 171, 178, 170) Peso &lt;- c(88, 72, 85, 95, 71, 69, 61, 61, 51, 75) M &lt;- cbind(Altura, Peso) Paquete para trabajar con bases de datos (más detalles en secciones 2.3 y 2.4) install.packages(&quot;tidyverse&quot;) library(tibble) # Una libreria dentro de tidyverse. misdatos &lt;- as_tibble(M) misdatos # Podemos ver los nombres o bien estadistica básica de cada variable. names(misdatos) summary(misdatos) Agregar columnas a un dataframe: Podemos agregar variables a la base. Dos opciones: # Opción 1: utilizando $nombre_columna&lt;-vector datos$id &lt;- c(1:3) datos # Opción 2: utilizando el cbind (al igual que con matrices) id2&lt;-c(1:3) datos1 &lt;- cbind(id2,datos) datos1 Attach: Notación muy inconveniente misdatos$Altura misdatos$Peso Para evitar escribir datos cada vez que quiera llamar a una variable voy a utilizar la funcion attach(): attach(datos) # para comenzar # Ahora puedo llamar a sus variables sin utilizar datos nueva &lt;- Edad * ocupacion nueva &lt;- datos$Edad * datos$ocupacion nueva detach(datos) # para terminar Esta es una forma mucho mas conveniente de trabajar con dataframes o tibble en R. Ejercicio 2.2.1: Crear un dataframe Cree su primera base de datos. Debe armar una tabla igual a la figura. Tiene 5 minutos. Respuesta: ejer &lt;- data.frame(Tipo_animal = c(&quot;Perro&quot;, &quot;Perro&quot;,&quot;Gato&quot;,&quot;Perro&quot;, &quot;Gato&quot;,&quot;Gato&quot;,&quot;Gato&quot;), Color =c(&quot;Café&quot;,&quot;Blanco&quot;,&quot;Negro&quot;,&quot;Manchas&quot;,&quot;Café&quot;,&quot;Tricolor&quot;,&quot;Negro&quot;), Peso = c(7,5,3,4,2,5,4), Pasea=c(&quot;Sí&quot;,&quot;Sí&quot;,&quot;Sí&quot;,&quot;No&quot;,&quot;No&quot;,&quot;No&quot;,&quot;Sí&quot;)) 2.2.2 Acceder a elementos de un objeto 2.2.2.1 Vectores Para acceder a los elementos de un objeto debemos utilizar los corchetes [ ] # Veamos en un vector x&lt;-c(&quot;T&quot;, &quot;FALSE&quot;, 1:9,1+2i,&quot;t&quot;, &quot;c&quot;,&quot;a&quot;,6) class(x) # Podemos llamar a un objeto de un vector x[1] x[3] De esta manera podemos extraerlo o utilizarlo en diferentes operaciones. Pero sólo debe ser entre observaciones numericas: x[1]+x[6] #de lo contrario R nos arroja un error y&lt;-c(1:6, 1+2i) y[3]+y[7] #O podemos visualizar a x, pero sin el primer objeto x[-1] #O eliminar el primer objeto x&lt;-x[-1] x1 &lt;- x[-1] 2.2.2.2 Matrices Si analizamos los objetos de una matriz: w&lt;-matrix(1:9,3) w # Elemento [1,1] w[1,1] # Toda la primera columna w[,1] # Toda la segunda fila w[2,] # Dos columnas w[,1:2] # w[,-3] # Todas las filas menos la primera w[-1,] 2.2.2.3 Listas Si queremos llamar a un objeto dentro de una lista: z &lt;- list(c(1:8), &quot;R&quot;, T, 2+3i, 5L) z #separa todo componente Para acceder a un objeto dentro de la lista se debe utilizar doble corchete: z[[1]] #Y algo dentro de ese objeto z[[1]][5] #Tambien podemos analizar su clasificacion class(z[[1]]) #numerico #Si es numerico, entonces tambien podemos hacer operaciones z[[1]][3]*z[[1]][5] 2.2.3 Tipos de objetos y datos 2.2.3.1 Identificar tipos de objetos Veamos en un vector cualquiera x&lt;-c(&quot;T&quot;, FALSE, 1:9,1+2i,&quot;t&quot;, &quot;c&quot;,&quot;a&quot;,6) class(x) Como bien sabemos todo en R es un objeto. Para saber que tipo de objeto es puedo utilizar la función class(): class(datos) class (x) Note que class() identifico que es un “data.frame” y una lista. También puedo ver los tipos de elementos dentro de un determinado objeto. Para datos, existen 5 tipos principales, llamados: carácteres: texto. Se escriben con comillas (ej: “3”, “swc”). numéricos: numeros reales (ej. 2, 15.5). enteros: numeros enteros (“L” le dice a R que guarde esto como un entero). logical: valores logicos (ej. TRUE, FALSE). complejos: 1 + 4i (Numero complejos). 2.2.3.2 Identificar tipos de datos # 1. Carácteres z&lt;-c(&quot;a&quot;,&quot;b&quot;) class(z) # 2. Números enteros w&lt;-c(1L,2L,3L) #la L es para obligar que sea entero class(w) # 3. Numéricos w1 &lt;- c(1,2,3) class(w1) # Notar que la L lo obliga a ser entero ¿Qué ocurre si no coloco la L? # 4. Valores logicos v1 &lt;- c(TRUE, FALSE) class(v1) # Notar que si estan entre comillas son caracteres, no logical!. v&lt;-c(&quot;TRUE&quot;, &quot;FALSE&quot;) class(v) # 5. Números complejos t&lt;-c(1+2i,1+3i) class(t) Hay más clases: Date(fechas), Factor(variables categóricas), data.frame, tibble, list. 2.2.3.3 ¿Importan los tipos de los objetos? R intenta mantener dentro de un vector el tipo de objeto. Si es que tratamos de juntar distintos tipos de datos en un vector. Igualar a la clase. Por ejemplo, si intentamos generar un vector con texto y número/logical todo será texto: h &lt;- c(TRUE,&quot;a&quot;, TRUE, 2) h class(h) Si intentamos juntar un “Logical” con un número todo será número: h1 &lt;- c(TRUE,2,3) h1 class(h1) Aquí carácter todo se va a caracter: x &lt;- c(&quot;T&quot;, &quot;FALSE&quot;, 1:3, 1+2i, &quot;t&quot;, &quot;c&quot;, &quot;a&quot;) class(x) y &lt;- c(1:4) class(y) y &lt;- c(1,2,3,4) class(y) Si utilizo el operador : para crear vectores lo interpreta como un integer. 2.2.3.4 Forzar a R para que utilice un tipo de dato Forzar a R a llevar el vector solo a numérico: z &lt;- as.numeric(x) class(z) z as.numeric() fuerza al vector a solo tener números. Noten que remplaza los que no son numérico por NA. Forzar a R a llevar el vector solo a carácteres: z1 &lt;- as.character(y) class(z1) z1 Noten que ahora se agregaron las dobles comillas. Forzar a R a llevar el vector sólo a carácter. x z2 &lt;- as.logical(x) class(z2) z2 Noten que “T” fue aceptado como TRUE! 2.2.3.5 ¿Cómo saber que tipo de datos tengo? # Puedo preguntar a R sobre el tipo. is.numeric(y) # Es numerico? is.character(y) # Es caracter? is.logical(y) # Es logico? # La respuesta a esta pregunta va a ser un valor lógico class(is.numeric(y)) # También se puede utilizar la opcion `typeof` typeof(y) 2.2.3.6 Mayúsculas importan Como vimos en lasección anterior, R es sensible a las mayúsculas. Esto aplica para nombres de funciones, paquetes, comando y también para los datos. Por ejemplo: x &lt;- c(&quot;A&quot;, &quot;a&quot;,&quot;a&quot;,&quot;a&quot;, &quot;B&quot;, &quot;B&quot;,&quot;b&quot;, &quot;A&quot;) length(x) sum(x == &#39;a&#39;) sum(x == &#39;b&#39;) Para R las minúsculas y mayúsculas SI IMPORTAN!. 2.2.3.7 Carácteres especiales Vimos que existen nombres de variables no validos en R. Tambien existe un conjunto de caracteres invalidos. NA: Not Available (missing values) NaN: Not a Numbers (ej. 0/0) Inf: Infinito (1/0) -Inf: Menos infinito 0/0 -1/0 2.2.3.8 Missing values En R, los valores perdidos (“missing values”) se representan con el valor especial NA (letras mayusculas N y A - sin comillas). Para saber si tengo valores NA en un objeto, puedo ocupar la funcion is.na(): ejemplo &lt;- c(1,3,NA,4) is.na(ejemplo) ejemplo[!is.na(ejemplo)] # El resultado es un vector. Noten que es importante para utilizar algunas funciones: mean(ejemplo) mean(ejemplo, na.rm = TRUE) No funciona en el primer caso, si en el segundo. Veremos mas detalles sobre como tratar missing values (ej. recodificar) en las clases de manipulacion y analisis de datos. 2.2.3.9 Funciones útiles # Redondear round(x,digits = n) round(c(2.53, 3.52), 1) # Estadística simple x &lt;- c(1,2,3,4,5,6) mean(x) # promedio median(x) # mediana sd(x) # desviacion estandar sum(x) # suma del vector min(x) # Valor minimo max(x) # Valor maximo range(x) # rango summary(x) # resumen # Notar que tienen que ser vectores! mean(10, 6, 12, 10, 5, 0) mean(c(10, 6, 12, 10, 5, 0)) # En el primer caso sólo toma el primer valor! Ojo, siempre un vector. # Otras funciones seq(1,10,2 ) # Crear secuencias rep(c(1,2,3),10) # Repetir cut(x,2) # subdividir sample(x, size = 3, replace = TRUE) # Generar un aleatorio # El analisis de datos es... Altura = c(168, 177, 177, 177, 178, 172, 165, 171, 178, 170) Peso = c(88, 72, 85, 95, 71, 69, 61, 61, 51, 75) M = cbind(Altura, Peso) # Paquete para trabajar con bases de datos (más detalles en secciones 2.3 y 2.4) install.packages(&quot;tidyverse&quot;) library(tibble) # Una libreria dentro de tidyverse. misdatos &lt;- as_tibble(M) misdatos attach(misdatos) max(Altura) min(misdatos$Peso) detach(misdatos) 2.2.4 Herramientas en R 2.2.4.1 Escribir Códigos Algunos comentarios con respecto a la escritura de codigos: Siempre escribir comentarios autocontenidos. Siempre utilizar índice. Me permite reducir el código. Me permite ver donde estoy también en un código largo. Puedo verlo con ctrl + shift + O o bien en la esquina inferior izquierda del script. Separar códigos largos en varios códigos. Cada código debe tener un objetivo claro que debe explicar en una oración. Escribir códigos en bloques. Tres consejos básicos de estilo: utilizar _ para generar variables o bien otra convención. separar entre objetos y operaciones. 2.2.4.2 Condicionales y controladores de flujo Operadores básicos: rm(list=ls()) # Asignador a &lt;- 2 * 3 a a1 = 2 * 3 a1 # Nota: Nunca ocupar igual. # Igualdad TRUE == TRUE TRUE == FALSE # Nota: Para comparar elementos se utiliza doble igual &quot;==&quot;. # Desigualdad (!=) TRUE != FALSE &quot;Hola&quot; != &quot;Chao&quot; # Otros comparadores: &lt;, &gt; (&gt;=), (&lt;=) 3 &lt; 5 5 &gt; 8 5 &gt;= 5 # Nota: No confundir con &lt;- que es para asignar. TRUE &gt; FALSE # Noten que la respuesta en un logical. # En vectores y matrices vector1 &lt;- c(16,9,13) vector2 &lt;- c(10,12,15) # Comparar contra un escalar vector1 &gt; 10 vector2 &lt; 10 # Compararlos entre ellos vector1 &lt; vector2 # Veamos en una matriz matrix &lt;- matrix(c(vector1, vector2), byrow = TRUE, nrow = 2) matrix matrix &gt; 10 Operador %in%: Un operador muy útil para comparar valores y para evaluar rápidamente si un valor está dentro de un vector o marco de datos. rm(list=ls()) v1 &lt;- 3 v2 &lt;- 101 t &lt;- c(1,2,3,4,5,6,7,8) # El valor v1 ¿se encuentra dentro de t? v1 %in% t # Otro ejemplo.... mivector &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) &quot;a&quot; %in% mivector # Si no está en el vector da un FALSE &quot;h&quot; %in% mivector # Si le quiero preguntar si NO está, coloco un signo de exclamación al frente. !&quot;a&quot; %in% mivector # Un vector en otro vector a &lt;- seq(12, 19, 1) b &lt;- seq(1, 16, 1) # Veamos si los elementos de un vector &quot;largo&quot; están en uno &quot;corto&quot; b %in% a # Esto va a ser muy útil cuando trabajemos con bases de datos. Operadores para seleccionar subconjuntos de datos: y &lt;- c(2,3,3,4,NA,8) y # Vamos a seleccionar solo los que no son NA y1 &lt;- y[!is.na(y)] y1 # Noten que utilizamos la funcion is.NA y un operador (!). Más detalles en parte de análisis de datos, pero noten que la idea principal está aquí. Operadores lógicos: # Operador (&amp;): operador &quot;y&quot; TRUE &amp; TRUE TRUE &amp; FALSE FALSE &amp; TRUE FALSE &amp; FALSE # Ejemplo x &lt;- 12 x &gt; 5 &amp; x &lt; 11 # Operador (|): operador &quot;o&quot;. Condiciones no excluyentes. TRUE | TRUE TRUE | FALSE FALSE | TRUE FALSE | FALSE # Ejemplo y &lt;- 4 y &lt; 5 | y &gt; 15 # Operador de negación (!) !TRUE !FALSE # Combinarlo con funciones !is.numeric(5) !is.numeric(&quot;Hello&quot;) # Operadores con vectores c(TRUE, TRUE, FALSE) &amp; c(TRUE, FALSE, FALSE) c(TRUE, TRUE, FALSE) | c(TRUE, FALSE, FALSE) !c(TRUE,TRUE,FALSE) # Si utilizo dos &quot;&amp;&amp;&quot; sólo compara el primer elemento del vector c(TRUE,FALSE,FALSE) || c(TRUE,FALSE,FALSE) c(TRUE,FALSE,FALSE) &amp;&amp; c(TRUE,TRUE, TRUE) 2.2.4.3 Condicionales If: x &lt;- 3 #if (condicion){ # cualquier cosa que quiero que se haga si la condición se cumple #} if (x &gt; 0) { print(&quot;x es número mayor que cero&quot;) } if (x &gt; 0){ print(&quot;x es un número mayor que cero &quot;) } if (x &lt; 0){ print(&quot;x es un número menor que cero&quot;) } Else: x &lt;- 0 if (x &gt; 0){ print(&quot;x es un número positivo&quot;) } else{ print(&quot;x es un número negativo&quot;) } Elseif: x &lt;- 0 if (x &gt; 0){ print(&quot;x es mayor que cero&quot;) } else if (x == 0){ print(&quot;x es igual a cero&quot;) } else{ print(&quot;x es menor que cero&quot;) } # Importante: `(%%) corresponde al resto de una división` x &lt;- 6 if (x %% 2 == 0){ print(&quot;x es divisible por 2&quot;) } else if (x %% 3 == 0){ print(&quot;x es divisible por 3&quot;) } else { print(&quot;x no es divisible ni por 2 ni por 3&quot;) } # Notar que si la primera condición se cumple, la segunda no se ejecuta aunque sea cierta. 2.2.4.4 Funciones Idea principal: \\(f(x) = 2x + 1\\), \\(x \\in R\\) \\(f(x) = &#39;hola&#39; + x\\), \\(x \\in (&#39;pepe&#39;, &#39;pepa&#39;, &#39;marta&#39;)\\) valores &lt;- c(1,2,3,4) mean(valores) Algunas cosas adicionales sobre funciones: n me permite ver los argumentos de una función, sin necesidad de ver la documentación. Útil a veces. # Escribir funciones con un argumento triple &lt;- function(x){ y &lt;- 3 * x return(y) } triple &lt;- function(x){ x/2 } triple(500) # Escribir funciones con mas de un argumento operacion &lt;- function(a,b){ a*b + a/b } operacion(4,2) # Escribir funciones fijando opción por defecto. operacion_defecto &lt;- function(a,b = 1){ a*b + a/b } operacion_defecto(4) operacion_defecto(4,0) # Escribir funciones utilizando if y return. operacion_condicionales &lt;- function(a,b = 1){ if (b == 0){ return(0) } a*b + a/b } operacion_condicionales(4,0) # Funciones con texto texto &lt;- function(){ print(&quot;Hola mundo!&quot;) return(TRUE) } texto() # Funciones por defecto en ambos casos operacion_dosdefectos &lt;- function(a = 1,b = 1){ if (b == 0){ return(0) } a*b + a/b } operacion_dosdefectos() Ejercicio 2.2.2: Funciones Genere una función que sea igual a la división de dos elementos. Coloque un mensaje que indique cuando la división es indeterminada. Respuesta: operacion_indeterminada &lt;- function(a,b){ a/b if (b == 0){ print(&quot;Es indeterminado&quot;) } } operacion_indeterminada(1,0) 2.3 Manipulación de bases de datos (Parte I) 2.3.1 Principios de programación 2.3.1.1 Iteradores For loop: # Imaginen que queremos mostrar los nombres de un vector de forma reiterada ciudades &lt;- c(&quot;Nueva York&quot;, &quot;Paris&quot;, &quot;Santiago&quot;, &quot;Rancagua&quot;) print(ciudades[1]) print(ciudades[2]) print(ciudades[3]) print(ciudades[4]) # Lo anterior se puede hacer utilizando un iterador. for (i in 1:4){ print(ciudades[i]) } # Utilizando variables ocultas... for (.j in 1:4){ print(ciudades[.j]) } for (.j in 1:length(ciudades)){ print(ciudades[.j]) } # o escrito señalando el nombre de cada elemento de un vector. for (ciudad in ciudades){ print(ciudad) } # Otro ejemplo: semana &lt;- c(&quot;Domingo&quot;, &quot;Lunes&quot;, &quot;Martes&quot;, &quot;Miercoles&quot;, &quot;Jueves&quot;, &quot;Viernes&quot;, &quot;Sabado&quot;) for (dia in semana) { print(dia) } For loop con opciones: ciudades &lt;- c(&quot;Nueva York&quot;, &quot;Paris&quot;, &quot;Santiago&quot;, &quot;Tokio&quot;) # Agregar opcion break: quiebra el loop for (ciudad in ciudades){ if(nchar(ciudad) == 8){ break } print(ciudad) } # Agregar Opción next: se salta ese elemento for (ciudad in ciudades){ if (nchar(ciudad) == 8){ next } print(ciudad) } Flexibilizar el iterador: ciudades &lt;- c(&quot;Nueva York&quot;, &quot;Paris&quot;, &quot;Santiago&quot;, &quot;Tokio&quot;, &quot;Rancagua&quot;, &quot;Roma&quot;) # Ahora el tamaño del loop es flexible. Esto es muy inportante para cuando trabajemos con bases de datos. for (i in 1:length(ciudades)){ print(ciudades[i]) } # Noten que ahora llamo a los elementos dentro de un loop como subconjuntos de un vector. # En resumen, dos versiones de lo mismo for (i in 1:length(ciudades)){ print(ciudades[i]) } for (ciudad in ciudades){ print(ciudad) } # Ejemplo: para dejar mensajes for (i in 1:length(ciudades)){ print(paste(ciudades[i], &quot;esta en la posicion&quot;,i, &quot;en el vector ciudades&quot;)) } # Lo anterior es aplicable para inspecciones de bases de datos, por ejemplo, podemos dejar un mensaje for (i in 1:length(mtcars)){ print(paste(&quot;el promedio de la variable&quot;, names(mtcars[i]), &quot;es&quot;, mean(mtcars[,i]))) } While: mientras que… x &lt;- 1 while (x &lt;= 7){ print(paste(&quot;x es&quot;, x)) # Actualización x &lt;- x + 1 } while (x &lt;= 700){ print(paste(&quot;x es&quot;, x)) # Actualizacion x &lt;- x + 1 } # Muy importante la actualización. 2.3.1.2 Lapply, Sapply y Vapply Lapply: nyc &lt;- list(poblacion = 8405837, barrios = c(&quot;Manhattan&quot;, &quot;Bronx&quot;, &quot;Brooklyn&quot;, &quot;Queens&quot;, &quot;Staten Island&quot;)) nyc Equivalencia loop y lapply. Quiero saber todas las clases de la lista: # Puedo hacer esto con un loop for (objeto in nyc){ print(class(objeto)) } for (i in 1:length(nyc)){ print(class(nyc[[i]])) } # Pero, si utilizo `lapply()` puedo hacerlo mucho más eficiente. # Lapply: que aplica esto como si fuese un `for`. lapply(nyc,class) Resultado de lapply con vector: # Lapply ejecuta la función, en este caso class, para todo elemento del objeto, en este caso nyc. # Si quiero saber el número de carácteres cities &lt;- c(&quot;New york&quot;,&quot;Paris&quot;, &quot;Tokyo&quot;, &quot; Rio de Janeiro&quot;) lapply(cities,nchar) class(lapply(cities,nchar)) # Noten que el resultado aquí es una lista. Si quiero que sea un vector, puedo utilizar la función `unlist()`. unlist(lapply(cities,nchar)) class(unlist(lapply(cities,nchar))) Lapply como función: precios &lt;- list(2.25, 2.18, 2.89, 2.84, 2.89) # Creamos una función multiplicar &lt;- function(x,factor){ x * factor } # Ahora, podemos aplicar lapply y agregar opciones de la función tresveces &lt;- lapply(precios, multiplicar, factor = 3) tresveces &lt;- unlist(tresveces) # Noten que la sintaxis es: objeto, función, opciones. Es decir, igual a lo anterior, pero pudiendo agregar opcionales. Sapply: Es una variacion de lapply que sirve para simplificar lapply. Ahora el resultado es un vector, no una lista. cities &lt;- c(&quot;New york&quot;,&quot;Paris&quot;, &quot;Tokyo&quot;, &quot; Rio de Janeiro&quot;) lapply(cities,nchar) sapply(cities,nchar) # Noten que es bastante ordenado. Sin embargo, falla cuando no es fácil ordenar el resultado. Vapply: Es una variación que sirve para definir explícitamente el tipo de objeto del resultado. vapply(cities, nchar, numeric(1)) 2.3.2 Manipulacion de bases de datos en R Analizar datos es parte importante de las labores que uno desea realizar al utilizar R. Vamos a revisar cuatro aspectos iniciales de cualquier trabajo con datos: Importar datos en distintos formatos. Inspeccionar y limpiar los datos que tenemos. Transformar los datos con el fin de crear nuevas variables. Juntar bases de datos de distinto tipo. 2.3.2.1 Importar bases de datos Para poder utilizar, cargar, renovar datos es importante tenerlos todos en un solo lugar. Esto también aplica para los resultados y codigos. Para que esto efectivamente ocurra necesitamos decirle a R cual va a ser nuestro directorio de trabajo. Es decir, el lugar donde guardaremos los datos que queremos trabajar, los resultados de nuestros análisis y nuestros códigos. Directorios de trabajo en R: # Me dice donde estoy getwd() # Si quiero indicarle otra ruta tengo dos opciones: # Opcion 1: Indicar a R la ruta/carpeta donde tengo mis datos setwd(&quot;C:/Users/catab/Dropbox/Cursos de R/Curso R - Noviembre 2022/Clase 3&quot;) # Opcion 2: Lo mismo que opcion 1, pero más ordenado. ruta &lt;-&quot;C:/Users/catab/Dropbox/Cursos de R/Curso R - Noviembre 2022/Clase 3&quot; setwd(ruta) # Noten que es necesario ocupar `/`. Por defecto las rutas al copiarlas vienen con otro tipo de &quot;slash&quot;. Para cambiarlas fácilmente, y no una por una, vamos a utilizar `ctrl + f`. # Con este atajo podemos remplazar varios elementos a la vez. Cuidado!! Es importante decirle si queremos que modifique todo el documento o bien solo una parte. dir(ruta) Ejemplo de ordenar carpetas: ruta &lt;- &quot;C:/Users/catab/Dropbox/Cursos de R/Curso R - Noviembre 2022/Clase 3&quot; # Codigos codigos &lt;- &quot;C:/Users/catab/Dropbox/Cursos de R/Curso R - Noviembre 2022/Clase 3/codigos&quot; codigos &lt;- paste(ruta,&quot;/&quot;,&quot;codigos&quot;, sep = &quot;&quot;) setwd(codigos) dir(codigos) # Datos datos &lt;- &quot;C:/Users/catab/Dropbox/Curso R - Agosto 2022/Clase 3/datos&quot; datos &lt;- paste(ruta,&quot;/&quot;,&quot;datos&quot;,sep=&quot;&quot;) dir(datos) # Datos raw datosraw &lt;- &quot;C:/Users/catab/Dropbox/Cursos de R/Curso R - Noviembre 2022/Clase 3/datos/raw&quot; dir(datosraw) # Todo lo anterior no es muy recomendado. Proyectos de R: Proyecto: piensen en muchos proyectos con muchos códigos. Es una herramienta incorporada en RStudio que permite manejar un proyecto de análisis de datos. Permite dividir el trabajo en múltiples contextos cada uno con su propio directorio de trabajo, espacio de trabajo e historial. ¿Por qué utilizarlo? Mantiene códigos y datos en la misma carpeta. Mantiene códigos y datos separados de otros proyectos: evita confusiones o errores. Identifica automáticamente el directorio de trabajo, facilitando cooperación. Pasos para crear un proyecto: Dos opciones: R crea una carpeta de trabajo. Crear una carpeta primero, y luego decirle a R que la identifique. Todos los nuevos archivos serán automáticamente guardados en la carpeta del proyecto. Una vez hecho el proyecto se genera un archivo con extensión R.proj. Aquí R guarda información del proyecto: historial, datos, etc. Lo más importante es que fija el directorio de trabajo de forma tal de que siempre sea el mismo una vez que se abre un proyecto. Evita cambiar directorios de trabajo al colaborar. Package here: install.packages(&quot;pacman&quot;) pacman::p_load(&quot;here&quot;) here() here(&quot;datos&quot;) Package rio: R tiene bases de datos propias. Sin embargo, muchas veces van a querer trabajar con datos propios. o bien de datos públicos que muchas veces estan en distintos formatos. Rio package es una forma flexible de importar datos en distintos. Rio debe su nombre por R input/output. Dos funciones principales: import() y export(). Además, cuando se le indica la extensión a rio este leerá y utilizará la herramienta indicada para leer esos datos. library(pacman) p_load(here, # Modificar carpetas rio) # Importar/exportar datos Hay otras opciones tambien para importar datos. Por ejemplo, read.csv() (\"base R\"); read.xlsx (\"openxlsx\"). El problema es que son difíciles de recordar. Mejor utilizar una. Importar datos en distintos formatos: Utilizar import() para importar un conjunto de datos es bastante sencillo. Basta con proporcionar la ruta del archivo (incluyendo el nombre y la extensión del archivo) entre comillas. # Ocupamos R project, here e import para importar datos fácilmente datos_xlsx &lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;)) datos_dta &lt;- import(here(&quot;datos&quot;, &quot;Data.dta&quot;)) datos_txt &lt;- import(here(&quot;datos&quot;, &quot;Data.txt&quot;)) datos_csv &lt;- import(here(&quot;datos&quot;, &quot;Data.csv&quot;)) Opciones: # 1. Importar distintas hojas: Por defecto se importa la primer hoja de una base de datos, con &quot;which&quot; puedo elegir la hoja. datos_xlsx_h1 &lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;), which = &quot;hoja1&quot;) datos_xlsx_h2 &lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;), which = &quot;hoja2&quot;) # 2. Puedo decirle a priori que valores son missings. # Especificar un missing datos_xlsx &lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;), na = &quot;2018&quot;) # Especificar varios a la vez.. datos_xlsx &lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;), na = c(&quot;Missing&quot;, &quot;&quot;, &quot; &quot;)) # 3. Saltar filas. datos_xlsx &lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;), skip = 1) # Noten que puedo hacerlo con cualquier tipo de datos, ya que son opciones de la función `rio`. datos_dta &lt;- import(here(&quot;datos&quot;, &quot;Data.dta&quot;) , skip = 1) # En la tabla de este link pueden ver los distintos paquetes que soporta `rio`, junto a ejemplo adicionales. browseURL(&quot;https://cran.r-project.org/web/packages/rio/vignettes/rio.html&quot;) 2.4 Manipulación de bases de datos (Parte II) Ya sabemos cargar datos. Ahora vamos a hacer el primer proceso para analizar cualquier base de datos. 2.4.1 Funciones clave Tidyverse es una colección de paquetes de R. Tidyverse contiene múltiples paquetes que iremos utilizando. Incluye: dplyr, ggplot2, tidyr, stringr, tibble, purrr, magrittr y forcats. Una paquete clave es dplyr que contiene muchas funciones para trabajar con bases de datos. Instalamos tidyverse: install.packages(&quot;tidyverse&quot;) library(tidyverse) library(pacman) p_load(tidyverse) 2.4.2 Operador piping Piping %&gt;%: crtrl + shift + m. Paquete asociado: magrittr p_load(magrittr) Operador que permite encadenar las funciones para realizar de manera sencilla transformaciones complejas en las bases de datos. Lo que dice es pasar el elemento que esta a su izquierda como un argumento de la función que tiene a la derecha. Coloca el énfasis en las acciones. Pasa un output intermedio de una función a la siguiente. magrittr es el paquete que permite ocupar piping. piping se utiliza mucho con las librerias de tidyverse y dplyr enfocadas en análisis de datos. Excelente cuando existe una secuencia de acciones/operaciones que queremos realizar. data(iris) # Ejemplo 1: usar pipe como encadenador head(iris, n = 4) # Con piping iris %&gt;% head(n = 4) # Ejemplo 2: obtener número total de observaciones y un promedio. summarize(mtcars, media = mean(disp)) mtcars %&gt;% summarize(promedio = mean(disp)) # Con piping mtcars %&gt;% filter(mpg &gt; 20) %&gt;% summarise(promedio = mean(disp)) promedio_mpg_20 &lt;- mtcars %&gt;% filter(mpg &gt; 20) %&gt;% summarise(promedio = mean(disp)) promedio_mpg_20 2.4.3 Proceso de análisis de datos (Parte I): cargar, inspeccionar y limpiar Preámbulo: # Limpiar rm(list = ls()) # Cargamos paquetes que vamos a utilizar library(pacman) p_load( rio, # Importar/Exportar datos here, # Determinar las rutas de mi carpeta tidyverse, # Analisis de datos y visualización magrittr, # Para utilizar operador %&gt;% janitor # Para análisis de datos ) # Importamos datos datos &lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;), which = &quot;hoja1&quot;) Inspeccionar: # Visión general datos view(datos) # Para una inspección detallada p_load(skimr) skim(datos) str(datos) # Mirar algunas filas, columnas, etc. head(datos) # muestra las 6 primeras filas tail(datos) # últimas 6 filas head(datos, 11) # podemos pedir m?s de 6 tail(datos, 3) # o menos de 6 # Mirar nombre variables/columnas names(datos) datos %&gt;% names() # `names()` también puede ser names(datos) &lt;- c(&quot;YEAR&quot;, &quot;GDP&quot;, &quot;GROSS_EXPORTS&quot;, &quot;GROSS_IMPORTS&quot;, &quot;NET_EXPORTS&quot; ) names(datos) # Mirar filas row.names(datos) row.names(mtcars) # Mirar la cantidad de variables de la base de datos length(datos) # columnas o variables dim(datos) ncol(datos) nrow(datos) # ¿Qué tipo de objeto es? class(datos) # También podemos inspeccionar elementos específicos datos&lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;), which = &quot;hoja1&quot;) # Si queremos ver la columna de GDP datos$gdp datos[2] datos[,2] # Para llamarlos solo por su nombre recordar ocupar `attach()` attach(datos) gdp detach(datos) # Si queremos un objeto dentro de una variable datos$gdp[7] datos[7,2] #[fila, columna] datos[7,&quot;gdp&quot;] # Si queremos seleccionar parte de la columna datos$gdp[5:10] # o bien (solo por `attach()`) attach(datos) gdp[1:2] # o bien datos[1:2,2] # mostrar las filas 1:2, de la columna 2 # `table()` me permite hacer una tabla sencilla de frecuencias table(datos$year) attach(datos) table(year) detach(datos) Ejercicio 2.4.1: Utilizando el operador pipping, mostrar las últimas 2 filas de las primeras 11 filas. Limpiar: names(datos) &lt;- c(&quot;YEAR&quot;, &quot;GDP&quot;, &quot;GROSS_EXPORTS&quot;, &quot;GROSS_IMPORTS&quot;, &quot;NET_EXPORTS&quot; ) names(datos) # La función `clean_names()` del paquete `janitor` estandariza nombres: datos_nuevos &lt;- clean_names(datos) names(datos) names(datos_nuevos) Renombrar variables: rm(list = ls()) datos&lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;), which = &quot;hoja1&quot;) # Función para renombrar variables. Sintaxis: rename(nuevonombre = viejonombre) # Escribamos esto, pero con `piping` datos_renombrados &lt;- datos %&gt;% rename(tiempo = year, pib = gdp, exportaciones = gross_exports) names(datos_renombrados) rm(datos_renombrados) Seleccionar variables o columnas: rm(list= ls()) datos&lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;), which = &quot;hoja1&quot;) # select() de `dplyr` permite seleccionar variables datos_select &lt;- datos %&gt;% select(year, gdp) datos_select1 &lt;- datos %&gt;% select(c(1:4)) datos_select1 &lt;- datos %&gt;% select(c(1:ncol(datos)-1)) # También puedo seleccionar en base a un criterio (Sólo sirve para string) datos_select2 &lt;- datos %&gt;% select(year, contains(&quot;Gross&quot;)) # Con `select` también se puede renombrar datos_select_renombrados &lt;- datos %&gt;% select(tiempo = year, pib = gdp) # Una opción es ocupar select con `everything()` para ordeanar mis columnas. datos_select_ordenados &lt;- datos %&gt;% select(gdp, year, everything()) Remover columnas: # La idea aqui es decir: todas se quedan, menos las que pongo aquí. datos_select_remover &lt;- datos %&gt;% select(-c(gdp, year)) Mirar si hay duplicados. En ocasiones es importante revisar si hay duplicados. El paquete dplyr contiene distinct(). Esta función examina cada fila y reduce los datos solo a las que sean valores diferentes: datos1 &lt;- datos %&gt;% distinct() # ¿Cuantos duplicados? nrow(datos) nrow(datos1) dif &lt;- nrow(datos) - nrow(datos1) dif 2.4.4 Proceso de análisis de datos (Parte II): cargar, inspeccionar y limpiar Cargar: # Limpiamos consola rm(list = ls()) # Cargamos paquetes que vamos a utilizar pacman::p_load( rio, # importar/exportar datos. here, # escribir rutas de las carpetas. janitor, # limpiar datos y tablas. tidyverse, # Manejo de bases de datos y visualización. magrittr, # Permite utilizar operador %&gt;% (piping). skimr, # Inspeccionar datos inspectdf, # Inspeccionar datos gapminder # Base de datos con información de países. ) data(&quot;gapminder&quot;) gapminder %&gt;% view() # Cargamos datos que vienen incluidos en R. data(starwars) starwars Inspeccionar datos: # Inspect_cat() retorna una base de datos que resume características de un data.frame. inspeccion &lt;- inspect_cat(starwars) inspeccion class(inspeccion) # Las columnas son: # col_names: nombre de cada columna # cnt: número de valores únicos por nivel # common: el nivel más común # common_pcnt: el porcentaje de ocurrencia del nivel más común. # levels: una lista de dataframes (tibbles) cada uno con tablas de frecuencia para todos los niveles. # Notar que una de las columnas de un data frame pueden ser listas: inspeccion[1,5] inspeccion[2,5] inspeccion[3,5] inspeccion[4,5] inspeccion[5,5] # Ahora, si quiero ver el contenido, debo utilizar doble paréntesis cuadrado inspeccion[1,5] # Con el nombre inspeccion[[1,5]] # El contenido inspeccion[[5]] # El contenido de todas las filas, en este caso, listas inspeccion[[5]][[1]] inspeccion[[5]][[2]] # Una forma más simple de mirar esta información es: inspeccion$levels$eye_color inspeccion[[5]][[1]] # Otra cosa interesante de este paquete es la función `show_plot()` starwars %&gt;% inspect_cat() %&gt;% show_plot() # Esta función permite ver las categorías de cada variable categórica. Noten que las zonas en gris son los NA. Limpiar bases de datos (continuación): rm(list= ls()) datos&lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;), which = &quot;hoja1&quot;) Seleccionar columnas: # Vimos que `select()` es parte importante. `select()` puede ser utilizado con varias funciones adicionales: # 1. everything () - todas las otras columnas no mencionadas. datos_everything &lt;- datos %&gt;% select (year, gdp, everything()) # 2. last_col () - la última columna. datos_last_col &lt;- datos %&gt;% select(year, last_col()) # 3. where () - aplicar una función a todas las columnas y # selecciona solo las que cumple esta condición # (es decir, cuando es verdadera). datos_where &lt;- datos %&gt;% select(where(is.logical)) # 4. contains () - columns containing a character string datos_contains &lt;- datos %&gt;% select(contains(&quot;exports&quot;)) # 5. starts_with () - selecciona la variable si se tiene un prefijo determinado datos_starts_with &lt;- datos %&gt;% select(starts_with(&quot;gross_&quot;)) # 6. ends_with () - selecciona la variable si se tiene un sufijo determinado datos_ends_with &lt;- datos %&gt;% select(ends_with(&quot;_imports&quot;)) # 7. matches () - aplicar una expresión regular datos_matches &lt;- datos %&gt;% select(matches(&quot;gross|gdp&quot;)) # 8. any_of () - la selecciona si la columna existe pero NO retorna error # si no la encuentra. datos_any_of &lt;- datos %&gt;% select(any_of(c(&quot;year&quot;, &quot;gdp&quot;, &quot;cualquiercosa&quot;))) Manipulación de NAs: Con vectores. Los NA son parte importante de la limpieza de los datos. Recordemos que la función is.na() nos permite identificarlos. x &lt;- c(1,2,NA,NA,5) malos &lt;- is.na(x) malos class(malos) # Si queremos eliminar los NA es cosa de colocar un vector sobre otro x[!malos] x[!is.na(x)] x &lt;- x[!malos] x Manipulación de NAs: con complete cases() # Miremos un caso más práctico con iris summary(iris) skim(iris) data(&quot;iris&quot;) # Generar NA en la base de datos (después veremos esto en detalle ahora concéntrense solo en los NA) iris$Sepal.Length&lt;-ifelse(iris$Sepal.Length&lt;5, NA,iris$Sepal.Length) # Dos opciones: # (i) como antes malos &lt;- is.na(iris$Sepal.Length) iris2 &lt;- iris[!malos,] iris2 # (ii) utilizando `complete.cases()` completos &lt;- complete.cases(iris$Sepal.Length) head(completos, 100) # Creamos una base nueva solo con casos completos. iris3 &lt;- iris[completos,] head(iris3) summary(iris3) 2.5 Manipulación de bases de datos (Parte III) 2.5.1 Crear Variables 2.5.1.1 Crear variables binarias Ahora vamos a ver como crear variables dicótomas o binarias. Estas variables son muy importantes para hacer análisis de datos. Vamos a utilizar la función ifelse(). rm(list= ls()) data &lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;), which = &quot;hoja1&quot;) # Asignar valor 1 si estamos en democracia, 0 caso contrario data &lt;- data %&gt;% mutate(demo = ifelse(year&gt;=1990,1,0)) table(data$demo) # Tabla 1: ¿Cual fue el pib promedio en democracia y en dictadura? tabla1 &lt;- data %&gt;% group_by(demo) %&gt;% summarize(promediopib = mean(gdp, na.rm = TRUE)) tabla1 # Asignar valor 1 si estamos en democracia y el pib es mayor a su media data &lt;- data %&gt;% mutate(avance = ifelse(demo == 1 &amp; gdp &gt; mean(gdp), 1,0)) mean(data$gdp) # Asignar valor 1 si estamos en democracia y si dentro de esos periodos # las exportaciones netas son mayores a la mediana de las importaciones data$expo &lt;-ifelse(data$demo==1, ifelse(data$gross_exports&gt; median(data$gross_imports),1,0),0) table(data$expo) Ejercicio 2.5.1: Escriba lo anterior utilizando mutate. Respuesta: data &lt;- data %&gt;% mutate(expo = ifelse(demo==1, ifelse(gross_exports&gt; median(gross_imports),1,0),0)) 2.5.1.2 Crear variables categóricas También podemos crear variables categóricas utilizando ifelse(). De manera muy sencilla podemos generar variables según ciertas condiciones: # De manera muy sencilla podemos generar variables según ciertas condiciones data$tipo&lt;-ifelse(data$year&lt;1980 &amp; data$year&gt;1959,1, ifelse(data$year&lt;2000 &amp; data$year&gt;1979,2, ifelse(data$year&lt;2010 &amp; data$year&gt;1999,3,4) ) ) table(data$tipo) # Nota: no es recomendable utilizar o escribir tantos `ifelse()` juntos. # Es mejor utilizar `case_when()` que veremos un más adelante. 2.5.2 Factores R puede codificar automáticamente una variable categorica (factor) con un número entero. Sirven para hacer estadisticas o estimar regresiones. Los factores, pueden ser ordenados o no ordenados, se utilizan para representar variables que se agrupan en categorías. Veamos un ejemplo: x &lt;- rep(c(&quot;Ford&quot;,&quot;BMW&quot;,&quot;Peugeot&quot;),10) x class(x) # `factor()` factor_nominal &lt;- factor(x) factor_nominal class(factor_nominal) levels(factor_nominal) #para analizar que niveles tiene el objeto table(factor_nominal) # resume la cantidad de observaciones por nivel 2.5.3 Funciones útiles para transformar bases de datos across(): Algunas veces queremos aplicar una función a múltiples variables, para ello vamos a utilizar la función across() y especificar la función con fns. Por ejemplo: datos2 &lt;- data %&gt;% mutate(across(cols = everything(), fns = as.numeric)) # Aquí `across()`, que es una función de &quot;dplyr&quot;, permite ser utilizada con `mutate()`, `select()`, `filter()`, `summarise()`, etc. datos3 &lt;- data %&gt;% mutate(across(.cols = contains(&quot;gross&quot;), .fns = as.numeric)) cumsum(): Suma acumulada # Para hacer operaciones acumuladas sum(c(2,4,15,10)) # Retorna la suma del vector cumsum(c(2,4,15,10)) # Retorna la suma acumulada del vector # Puedo utilizarla con mutate () datos_acumulados &lt;- data %&gt;% arrange(year) %&gt;% count(gdp) %&gt;% mutate(gdp_acumulado = cumsum(n)) datos_acumulados Recodificar variables: A continuación se presentan algunos escenarios en los que es necesario recodificar (cambiar) los valores: Editar un valor específico (por ejemplo, una fecha con un año o formato incorrecto) Para conciliar valores que no se escriben igual Crear una nueva columna de valores categóricas Crear una nueva columna de categorías numéricas (por ejemplo, categorías de edad) recode (): Cambiar valores rm(list= ls()) data &lt;- import(here(&quot;datos&quot;, &quot;Data.xlsx&quot;), which = &quot;hoja1&quot;) data &lt;- data %&gt;% mutate(demo = ifelse(year&gt;=1990,1,0)) # Seguimos con data names(data) # Creamos una nueva variable datos &lt;- data %&gt;% mutate(regimen = ifelse(demo == 1, &quot;Democracia&quot;, &quot;Dictadura&quot;)) datos # Recodificamos (cambiar nombres) datos &lt;- datos %&gt;% mutate(regimen = recode(regimen, &quot;Democracia&quot; = &quot;Demo&quot;, &quot;Dictadura&quot; = &quot;Dict&quot;)) datos # Notar que es vieja variable por nueva variable replace(): Reemplazar valores datos &lt;- datos %&gt;% mutate(avance = ifelse(demo == 1 &amp; gdp &gt; mean(gdp), 1,0)) # Similar sintaxis a la de recode datos &lt;- datos %&gt;% mutate(regimen = replace(regimen, avance == 0, &quot;No cambio en el pib&quot;)) # Sintaxis # mutate(columna a cambiar = replace(columna a cambiar, # criterio para las filas, # nuevo valor)). # Un equivalente a `replace()` es utilizar []. datos$regimen[datos$avance == 0] &lt;- &quot;No cambio en el pib&quot; replace_na(): Para cambiar los valores perdidos (NA) por un valor específico, como “Missing”, utilice la función dplyr replace_na() dentro de mutate(): datos_ficticios &lt;- data.frame(var1 = c(seq(1,10), NA), var2 = c(rep(NA,11))) datos_ficticios datos_ficticios1 &lt;- datos_ficticios %&gt;% mutate(var1 = replace_na(var1, 0)) datos_ficticios1 Recordatorio: Esta función cambia los missing values solo por valores de la misma clase de la variable/columna, por lo tanto, si trabajamos con valores de clase numérica los reemplazos deben ser también numéricos. case_when(): una función de dplyr. Es útil para asignar múltiples valores. Sirve si se necesita recodificar muchos grupos: rm(list = ls()) datosedad &lt;- data.frame(edad = c(2,3,4,1,500,2330,8,10,12), unidad = c(&quot;años&quot;,&quot;años&quot;, &quot;años&quot;, NA, &quot;meses&quot;, &quot;meses&quot;, &quot;años&quot;, &quot;años&quot;, &quot;semanas&quot;)) datosedad # Imaginemos que queremos tener una medida comparable de edad, para ello # podemos utilizar `case_when()`. datos_case_when &lt;- datosedad %&gt;% mutate(edad_años = case_when( unidad == &quot;años&quot; ~ edad, unidad == &quot;meses&quot; ~ edad/12, unidad == &quot;semanas&quot; ~ edad/52, is.na(unidad) ~ edad)) datos_case_when 2.5.4 Cambio de formato de los datos 2.5.4.1 De ancho a largo En en siguiente ejemplo, los datos están guardaos en “wide” para las columnas que tienen el número de casos de malaria por tramos de edad. Para un trabajo de análisis de datos es importante transformar los datos a “long”. rm(list = ls()) count_data &lt;- import(here(&quot;datos&quot;,&quot;malaria_facility_count_data.rds&quot;)) head(count_data) pivot_longer(): función del paquete tidyr. Paquete incluido en tidyverse(). Transforma los datos de wide a long. df_long &lt;- count_data %&gt;% pivot_longer( cols = c(&quot;malaria_rdt_0-4&quot;, &quot;malaria_rdt_5-14&quot;, &quot;malaria_rdt_15&quot;, &quot;malaria_tot&quot;) ) df_long # Una mejor opción es con la función starts_with(): count_data %&gt;% pivot_longer( cols = starts_with(&quot;malaria_&quot;) ) # Para agregar nombres a las nuevas variable creadas df_long1 &lt;- count_data %&gt;% pivot_longer( cols = starts_with(&quot;malaria_&quot;), names_to = &quot;grupo_edad&quot;, values_to = &quot;casos_malaria&quot; ) df_long1 2.5.4.2 De largo a ancho pivot_wider(): Transforma los datos de long a wide. Útil si quiero hacer una tabla mas amigable para el o la lectora. rm(list = ls()) linelist &lt;- import(here(&quot;datos&quot;,&quot;linelist_cleaned.rds&quot;)) df_wide &lt;- linelist %&gt;% count(age_cat, gender) df_wide # En un mejor formato table_wide &lt;- df_wide %&gt;% pivot_wider( id_cols = age_cat, names_from = gender, values_from = n ) table_wide Otra opción para hacer esto mismo es gather() y spread(): rm(list = ls()) datos &lt;- import(here(&quot;datos&quot;,&quot;Cuadro_1.xls&quot;), skip = 1) # Cargamos datos que estan en formato ancho y los preparamos un poco... datos &lt;- datos[-c(1:2)] colnames(datos) &lt;- c(1960:2018) colnames(datos) # 1. Como vemos, los años estan en las columnas, y queremos pasar a long data, # de forma tal que los años esten en una columna y el pib en otra # 2. La funciom &quot;gather()&quot; transforma los datos de formato ancho (wide) a # formato largo (long) # De ancho a largo: utilizando la función gather() # La primera es la variable &quot;clave&quot; y la segunda es la del valor data_long &lt;- datos %&gt;% gather(año, pib, 1:59) data_long # De largo a ancho: utilizando la función spread() data_wide &lt;- data_long %&gt;% spread(año,pib) data_wide 2.5.5 Juntar bases de datos 2.5.5.1 Pegar hacia el lado (por columnas) En el siguiente ejemplo, tenemos datos de hospitales. rm(list = ls()) hosp_info &lt;- import(here(&quot;datos&quot;,&quot;hosp_info_final.xlsx&quot;)) linelist_mini &lt;- import(here(&quot;datos&quot;,&quot;linelist_mini_final.xlsx&quot;)) Sintaxis: Imaginemos que tenemos dos bases de datos “df1”, “df2”. df1 tienen una columna llamada “ID”. df2 tiene una columna que se llama identificador. # Caso 1: nombres de identificadores distintos. data_junta &lt;- join(df1, df2, by = c(&quot;ID&quot; = &quot;identificador&quot;)) # Caso 2: imaginemos ambas bases de datos (df1, df2) tienen un # identificador llamado &quot;ID&quot; data_junta &lt;- join(df1, df2, by = &quot;ID&quot;) # Caso 3: imaginemos queremos pegar bases de datos considerando más # de un identificador. data_junta &lt;- join(df1, df2, by = c(&quot;nombre&quot; = &quot;primernombre&quot;, &quot;apellido&quot; = &quot;primerapellido&quot;, &quot;Edad&quot; = &quot;edad&quot;)) Left y Right join: # Left join: la primera base de datos que aparece es la referencia. # Right join: la segunda base de datos que aparece es la referencia. # Left_join left_join_ex1 &lt;- left_join(linelist_mini, hosp_info, by = c(&quot;hospital&quot; = &quot;hosp_name&quot;)) right_join_ex1 &lt;- right_join(hosp_info, linelist_mini, by = c(&quot;hosp_name&quot; = &quot;hospital&quot;)) # Ambos son equivalentes. right_join_ex2 &lt;- right_join(linelist_mini, hosp_info, by = c(&quot;hospital&quot; = &quot;hosp_name&quot;)) left_join_ex2 &lt;- linelist_mini %&gt;% left_join(hosp_info, by = c(&quot;hospital&quot; = &quot;hosp_name&quot;)) # Notas: # 1. Todas las filas/observaciones de la base de datos de referencia # se mantienen. # 2. Si hay más de un match, se duplican las observaciones. # 3. Los identificadores se combinan. Según el nombre # de la columna de la base de datos de referencia. # 4. Cuando no hay un &quot;match&quot; las columnas se llenan con un NA # para las observaciones de la base de referencia. # 5. No &quot;match&quot; por la base que no es de referencia se borran. Full Join: El más inclusivo de los “joins”. Retorna todas las observaciones/filas: full_join_ex3 &lt;- full_join(linelist_mini, hosp_info, by = c(&quot;hospital&quot; = &quot;hosp_name&quot;)) full_join_ex3 &lt;- linelist_mini %&gt;% full_join(hosp_info, by = c(&quot;hospital&quot; = &quot;hosp_name&quot;)) Inner join: El más restrictivo de los “join”. Retorna solo las filas que hicieron match entre ambas bases de datos. # Su análogo en stata es: merge 1:1, keep _merge==3 # Los que se pegaron perfectamente entre ambas bases. inner_join_example &lt;- linelist_mini %&gt;% inner_join(hosp_info, by = c(&quot;hospital&quot; = &quot;hosp_name&quot;)) Semi - join: Mantiene todas las observaciones de la base de referencia que tengan un “match” en la base secundaria, pero NO agrega nuevas columnas ni duplicados en casos de multiples “match”. semi_join_example1 &lt;- semi_join(hosp_info, linelist_mini, by = c(&quot;hosp_name&quot; =&quot;hospital&quot;)) semi_join_example &lt;- hosp_info %&gt;% semi_join(linelist_mini, by = c(&quot;hosp_name&quot; = &quot;hospital&quot;)) Anti- join: Se le llama, al igual que semi-join “join de filtros”. Retorna las observaciones/filas en la base de datos de referencia que no hacen “match” en base de datos secundaria. anti_join_example &lt;- hosp_info %&gt;% anti_join(linelist_mini, by = c(&quot;hosp_name&quot; = &quot;hospital&quot;)) La función merge: rm(list = ls()) authors &lt;- data.frame( surname = (c(&quot;Tukey&quot;, &quot;Venables&quot;, &quot;Tierney&quot;, &quot;Ripley&quot;, &quot;McNeil&quot;)), nationality = c(&quot;US&quot;, &quot;Australia&quot;, &quot;US&quot;, &quot;UK&quot;, &quot;Australia&quot;), deceased = c(&quot;yes&quot;, rep(&quot;no&quot;, 4))) authors books &lt;- data.frame( name = (c(&quot;Tukey&quot;, &quot;Venables&quot;, &quot;Tierney&quot;, &quot;Ripley&quot;, &quot;Ripley&quot;, &quot;McNeil&quot;, &quot;R Core&quot;)), title = c(&quot;Exploratory Data Analysis&quot;, &quot;Modern Applied Statistics ...&quot;, &quot;LISP-STAT&quot;, &quot;Spatial Statistics&quot;, &quot;Stochastic Simulation&quot;, &quot;Interactive Data Analysis&quot;, &quot;An Introduction to R&quot;), other.author = c(NA, &quot;Ripley&quot;, NA, NA, NA, NA, &quot;Venables &amp; Smith&quot;)) books m0 &lt;- merge(authors, books, by.x = &quot;surname&quot;, by.y = &quot;name&quot;) m0 # Por defecto solo mantiene las que hicieron match. m1 &lt;- merge(authors, books, by.x = &quot;surname&quot;, by.y = &quot;name&quot;, all = TRUE) m1 2.5.5.2 Pegar hacia abajo (por filas) Otra forma de unir bases de datos es agregar filas. Similar a lo que se hace con append() en Stata. Vamos a utilizar la función bind_rows() desde el paquete “dplyr”. bind_rows() es bastante inclusivo. Cualquier columna presente en las bases de datos se incluye en el output. Si ambas columnas se llaman igual, se alinearan correctamente. Adicionalmente, podemos agregar el argumento .id=. Este argumento genera una nueva columna que sirve para identificar de donde proviene la informacion. Ejemplo 1: caso sencillo continente_resumen &lt;- gapminder %&gt;% group_by(continent) %&gt;% summarise( cases = n(), gdpPercapmedian = median(gdpPercap, na.rm = TRUE)) continente_resumen # Crear Tabla 2: sin agrupar totales &lt;- gapminder %&gt;% summarise( cases = n(), gdpPercapmedian = median(gdpPercap, na.rm=T) ) totales # Ahora las podemos pegar combinadas &lt;- bind_rows(continente_resumen, totales) combinadas # ¿Como cambiar ese NA? combinadas &lt;- combinadas %&gt;% mutate(continent = replace_na(&quot;total&quot;)) combinadas # Muy util colocar &quot;id&quot; combinadas_id &lt;- bind_rows(continente_resumen, totales, .id = &quot;id&quot;) combinadas_id Ejemplo 2: ¿Qué ocurre si hay más de un archivo? # Base de datos maestra trial &lt;- data.frame( year = c(2016, 2017, 2018, 2019), n = c(501, 499, 498, 502), outcome = c(51, 52, 49, 50) ) %&gt;% print() # Base de datos 1 trial_2020 &lt;- data.frame( year = 2020, n = 500, outcome = 48 ) %&gt;% print() # Base de datos 2 trial_2021 &lt;- data.frame( year = 2021, n = 598, outcome = 57 ) %&gt;% print() # Para combinar mas de una base de datos trial1&lt;- bind_rows(trial,trial_2020, trial_2021) Ejemplo 3: ¿Qué ocurre si tengo muchos archivos? rm(list=ls()) library(pacman) p_load(plyr) # Recomendable ocupar paquete plyr. allfiles &lt;- list.files(path = &quot;datos&quot;, pattern = &quot;.csv&quot;, full.names = TRUE) allfiles # Append data combined_data&lt;- ldply(allfiles, read_csv) combined_data # Transformar a un data.frame. combined_data_sep &lt;- separate(data = combined_data, col = &quot;year;n;outcome&quot;, into = c(&quot;year&quot;, &quot;n&quot;, &quot;outcome&quot;), sep = &quot;;&quot;) combined_data_sep 2.6 Análisis de datos 2.6.1 Inspección de datos Preámbulo: # Limpiamos consola rm(list = ls()) # Cargamos paquetes que vamos a utilizar pacman::p_load( rio, # importar/exportar datos. here, # escribir rutas de las carpetas. janitor, # limpiar datos y tablas. tidyverse, # Manejo de bases de datos y visualización. magrittr, # Permite utilizar operador %&gt;% (piping). skimr, # Inspeccionar datos inspectdf, # Inspeccionar datos gapminder # Base de datos con información de países. ) Ahora vamos a crear tablas de estadística descriptiva que nos interesen para el análisis de datos. # Importamos datos datos &lt;- import(here(&quot;datos&quot;,&quot;linelist_cleaned.rds&quot;)) #Inspeccionamos los datos # a. Visión general de la base de datos skim(datos) # b. Información sobre cada columna summary(datos) # c. Información sobre cada variable categórica. insp &lt;- inspect_cat(datos) insp insp_figura &lt;- insp %&gt;% show_plot() insp_figura # d. Miramos nombre de las variables names(datos) # Nota 1: Tenemos 29 variables y el id es igual a case_id. Transformamos variables de interés: # a. Miramos la clase de cada variable unlist(lapply(datos,class)) # Nota 2: gender esta como texto, podría estar como factor. Lo mismo ocurre con outcome. # b. Transformamos gender/outcome en factores datos$gender &lt;- as.factor(datos$gender) levels(datos$gender) datos$outcome&lt;- as.factor(datos$outcome) levels(datos$outcome) # Miramos como esta codificado ahora unlist(lapply(datos,class))[&quot;gender&quot;] skim(datos) # c. Seleccionamos solo variables que nos interesa ocupar: reducir el problema! datos_trabajo &lt;- datos %&gt;% select(case_id, outcome, gender, age, age_years, age_cat, hospital, wt_kg:temp, days_onset_hosp) # d. Vemos que hay variables que están codificadas como &quot;yes&quot; y &quot;no&quot;. # Vamos a crearlas como variables binarias. datos_trabajo &lt;- datos_trabajo %&gt;% mutate(chills = ifelse(chills == &quot;yes&quot;,1,0), cough = ifelse(cough == &quot;yes&quot;,1,0), aches = ifelse(aches == &quot;yes&quot;,1,0), vomit = ifelse(vomit == &quot;yes&quot;,1,0)) summary(datos_trabajo) # Limpiamos para quedarnos solo con los datos que nos interesan. rm(insp, insp_figura) # Inspeccionamos nuevamente skim(datos_trabajo) # e. Ahora vamos a dejar una base de datos unicamente con valores completos completos &lt;- complete.cases(datos_trabajo) completos datos_trabajo &lt;- datos_trabajo[completos,] skim(datos_trabajo) # f. Finalmente, vamos a renombrar la base de datos con la que vamos a trabajar. rm(datos, completos) datos &lt;- datos_trabajo rm(datos_trabajo) 2.6.2 Estadística descriptiva Describiendo los datos: pacman::p_load(rstatix) # Opcion 1: utilizar get_summary_stats() del paquete &quot;rstatix&quot;. # El resultado se guarda en un dataframe. tabla1 &lt;- datos %&gt;% get_summary_stats( everything(), type = &quot;full&quot;) tabla1 # Puedo exportar esta tabla en excel utilizando `rio` y `here`. export(tabla1, here(&quot;resultados&quot;, &quot;ejercicio1&quot;, &quot;tabla1.xlsx&quot;)) 2.6.3 Tablas de frecuencia El paquete “janitor” ofrece la función tabyl() para producir tabulaciones simples y tabulaciones cruzadas, que pueden ser “adornadas” o modificadas con funciones de ayuda para mostrar porcentajes, proporciones, recuentos, etc. El uso por defecto de tabyl() en una columna específica produce los valores únicos, los recuentos y los “porcentajes” de la columna (en realidad proporciones). Las proporciones pueden tener muchos dígitos. Puede ajustar el número de décimales con la función adorn_rounding() como se describe a continuación. 2.6.3.1 Tablas de frecuencias con una entrada # Frecuencia para age_cat tabla2a &lt;- datos %&gt;% tabyl(outcome) tabla2a tabla2b &lt;- datos %&gt;% tabyl(gender) tabla2b tabla2c &lt;- datos %&gt;% tabyl(age_cat) tabla2c rm(tabla2a, tabla2b, tabla2c) # ¿Qué pasa si queremos hacer una tabla de frecuencias para # todas las variables que son factores? -&gt; iteradores! # Nombre de todas las variables de la base de datos nombres &lt;- names(datos) nombres # Selecciono solo a las que son categóricas (factores) select &lt;- unlist(lapply(datos, is.factor)) select nombres &lt;- nombres[select == TRUE] nombres Ahora voy a generar tantas tablas como variables categóricas para ello vamos a hacer uso de iteraciones. Creo una lista vacía, donde voy a guardar las tablas (data frames) que se generen. tabla2 &lt;- list() tabla2a &lt;- datos %&gt;% tabyl(outcome) tabla2a tabla2b &lt;- datos %&gt;% tabyl(gender) tabla2b tabla2c &lt;- datos %&gt;% tabyl(age_cat) tabla2c for (i in 1:length(nombres)){ tabla2[[i]] &lt;- datos %&gt;% tabyl(nombres[i]) } Ahora tengo una lista de tablas. Cada tabla habla de un variable categórica. Si vemos son equivalente a generarlas de otra forma. Si tengo pocas variables categóricas, esta forma puede no ser relevante, sin embargo, si tengo muchas, puede ser una buena forma de generar estadística descriptiva. # Comparamos datos %&gt;% tabyl(outcome,show_na = FALSE) tabla2[[1]] datos %&gt;% tabyl(gender,show_na = FALSE) tabla2[[2]] # Exportamos utilizando `rio` y `here` de nuevo export(tabla2[[1]],here(&quot;resultados&quot;, &quot;ejercicio1&quot;, &quot;tabla2-1-freq-outcomes.xlsx&quot;)) export(tabla2[[2]],here(&quot;resultados&quot;, &quot;ejercicio1&quot;, &quot;tabla2-2-freq-gender.xlsx&quot;)) export(tabla2[[3]],here(&quot;resultados&quot;, &quot;ejercicio1&quot;, &quot;tabla2-3-freq-age_cat.xlsx&quot;)) 2.6.3.2 Tablas de frecuencias con más de una entrada Imaginen que estamos interesados o interesadas en saber cuantas observaciones por categoría de edad por genero. Para ello nos gustaría hacer una tabla de doble entrada. Podemos ocupar tabyl() para hacer eso fácilmente: tabla3 &lt;- datos %&gt;% tabyl(age_cat, gender, show_na = FALSE) tabla3 rm(tabla3) # Hacemos una lista tabla3 &lt;- list() tabla3[[1]] &lt;- datos %&gt;% tabyl(outcome, gender) tabla3[[2]] &lt;- datos %&gt;% tabyl(outcome, age_cat) tabla3[[3]] &lt;- datos %&gt;% tabyl(age_cat, gender) tabla3[[1]] tabla3[[2]] tabla3[[3]] # Exportamos pero a diferentes hojas export(list(&quot;tabla 3.1&quot; = tabla3[[1]],&quot;tabla 3.2&quot; = tabla3[[2]], &quot;tabla 3.3&quot; = tabla3[[3]]), #Podemos asignarles nombres here(&quot;resultados&quot;, &quot;ejercicio1&quot;, &quot;tabla3_cruzadas.xlsx&quot;)) 2.6.3.3 Tablas mejoradas con opciones # Tabular los recuentos y las proporciones por categoría de edad # Con porcentajes para una de una entrada tabla4 &lt;- datos %&gt;% tabyl(age_cat) %&gt;% adorn_pct_formatting() # convertir proporciones en porcentajes tabla4 # Con porcentajes por fila tabla5 &lt;- datos %&gt;% tabyl(age_cat, gender) %&gt;% # contar para edad y género adorn_totals(where = &quot;row&quot;) %&gt;% # agregar totales adorn_percentages(denominator = &quot;row&quot;) %&gt;% # cambiar a porcentaje adorn_pct_formatting(digits = 2) # numero de digitos tabla5 # Nota: ¿Qué ocurre si cambio col/row en adorn_percentages? # Con porcentajes por columna tabla6 &lt;- datos %&gt;% tabyl(age_cat, gender) %&gt;% # contar para edad y genero adorn_totals(where = &quot;row&quot;) %&gt;% # agregar totales adorn_percentages(denominator = &quot;col&quot;) %&gt;% # cambiar a porcentaje adorn_pct_formatting(digits = 2) # nùmero de digitos tabla6 # Con total por columna y fila tabla7 &lt;- datos %&gt;% tabyl(age_cat, gender) %&gt;% # contar para edad y genero adorn_totals(where = list(&quot;row&quot;,&quot;col&quot;)) %&gt;% # agregar totales adorn_percentages(denominator = &quot;col&quot;) %&gt;% # cambiar a porcentaje adorn_pct_formatting(digits = 2) # nùmero de digitos tabla7 # ¿Como se diferencian estas tablas? tabla4 tabla5 # por fila tabla6 # por la columna tabla7 # agrega dos totales # Agregamos titulos tabla8 &lt;- datos %&gt;% tabyl(age_cat, gender) %&gt;% adorn_totals(where = &quot;row&quot;) %&gt;% adorn_percentages(denominator = &quot;row&quot;) %&gt;% # adorn_pct_formatting(digits = 2) %&gt;% adorn_ns(position = &quot;rear&quot;) %&gt;% # front para colocar parentesis en % adorn_title( # Agregar titulos row_name = &quot;Cat. edad&quot;, col_name = &quot;Genero&quot;) tabla8 # Exportamos tablas utilizando `rio` y `here`. lista &lt;- list(tabla4,tabla5,tabla6,tabla7,tabla8) lista for (i in 1:5){ export(lista[i],here(&quot;resultados&quot;, &quot;ejercicio1&quot;, paste(&quot;tabla&quot;,i + 3,&quot;.xlsx&quot;,sep=&quot;&quot;))) } pacman::p_load(flextable) # Exportamos la tabla directamente desde flextable tabla8_imagen_word &lt;- datos %&gt;% tabyl(age_cat, gender) %&gt;% adorn_totals(where = &quot;col&quot;) %&gt;% adorn_percentages(denominator = &quot;col&quot;) %&gt;% adorn_pct_formatting(digits = 2) %&gt;% adorn_ns(position = &quot;front&quot;) %&gt;% adorn_title( row_name = &quot;Categoria Edad&quot;, col_name = &quot;Genero&quot;, placement = &quot;combined&quot;) %&gt;% flextable::flextable() %&gt;% flextable::autofit() %&gt;% flextable::save_as_docx(path = &quot;tabla8_imagen.docx&quot;) 2.6.4 Estadística descriptiva con “dplyr” Ahora vamos a volver a utilizar los verbos del paquete “dplyr” que vimos la sección anterior. Vamos a generar las mismas cosas, pero de otra forma. Frecuencias: # Removemos todo, menos datos rm(list=ls()[! ls() %in% c(&quot;datos&quot;)]) # 1. ¿Cuál es el total de datos? tabla1 &lt;- datos %&gt;% summarise(n_rows = n()) tabla1 # 2. ¿Cuál es el total por categorías de edad? (con group_by y con summarize)? tabla2 &lt;- datos %&gt;% group_by(age_cat) %&gt;% summarise(n_rows = n()) tabla2 # 3. ¿Cuál es el total por categorías de edad (con count)? tabla3 &lt;- datos %&gt;% count(age_cat) tabla3 # 4. ¿Cuál es el total por categorías de edad y outcome (con count)? tabla4 &lt;- datos %&gt;% count(age_cat, outcome) tabla4 # 5. Equivalente con group_by() tabla4a &lt;- datos %&gt;% group_by(age_cat, outcome) %&gt;% summarise(n_rows = n()) tabla4a Porcentajes: tabla5 &lt;- datos %&gt;% count(outcome, age_cat) %&gt;% mutate( percent = (n / sum(n))*100) tabla5 tabla6 &lt;- datos %&gt;% group_by(outcome) %&gt;% count(age_cat) %&gt;% mutate(percent = (n / sum(n)*100)) tabla6 Resumen: tabla7 &lt;- datos %&gt;% # armamos la tabla como un nuevo objeto group_by(hospital) %&gt;% # agrupamos todos los cálculos por hospital summarise( # generamos la estadística que nos interesa cases = n(), # número de observaciones por grupo delay_max = max(days_onset_hosp, na.rm = TRUE), # maximo retraso delay_mean = round(mean(days_onset_hosp, na.rm = TRUE), digits = 1), # retraso promedio delay_sd = round(sd(days_onset_hosp, na.rm = TRUE), digits = 1), # desviacion estandar retraso delay_3 = sum(days_onset_hosp &gt;= 3, na.rm = TRUE), # número de hospitales on retrasos mayores a tres dias pct_delay_3 = (delay_3 / cases)) # porcentaje de lo anterior tabla7 Estadísticas condicionales: tabla8 &lt;- datos %&gt;% group_by(hospital) %&gt;% summarise( max_temp_fvr = max(temp[fever == &quot;yes&quot;], na.rm = TRUE), max_temp_no = max(temp[fever == &quot;no&quot;], na.rm = TRUE) ) tabla8 # ¿Cuál es la temperatura promedio para los pacientes que tuvieron fiebre y para los que no? tabla9 &lt;- datos %&gt;% group_by(hospital) %&gt;% summarise( promedio_temp_fvr = mean(temp[fever == &quot;yes&quot;], na.rm = TRUE), promedio_temp_no = mean(temp[fever == &quot;no&quot;], na.rm = TRUE) ) tabla9 Percentiles: # Percentiles por defecto de la variable edad (0%, 25%, 50%, 75%, 100%). # Usamos la función `quantile()`. tabla10 &lt;- datos %&gt;% summarise(percentiles_edad = quantile(age_years, na.rm = TRUE)) tabla10 # Agregarlos manualmente tabla11 &lt;- datos %&gt;% summarise( percentiles_edad = quantile( age_years, probs = c(.05, 0.5, 0.75, 0.98), na.rm=TRUE) ) tabla11 # También los podemos calcular combinando con otro verbos y mas especifico tabla12 &lt;- datos %&gt;% group_by(hospital,outcome) %&gt;% summarise( p05 = quantile(age_years, probs = 0.05, na.rm=TRUE), p50 = quantile(age_years, probs = 0.5, na.rm=TRUE), p75 = quantile(age_years, probs = 0.75, na.rm=TRUE), p98 = quantile(age_years, probs = 0.98, na.rm=TRUE) ) tabla12 # También podemos hacerlo utilizando `get_summary_stats()` tabla13 &lt;- datos %&gt;% group_by(hospital) %&gt;% rstatix::get_summary_stats(age, type = &quot;quantile&quot;) tabla13 Resumir datos agregados: # Contamos y quitamos los NA tabla14 &lt;- datos %&gt;% drop_na(gender, outcome) %&gt;% count(outcome, gender) tabla14 # Contamos por grupos y con condiciones. tabla15 &lt;- tabla14 %&gt;% group_by(outcome) %&gt;% summarise( total_cases = sum(n, na.rm=T), male_cases = sum(n[gender == &quot;m&quot;], na.rm=T), female_cases = sum(n[gender == &quot;f&quot;], na.rm=T)) tabla15 # Hacer lo mismo, pero para mas grupos y variables tabla16 &lt;- datos %&gt;% group_by(outcome) %&gt;% summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # columnas .fns = mean, # funcion na.rm = TRUE)) # opciones tabla16 # Para todas las variables numéricas tabla17 &lt;- datos %&gt;% group_by(outcome) %&gt;% summarise(across( .cols = where(is.numeric), .fns = mean, na.rm=T)) tabla17 # De long a wide pacman::p_load(scales) tabla18 &lt;- datos %&gt;% group_by(outcome) %&gt;% count(age_cat) %&gt;% mutate(percent = scales::percent(n / sum(n))) tabla18 # La tabla esta en formato long! tabla19 &lt;- tabla18 %&gt;% select(-percent) %&gt;% # no quiero porcentaje pivot_wider(names_from = age_cat, values_from = n) tabla19 # Tabla con totales tabla20 &lt;- datos %&gt;% group_by(gender) %&gt;% summarise( known_outcome = sum(!is.na(outcome)), # Número de filas del grupo en las que no falta el resultado n_death = sum(outcome == &quot;Death&quot;, na.rm=T), # Número de filas en el grupo donde el resultado es Muerte n_recover = sum(outcome == &quot;Recover&quot;, na.rm=T), # Número de filas del grupo cuyo resultado es Recuperado ) %&gt;% adorn_totals() %&gt;% # Adornar la fila total (suma de cada columna numérica) adorn_percentages(&quot;row&quot;) %&gt;% # Proporciones adorn_pct_formatting() %&gt;% # porcetnaje adorn_ns(position = &quot;rear&quot;) # () tabla20 # Exportamos todas las tablas lista_tablas &lt;- list(tabla1,tabla2,tabla3,tabla4,tabla5, tabla6,tabla7,tabla8,tabla9,tabla10, tabla11,tabla12,tabla13,tabla14,tabla15, tabla16,tabla17,tabla18,tabla19,tabla20) lista_tablas for (i in 1:20){ export(lista_tablas[i],here(&quot;resultados&quot;, &quot;ejercicio2&quot;, paste(&quot;tabla&quot;,i,&quot;.xlsx&quot;,sep=&quot;&quot;))) } Juntar tablas: # Algunas estadísticas por hospital y outcome tabla21 &lt;-datos %&gt;% filter(!is.na(outcome) &amp; hospital != &quot;Missing&quot;) %&gt;% # Dejo todo lo que no sea missing group_by(hospital, outcome) %&gt;% # agrupo por hospital y outcome summarise( N = n(), ct_value = median(ct_blood, na.rm=T)) tabla21 # Algunas estadísticas solo por outcome tabla22 &lt;- datos %&gt;% filter(!is.na(outcome) &amp; hospital != &quot;Missing&quot;) %&gt;% group_by(outcome) %&gt;% # Ahora agrupo solo por outcome, no hospital summarise( N = n(), # Estadisticas solo por outcome ct_value = median(ct_blood, na.rm=T)) tabla22 # Juntando table_long &lt;- bind_rows(tabla21, tabla22) %&gt;% mutate(hospital = replace_na(hospital, &quot;Total&quot;)) table_long # A formato long y a exportar table_long %&gt;% mutate(hospital = replace_na(hospital, &quot;Total&quot;)) %&gt;% pivot_wider( # de largo a ancho values_from = c(ct_value, N), # cambio valores names_from = outcome) %&gt;% # cambio columnas mutate( # agrego nuevas columnas N_Known = N_Death + N_Recover, # numero total Pct_Death = scales::percent(N_Death / N_Known, 0.1), # % casos que murieron Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # % casos recuperados select( # reordeno columnas hospital, N_Known, # totales N_Recover, Pct_Recover, ct_value_Recover, # recuperado N_Death, Pct_Death, ct_value_Death) %&gt;% # muertes arrange(N_Known) %&gt;% # Ordeno flextable::flextable() %&gt;% # a imagen flextable::autofit() %&gt;% # una linea por fila flextable::save_as_docx(path = here(&quot;resultados&quot;,&quot;ejercicio2&quot;,&quot;tablefinal.docx&quot;)) # exporto 2.7 Visualización 2.7.1 Visualización: R base Vamos a hacer graficos unicamente utilizando R básico. 2.7.1.1 Plot # Para visualizar datos altura &lt;- c(168, 177, 177, 177, 178, 172, 165, 171, 178, 170) peso &lt;- c(88, 72, 85, 52, 71, 69, 61, 61, 51, 75) # Gráfico simple plot(altura, peso, ylab = &quot;Peso (kg)&quot;, xlab = &quot;Altura (cm)&quot;) # Ahora lo vamos a exportar setwd(here(&quot;figuras&quot;)) pdf(&quot;g1.pdf&quot;) plot(altura,peso) dev.off() rm(altura,peso) 2.7.1.2 Histograma # Buscar ayuda: ?hist() # Implementarla g2 &lt;- hist(wage, breaks = 20, # número de intervalos main = &quot;Distribución del Salario (dólares por hora)&quot;, # título del gráfico xlab = &quot;Salario&quot;, # título del eje x ylab = &quot;Número de personas&quot; # título del eje y ) g2 # Podemos agregar colores g2 &lt;- hist(wage, breaks = 20, # n?mero de intervalos main = &quot;Distribución del Salario (dólares por hora)&quot;, # título del gráfico xlab = &quot;Salario&quot;, # título del eje x ylab = &quot;Numero de personas&quot;, # título del eje y col = &quot;pink&quot; ) g2 # También podemos agregar límites en los ejes g2 &lt;- hist(wage, breaks = 20, # número de intervalos main = &quot;Distribución del Salario (dólares por hora)&quot;, xlab = &quot;Salario&quot;, ylab = &quot;Número de personas&quot;, col=&quot;pink&quot;, xlim = c(0,50),# Límites del histograma freq = TRUE #TRUE = freq. absoluta, FALSE: relativa. ) g2 # Podemos hacer lo mismo, pero agregar la distribución empirica pdf(&quot;g3.pdf&quot;) g3 &lt;- hist(wage, breaks = 20, # número de intervalos main = &quot;Distribución del Salario (dólares por hora)&quot;, xlab = &quot;Salario&quot;, ylab = &quot;Número de personas&quot;, col=&quot;pink&quot;, xlim = c(0,30), ylim = c(0, .12), # Límites del histograma freq = FALSE, #TRUE = freq. absoluta, FALSE: relativa. ) # Agrego la distribución empirica de los datos lines(density(wage), col=&quot;blue&quot;, lwd=2) Opciones: # lwd = line width # col = color # lty = line type # opciones de lty (0 = blank, 1 = solid (default), # 2 = dashed, 3 = dotted, # 4 = dotdash, 5 = longdash, # 6 = twodash) # Agregar más de una distribución lines(density(wage, adjust=2), col=&quot;red&quot;, lwd=2, lty=2) # adjust=2 lo que hace es suavizar un poco la curva # Agregar el promedio y la mediana # Promedio abline(v = mean(wage), lwd = 2, lty = 3, col=&quot;darkgreen&quot;) # Mediana abline(v = median(wage), lwd = 2, lty = 3, col=&quot;darkblue&quot;) dev.off() # Notar que solo hemos utilizado paquetes básicos de R. # Ahora, podemos exportar el gráfico a la carpeta. 2.7.1.3 Gráfico de dispersión # Básico dev.off() plot(experience, wage) plot(wage~experience) # Mejorando la presentación plot (wage ~ experience, main = &quot;Salario en función de la experiencia&quot;, xlab = &quot;Experiencia (en años)&quot;, ylab = &quot;Salario&quot; ) # Podemos agrupar CPS1985 &lt;- CPS1985 %&gt;% mutate(sexo = as.numeric(gender)) pdf(&quot;g4.pdf&quot;) g4 &lt;- plot (wage ~ experience, data = CPS1985, pch = sexo, #Diferente simbolo dependiendo del género col = sexo, #Color diferenciado por género main = &quot;Salario en función de la experiencia&quot;, xlab = &quot;Experiencia (en años)&quot;, ylab = &quot;Salario&quot; ) # Agregamos Leyenda legend(&quot;topright&quot;, legend=c(&quot;Hombres&quot;,&quot;Mujeres&quot;), pch=1:2, col=1:2, bty=&quot;n&quot;) #Caja de la leyenda legend(&quot;topleft&quot;, legend=c(&quot;Hombres&quot;,&quot;Mujeres&quot;), pch=1:2, col=1:2) # Agregamos una regresión with(CPS1985[gender==&quot;male&quot;,], abline(lm(wage~experience), col=&quot;black&quot;)) with(CPS1985[gender==&quot;female&quot;,], abline(lm(wage~experience), col=&quot;red&quot;)) dev.off() 2.7.1.4 Gráfico de barras # Primero tenemos que crear las frecuencias frecuencias &lt;- table(occupation) # con variable categórica frecuencias # Básico barplot(frecuencias, col = c(1:6) ) # Ahora con educación educacion &lt;- table(education) pdf(&quot;g5.pdf&quot;) g5 &lt;- barplot(educacion, col = 1:dim(educacion), # para establecer el número de diferentes colores (=diferentes valores) horiz = FALSE, # orientación de las barras ylim = c(0,250) ) # Agregamos un título title(&quot;Distribución de la educación&quot;, xlab= &quot;Educación (en años)&quot;, ylab = &quot;Número de personas&quot;) dev.off() 2.7.1.5 Gráfico de torta datos &lt;- table(ethnicity) datos pie(datos, labels=c(&quot;Caucasicos&quot;, &quot;Hispanos&quot;, &quot;Otros&quot;), col = heat.colors(3), main = &quot;Frecuencia de etnias&quot;, clockwise = FALSE) # Podemos cambiar los colores colores&lt;-c(&quot;darkred&quot;,&quot;pink&quot;,&quot;red&quot;) pdf(&quot;g6.pdf&quot;) g6 &lt;- pie(datos, labels = levels(ethnicity), col = colores, main = &quot;Frecuencia etnias&quot;) dev.off() 2.7.1.6 Boxplot Algunas cosas que tener en cuenta sobre un boxplot: Se le llama grafico de caja y bigote. Primer quartil (1): borde inferior de la caja. Mediana: Linea de al medio de la caja. Tercer quartil: Borde superior de la caja. Rango intercuartil: Diferencia entre el tercer cuartil y el primero. Sobre el gráfico: Caja más grande implica que los datos están mas dispersos. Tamaño de la caja es el rango intercuartil. Si la mediana esta al centro, la distribución es simétrica. ¿Que pasa si la parte superior (sobre la linea) es más grande? Los datos se concentran en la parte baja de la distribución. Los bigotes determinan el límite para valores atípicos.Su longitud máxima es de un 150% del Rango intercuartil (RIC). dev.off() boxplot(wage, main = &quot;Salario (dólares por hora)&quot;, ylab = &quot;Salario&quot;, col = &quot;pink&quot;, border = &quot;red&quot;) # Separando por sexo boxplot(wage ~ gender, main = &quot;Salario (dólares por hora) según sexo&quot;, ylab = &quot;Salario&quot;, col = c(&quot;pink&quot;,&quot;darkgreen&quot;), border = &quot;black&quot;) #Horizontal boxplot(wage ~ gender, main = &quot;Salario (dólares por hora) según sexo&quot;, ylab = &quot;Salario&quot;, names = c(&quot;Hombres&quot;,&quot;Mujeres&quot;), #Cambiar nombres horizontal = T, #Posición horizontal col = rainbow(2, alpha=0.8), #Paleta rainbow (aleatoria) y transparencia (alpha) border = &quot;black&quot;) 2.7.2 Uso paquete ggplot Ahora vamos a utilizar un paquete avanzado de visualización. Primero, algunos aspectos relacionados con la lógica de su uso. Utilizar ggplot2 es básicamente ir agregando capas. Entre cada cosa que quiero agregar al gráfico debo colocar un signo +. La sintaxis básica incluye: Comience con el comando ggplot() de la línea de base, esto “abre” el ggplot y permite que las funciones subsecuentes sean agregadas con +. Normalmente el conjunto de datos también se especifica en este comando. Añadir capas “geom”, estas funciones visualizan los datos como geometrías (formas), por ejemplo, como un gráfico de barras, un gráfico de líneas, un gráfico de dispersión, un histograma (¡o una combinación!). Todas estas funciones comienzan con geom_ como prefijo. Añade elementos de diseño al gráfico, como etiquetas de ejes, títulos, fuentes, tamaños, esquemas de color, leyendas o rotación de ejes. Ejemplo: ggplot(datos, aes(x = experience, y = wage)) + geom_point( color = &quot;blue&quot;) + labs()+ theme() Ahora ya entendemos la sintaxis general. Para cambiar de tipo de gráficos tenemos distintas geometrías. # geom_point (para puntos) # geom_line (para lineas) # geom_histogram (para histograma) # geom_boxplot (para boxplot) # geom_bar o geom_col() (para barras) # geom_smooth (lineas suavizadas) 2.7.2.1 Geometrías Otros tienen más sentido con una variable ggplot(datos, aes(x = experience))+ geom_histogram() + labs()+ theme() ggplot(datos, mapping = aes(x = experience, y = wage))+ geom_smooth(color = &quot;red&quot;) + labs()+ theme() 2.7.2.2 Aesthetics Otro aspecto importante es lo que se denomina “aesthetics”. Estas son las características visuales de los datos. En ggplot estos son modificados dentro de la opción theme(). No todas las geometrías tienen las mismas opciones. Sin embargo, algunas comunes son: shape: Mostrar un punto con geom_point() como punto, estrella, triángulo o cuadrado. fill: El color interior (por ejemplo, de una barra o boxplot) color: La línea exterior de una barra, boxplot, etc., o el color del punto si se utiliza geom_point() size: Tamaño (por ejemplo, grosor de la línea, tamaño del punto) alpha: Transparencia (1 = opaco, 0 = invisible) binwidtho: Ancho de los bins o cajas del histograma width: Anchura de las columnas del “bar plot”. linetype: Tipo de línea (por ejemplo, sólida, discontinua, punteada) Los “aesthetics” pueden ser asignados a valores o a vectores. Ejemplo: # Visualización de puntos ggplot(datos, aes(x = experience, y = wage))+ geom_point(color = &quot;darkgreen&quot;, size = 2.8, alpha = 0.2) + theme() # Histograma ggplot(datos, mapping = aes(x = wage))+ geom_histogram(color = &quot;white&quot;, fill = &quot;pink&quot;, binwidth = 5 , alpha = 1) 2.7.2.3 Escalar los valores o agrupar # Si queremos diferenciar alguna variable categorica por color (agrupar) ggplot(datos, aes(experience, wage, color = gender)) + geom_point() # Si queremos diferenciar alguna variable continua por tamaño (escalar) ggplot(datos, aes(x = experience, y = wage, size = age)) + geom_point(shape = &quot;circle&quot;, alpha = 0.3) # Ambos (agrupar y escalar) ggplot(data = datos, mapping = aes(x = experience, y = wage, size = age, color = gender)) + geom_point(shape = &quot;circle&quot;, alpha = 0.3) 2.7.2.4 Equivalencia sintaxis ggplot # Notar que estas tres sintaxis son equivalentes ggplot(data = datos, mapping = aes(x = age))+ geom_histogram() ggplot(data = datos)+ geom_histogram(mapping = aes(x = age)) ggplot()+ geom_histogram(data = datos, mapping = aes(x = age)) 2.7.2.5 Combinar gráficos facet_wrap(): Mostrar un panel diferente para cada nivel de una sola variable. Un ejemplo de esto podría ser mostrar una figura diferente para cada region de un país. Las facetas se ordenan alfabéticamente, a menos que la variable sea un factor con otro ordenamiento definido. Por ejemplo: # Datos malaria_data &lt;- import(here(&quot;datos&quot;, &quot;malaria_facility_count_data.rds&quot;)) %&gt;% select(-submitted_date, -Province, -newid) # A plot with facets by district ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) + geom_col(width = 1, fill = &quot;darkred&quot;) + # graficamos datos como columnas theme_minimal() + # simplificamos la parte de atras labs(x = &quot;Fecha&quot;, #Etiquetas/labels y = &quot;Casos de Malaria&quot;, title = &quot;Casos de Malaria por distrito&quot;) + facet_wrap(~District) # creamos las facetas facet_grid(): Se utiliza cuando se quiere introducir una segunda variable en la disposición de las facetas. Aquí cada panel de una cuadrícula muestra la intersección entre los valores de dos columnas. Por ejemplo: malaria_age &lt;- malaria_data %&gt;% select(-malaria_tot) %&gt;% pivot_longer( cols = c(starts_with(&quot;malaria_rdt_&quot;)), names_to = &quot;grupo_edad&quot;, values_to = &quot;num_casos&quot; ) %&gt;% mutate( age_group = str_replace(grupo_edad, &quot;malaria_rdt_&quot;, &quot;&quot;)) ggplot(malaria_age, aes(x = data_date, y = num_casos)) + geom_col(fill = &quot;darkred&quot;, width = 1) + theme_minimal()+ labs( x = &quot;Fechas&quot;, y = &quot;Casos&quot;, title = &quot;Casos de Malaria por grupos de edad y distrito&quot;) + facet_grid(District ~ age_group) 2.7.2.6 Modificar y guardar Modificar graficos: Una cosa muy positiva de ggplot() es que uno puede definirlo con un nombre y luego ir sobre-escribiendolo. Eso es muy útil para la sintaxis. # Gráfico original histograma &lt;- ggplot(data = datos, mapping = aes(x = age))+ geom_histogram() histograma # Gráfico modificado. histograma_modificado &lt;- histograma + geom_vline(xintercept = 50) histograma_modificado # Noten que solamente hemos agregado la nueva opción sobre el objeto asignado. # Muy útil y recomendable para hacer visualizaciones en R. Exportar gráficos: Para los gráfico que se generen con ggplot() es posible utilizar la opción ggsave(). ggsave(here(&quot;figuras&quot;, &quot;histograma.pdf&quot;), histograma_modificado) 2.7.2.7 Labels distribucion_salarios &lt;- ggplot( data = datos, # datos mapping = aes( # ejes x = age, y = wage, color = occupation))+ # agrupo geom_point()+ # geometria labs( title = &quot;Salarios por edad&quot;, subtitle = &quot;Estados Unidos, 1985&quot;, x = &quot;Edad en años&quot;, y = &quot;Salario en dólares por hora&quot;, color = &quot;Ocupación&quot;, caption = stringr::str_glue(&quot;Maxima edad es: {max(datos$age, na.rm=TRUE)}&quot;)) distribucion_salarios 2.7.2.8 Temas # Clasico distribucion_salarios + theme_classic() # Mínimo distribucion_salarios + theme_minimal() # Oscuro distribucion_salarios + theme_dark() # Claro distribucion_salarios + theme_light() # Gris distribucion_salarios + theme_grey() # Blanco y negro distribucion_salarios + theme_bw() 2.7.2.9 Piping y ggplot rm(list = ls()) datos &lt;- import(here(&quot;datos&quot;, &quot;linelist_cleaned.rds&quot;)) datos %&gt;% select(c(case_id, fever, chills, cough, aches, vomit)) %&gt;% pivot_longer( cols = -case_id, names_to = &quot;symptom_name&quot;, values_to = &quot;symptom_is_present&quot;)%&gt;% mutate( symptom_is_present = replace_na(symptom_is_present, &quot;unknown&quot;)) %&gt;% ggplot( mapping = aes(x = symptom_name, fill = symptom_is_present))+ geom_bar(position = &quot;fill&quot;, col = &quot;black&quot;) + theme_minimal() + labs( x = &quot;Sintoma&quot;, y = &quot;Sintoma (status)&quot; ) 2.7.2.10 Gráficos para variables continuas Histograma: rm(list = ls()) data(&quot;CPS1985&quot;) data &lt;- CPS1985 rm(CPS1985) attach(data) #Gráfico absoluto ggplot(data, aes(x=wage)) + geom_histogram() #Gráfico relativo ggplot(data, aes(x=wage)) + geom_histogram(aes(y=..density..)) # Histograma con 20 intervalos ggplot(data, aes(x=wage)) + geom_histogram(bins=100, color=&quot;black&quot;, fill=&quot;blue&quot;, alpha = 0.8) #Agregando títulos y limites ggplot(data, aes(x=wage)) + geom_histogram(bins=20, color=&quot;white&quot;, fill=&quot;blue&quot;) + labs(title = &quot;Distribución del salario (dólares por hora)&quot;, x = &quot;Salario&quot;, y = &quot;Número de empleados&quot;) + xlim(0,30) #Gráficos de subconjuntos ggplot(data, aes(x=wage)) + geom_histogram(bins=20, color=&quot;white&quot;, fill=&quot;pink&quot;) + facet_grid(gender~.) # U horizontal ggplot(data, aes(x=wage)) + geom_histogram(bins=20, color=&quot;white&quot;, fill=&quot;pink&quot;) + facet_wrap(~gender)+ labs(title = &quot;Distribución del salario (dólares por hora)&quot;, x = &quot;Salario&quot;, y = &quot;Número de empleados&quot;) + xlim(0,30) + theme_minimal() # O ambos juntos ggplot(data, aes(x=wage)) + geom_histogram(bins=20, aes(fill=gender), position=&quot;fill&quot;, alpha=0.6) + labs(title = &quot;Distribución del salario (dólares por hora)&quot;, x= &quot;Salario&quot;, y=&quot;Empleados&quot;, fill=&quot;Género&quot;) + # títulos de ejes y leyenda scale_fill_discrete(labels=c(&quot;Hombre&quot;,&quot;Mujer&quot;)) + # títulos claves leyenda xlim(0,30) Gráfico de densidad: ggplot(data, aes(x=wage, color=gender)) + geom_freqpoly(bins=20, aes(y=..density..)) + labs(color=&quot;Género&quot;) # Uniendo a y b ggplot(data, aes(x=wage)) + geom_histogram(aes(y=..density..), bins=20, color=&quot;white&quot;, fill=&quot;pink&quot;) + #stat_function(fun = dnorm, colour = &quot;red&quot;, # args = list(mean = mean(wage, na.rm = TRUE), # sd = sd(wage, na.rm = TRUE))) + geom_density(color=&quot;blue&quot;)+ labs(title=&quot;Distribución del salario (dólares por hora)&quot;, x= &quot;Salario&quot;, y=&quot;Empleados&quot;) Diagrama de dispersión (scatterplot): ggplot(data, aes(experience, log(wage))) + geom_point() + labs(title=&quot;Diagrama de dispersión&quot;, subtitle= &quot;ScatterPlot&quot;, caption=&quot;Fuente: CPS1985 (paquete AER)&quot;, x=&quot;Experiencia (en años)&quot;, y=&quot;Salario (en logaritmo)&quot;) # Formas de darle color al gráfico # (1) Desde geom_() ggplot(data, aes(experience, log(wage))) + geom_point(aes(color=gender)) # (2) Desde ggplot() ggplot(data, aes(experience, log(wage), color=&quot;red&quot;)) + geom_point() # Función jitter (shortcut geom_point(position = &quot;jitter&quot;) ggplot(data, aes(experience,log(wage))) + geom_jitter(width=.2, alpha=0.5) + #Suavizar la visualización de solapamiento labs(title=&quot;Diagrama de dispersión&quot;, subtitle= &quot;ScatterPlot&quot;, caption=&quot;Fuente: CPS1985 (paquete AER)&quot;, x=&quot;Experiencia (en años)&quot;, y=&quot;Salario (en logaritmo)&quot;) # Diviendo por categorías ggplot(data, aes(experience,log(wage), color=gender)) + geom_jitter() + geom_smooth(method=&quot;lm&quot;) + labs(title=&quot;Diagrama de dispersión&quot;, x=&quot;Experiencia (en años)&quot;, y=&quot;Salario (en logaritmo)&quot;) + scale_color_discrete(name=&quot;Género&quot;, labels=c(&quot;Hombre&quot;,&quot;Mujer&quot;)) # Nota: Ojo con realizar de otra manera, cambia la recta de regresión ggplot(data, aes(experience,log(wage))) + geom_point(aes(color=gender)) + geom_smooth(method=&quot;lm&quot;) + labs(title=&quot;Diagrama de dispersión&quot;, x=&quot;Experiencia (en años)&quot;, y=&quot;Salario (en logaritmo)&quot;) + scale_color_discrete(&quot;Género&quot;, labels=c(&quot;Hombre&quot;,&quot;Mujer&quot;)) Boxplot: # Básico ggplot(data, aes(x=gender, y=wage, fill=gender)) + geom_boxplot() + labs(title=&quot;Boxplot&quot;, x=&quot;Género&quot;, y=&quot;Salario&quot;, fill=&quot;Género&quot;) + # titulo ejes y leyenda scale_x_discrete(labels=c(&quot;Hombre&quot;,&quot;Mujer&quot;)) + # etiquetas del eje x scale_fill_discrete(labels=c(&quot;Hombre&quot;,&quot;Mujer&quot;)) # etiquetas claves leyenda #Visualizando todos los datos con paletas creadas (armamos una función) ts4_colors &lt;- c( `pink` = &quot;#B40586&quot;, `light blue` = &quot;#00A2E9&quot;, `green` = &quot;#00AC8B&quot;, `orange` = &quot;#f37735&quot;, `red` = &quot;#FF1B6B&quot;, `purple` = &quot;#805FAA&quot;, `blue` = &quot;#0059ff&quot;, `light green` = &quot;#7EAF64&quot;) ts4_cols &lt;- function(...) { cols &lt;- c(...) if (is.null(cols)){ return (ts4_colors) } ts4_colors[cols] } ts4_cols(&quot;red&quot;) ts4_cols() ggplot(data, aes(x=gender, y=wage, fill=gender) ) + geom_boxplot(alpha=0.3, fill=ts4_cols(&quot;pink&quot;,&quot;light green&quot;), outlier.colour = ts4_cols(&quot;blue&quot;)) + labs(title=&quot;Boxplot&quot;,x=&quot;Género&quot;, y=&quot;Salario&quot;) + scale_x_discrete(labels=c(&quot;Hombre&quot;,&quot;Mujer&quot;)) + guides(fill=FALSE) + coord_flip() + geom_point(stat= &quot;summary&quot;, shape=16, size=4, colour=ts4_cols(&quot;purple&quot;)) + geom_jitter(width = 0.1, alpha = 0.2, colour=ts4_cols(&quot;orange&quot;)) Gráfico de barras: ggplot(data, aes(ethnicity)) + geom_bar() + labs(title=&quot;Diagrama de barras&quot;, x= &quot;Raza&quot;, y=&quot;Empleados&quot;) + scale_x_discrete(labels=c(&quot;Caucásico&quot;, &quot;Hispano&quot;, &quot;Otros&quot;)) # Distintos colores ggplot(data, aes(ethnicity, fill=ethnicity)) + geom_bar() + labs(title=&quot;Distribución de empleadores según etnia&quot;, x= &quot;Raza&quot;, y=&quot;Empleados&quot;) + scale_x_discrete(labels=c(&quot;Caucásico&quot;, &quot;Hispano&quot;, &quot;Otros&quot;)) + guides(fill=FALSE) # Sin/con leyenda # ¿Cómo se distribuye el género sobre la etnia? ggplot(data, aes(ethnicity, fill=gender)) + geom_bar() + labs(title=&quot;Diagrama de barras&quot;, x= &quot;Etnia&quot;, y=&quot;Empleados&quot;) + scale_x_discrete(labels=c(&quot;Caucásico&quot;, &quot;Hispano&quot;, &quot;Otros&quot;)) + scale_fill_discrete(&quot;Género&quot;, labels=c(&quot;Hombre&quot;,&quot;Mujer&quot;)) # Separado por género, pero paralelo ggplot(data, aes(ethnicity, fill=gender)) + geom_bar(position=&quot;dodge&quot;) + # también: position=position_dodge() labs(title=&quot;Distribución de empleadores según etnia&quot;, x= &quot;Raza&quot;, y=&quot;Empleados&quot;) + scale_x_discrete(labels=c(&quot;Caucásico&quot;, &quot;Hispano&quot;, &quot;Otros&quot;)) + scale_fill_brewer(palette = &quot;Accent&quot;, # Definir la paleta manualmente &quot;Género&quot;, labels=c(&quot;Hombre&quot;,&quot;Mujer&quot;)) 2.7.2.11 Gráficos con plotly Ejemplo 1: g1 &lt;- ggplot(data, aes(ethnicity, fill=gender)) + geom_bar(position=&quot;dodge&quot;) + # también: position=position_dodge() labs(title=&quot;Distribución de empleadores según etnia&quot;, x= &quot;Raza&quot;, y=&quot;Empleados&quot;) + scale_x_discrete(labels=c(&quot;Caucásico&quot;, &quot;Hispano&quot;, &quot;Otros&quot;)) + scale_fill_brewer(palette = &quot;Accent&quot;, #Definir la paleta manualmente &quot;Género&quot;, labels=c(&quot;Hombre&quot;,&quot;Mujer&quot;)) g1 ggplotly(g1) Ejemplo 2: set.seed(100) #semilla d &lt;- diamonds[sample(nrow(diamonds), 1000), ] p &lt;- ggplot(data = d, aes(x = carat, y = price)) + geom_point(aes(text = paste(&quot;Clarity:&quot;, clarity)), size = 1) + geom_smooth(aes(colour = cut, fill = cut)) + facet_wrap(~ cut) p ggplotly(p) Recordatorio: Set seed o sembrar la semilla nos permite generar datos seudo aleatorizados pero replicables, de manera que cualquier persona que acceda al script sea capaz de llegar a los mismos resultados que nosotros. El número que se incluye dentro de la función actua como un “código” que genera estos datos aleatorios, y puede ser cualquiera. Ejemplo 3: Ocupar directamente plotly data(iris) fig &lt;- plot_ly(data = iris, x = ~Sepal.Length, y = ~Petal.Length, color=~Species) fig # Sacar barra de opciones y zoom fig %&gt;% layout(yaxis = list(fixedrange = TRUE), showlegend = TRUE, xaxis = list(fixedrange = TRUE)) %&gt;% config(displayModeBar = FALSE) #Line plot x &lt;- c(1:50) random_y &lt;- rnorm(50, mean = 0) data &lt;- data.frame(x, random_y) fig &lt;- plot_ly(data, x = ~x, y = ~random_y, type = &#39;scatter&#39;, mode = &#39;lines&#39;) fig # Histogramas fig &lt;- plot_ly(x = ~rnorm(50), type = &quot;histogram&quot;) fig # Con 2 grupos fig &lt;- plot_ly(alpha = 0.6) fig &lt;- fig %&gt;% add_histogram(x = ~rnorm(500)) fig &lt;- fig %&gt;% add_histogram(x = ~rnorm(500) + 1) fig &lt;- fig %&gt;% layout(barmode = &quot;overlay&quot;) fig # Boxplot fig &lt;- plot_ly(y = ~rnorm(50), type = &quot;box&quot;) fig &lt;- fig %&gt;% add_trace(y = ~rnorm(50, 1)) fig 2.8 Análisis de datos y generación de informes con R Markdown 2.8.1 Test de hipótesis Imaginen que una compañia quiere testear la efectividad de una estrategia de venta. La estrategia A consiste en colocar un letrero que diga “oferta final”. La estrategia B consiste en dejar todo como siempre. Aleatoriamente se eligen los días y lugares en donde se utilizara la estrategia A y los días en que se utilizara la estrategia B. Luego, se registran los datos de ventas y se observan que las ventas de la compañía con la estrategia B fueron un 43,4% mayores a las tiendas con la estrategia A. La intuición se contradice con los datos, sin embargo, ¿Es esto debido al azar? ¿o bien es un resultado estadísticamente significativo? 2.8.1.1 Test de diferencia de media Una de las pruebas más comunes en estadística, la prueba t, se utiliza para determinar si las medias de dos grupos son iguales entre sí. La hipótesis de la prueba es que ambos grupos proceden de distribuciones normales con varianzas iguales. La hipótesis nula es que las dos medias son iguales, y la alternativa es que no lo son. Se sabe que bajo la hipótesis nula, podemos calcular un estadístico t que seguirá una distribución t. También existe una modificación ampliamente utilizada de la prueba t, conocida como prueba t de Welch, que ajusta el número de grados de libertad cuando se cree que las varianzas no son iguales entre sí. Este tutorial cubre los fundamentos de la realización de pruebas t en R. t.test() puede utilizarse para realizar pruebas t de una y dos muestras en vectores de datos. La función contiene una variedad de argumentos. La sintaxis es: # Datos data(&quot;midwest&quot;) names(midwest) head(midwest) skim(midwest) t.test(x, y = NULL, alternative = c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;), paired = FALSE, mu = 0, var.equal = FALSE, conf.level = 0.95) Aquí \\(x\\) es un vector numérico de valores de datos e \\(y\\) es un vector numérico opcional de valores de datos. Si se excluye \\(y\\), la función realiza una prueba t de una muestra sobre los datos contenidos en \\(x\\), si se incluye realiza una prueba t de dos muestras utilizando tanto \\(x\\) como \\(y\\). El argumento \\(mu\\) proporciona un número que indica el verdadero valor de la media (o la diferencia de medias si se realiza una prueba de dos muestras) bajo la hipótesis nula. Por defecto, la prueba realiza una prueba t de dos caras; sin embargo, puede realizar una hipótesis alternativa cambiando el argumento alternativo a “mayor” o “menor” dependiendo de si la hipótesis alternativa es que la media es mayor o menor que \\(mu\\), respectivamente. Por ejemplo: t.test(x, alternative = &quot;less&quot;, mu = 25) Realiza una prueba t de una muestra sobre los datos contenidos en \\(x\\) donde la hipótesis nula es que \\(mu = 25\\) y la alternativa es menor que 25. El argumento var.equal indica si se deben asumir o no varianzas iguales al realizar una prueba t de dos muestras. Por defecto se asume una varianza desigual. Por último, el argumento conf.level determina el nivel de confianza del intervalo de confianza. 2.8.1.2 t-test de una cola La prueba t de una muestra compara la media de una muestra con un valor conocido, cuando la varianza de la población es desconocida. Consideremos que queremos evaluar el porcentaje de adultos con estudios universitarios en el “midwest” y compararlo con un valor determinado. Por ejemplo, supongamos que la media nacional de adultos con estudios universitarios es del 32% (licenciatura o superior) y queremos ver si la media del “midwest” es significativamente diferente (en terminos estadísticos) de la media nacional. En concreto, queremos comprobar si la media del medio oeste es inferior a la media nacional. summary(midwest$percollege) # Gráficamente # En escala absoluta p1 &lt;- ggplot(midwest, aes(percollege)) + geom_histogram(fill = &quot;white&quot;, color = &quot;grey30&quot;) # En escala logarítmica p2 &lt;- ggplot(midwest, aes(percollege)) + geom_histogram(fill = &quot;white&quot;, color = &quot;grey30&quot;) + scale_x_log10() # La escala logarítmica es una transformación que sirve justificar el supuesto de normalidad. # La escala logarítmica hace que la distancia entre 10 y 100 sea la misma que entre 100 y 1000. grid.arrange(p1, p2, ncol = 2) # 1. Recordemos que queremos testear si el promedio del # &quot;midwest&quot; es menor que el promedio nacional. # 2. Hacemos tres test: t.test(midwest$percollege, mu = 32, alternative = &quot;less&quot;) El resultado nos indica que p &lt; 0.001 lo que nos dice que rechazamos la hipótesis nula (de que es igual a la nacional) lo que nos da evidencia estadística de que la media poblacional del “midwest” es menor que un 32%. Pero, como vimos anteriormente, tenemos problemas de no normalidad (recuerden el gráfico con las distribuciones empíricas). Para asegurarnos de que nuestra conclusión es correcta vamos a efectuar dos versiones alternativas del test: # La misma versión, pero en logaritmos... t.test(log(midwest$percollege), mu = log(32), alternative = &quot;less&quot;) # Wilcox test sirve cuando no deseamos asumir que los datos provienen de una distribución normal. wilcox.test(midwest$percollege, mu = 32, alternative = &quot;less&quot;) Ambos resultados apoyan nuestra conclusión inicial de que el porcentaje de adultos con estudios universitarios en el medio oeste es estadísticamente inferior a la media nacional. 2.8.1.3 t-test de dos colas Ahora digamos que queremos comparar las diferencias entre el porcentaje promedio de adultos con estudios universitarios en Ohio y en Michigan. En este caso, queremos realizar una prueba t de dos muestras. # Seleccionamos los datos df &lt;- midwest %&gt;% filter(state == &quot;OH&quot; | state == &quot;MI&quot;) %&gt;% select(state, percollege) # Estadisticas para ohio summary(df %&gt;% filter(state == &quot;OH&quot;) %&gt;% .$percollege) # Estadisticas para michigan summary(df %&gt;% filter(state == &quot;MI&quot;) %&gt;% .$percollege) Podemos ver que Ohio parece tener ligeramente menos adultos con estudios universitarios que Michigan. No obstante, el gráfico no nos dice si es estadísticamente significativo o no. ggplot(df, aes(state, percollege)) + geom_boxplot() p1 &lt;- ggplot(df, aes(percollege)) + geom_histogram(fill = &quot;white&quot;, color = &quot;grey30&quot;) + facet_wrap(~ state) # En logaritmos p2 &lt;- ggplot(df, aes(percollege)) + geom_histogram(fill = &quot;white&quot;, color = &quot;grey30&quot;) + facet_wrap(~ state) + scale_x_log10() grid.arrange(p1, p2, nrow = 2) # Realizamos los test # Sintaxis basica t.test(percollege ~ state, data = df) # Transformando los datos t.test(log(percollege) ~ state, data = df) # Sin asumir normalidad wilcox.test(percollege ~ state, data = df) Los resultados que aparecen a continuación muestran un valor \\(p &lt; 0.01\\) que apoya la hipótesis alternativa de que “la verdadera diferencia de medias no es igual a 0”; esencialmente afirma que existe una diferencia estadística entre las dos medias. 2.8.1.4 paired t - test Sirve para hacer test de diferencias de media para dos grupos que son estadisticamente iguales, pero que fueron sometidos a un tratamientom distinto. Lo que se quiere testear es si efectivamente la diferencia de promedios de alguna variable puede estar asociada a este tratamiento. Vamos a ocupar la base de datos de R llamada “sleep”. Imaginen queremos testear si una droga particular tiene un efecto estadisticamente significativo sobre las horas que se duerme. En particular, vamos a ver si la variable “extra” es diferente entre ambos grupos. Vamos a utilizar t.test() nuevamente, pero con la opción paired = TRUE. # Miramos los datos graficamente ggplot(sleep, aes(group, extra)) + geom_boxplot() # Testeamos t.test(extra ~ group, data = sleep, paired = TRUE) 2.8.2 Regresión Lineal en R 2.8.2.1 MCO con datos generados # Limpiar rm(list = ls()) # Fijar la semilla (Nos permite generar resultados reproducibles) set.seed(1234) # Genero número de observaciones N &lt;- 50 # Simular una variable x con una distribución uniforme runif(N,min,max) x &lt;- runif(N,1,40) x # Simular y rnorm(N,media,sd) y &lt;- 40 + 0.5*x + rnorm(N,0,2) y # Crear una base de datos (data.frame) con lo que yo genere. mco_data &lt;- data.frame(x,y) mco_data # Ahora, vamos a estimar por Minimos Cuadrados ordinarios # el modelo mco &lt;- lm(y ~ x, data = mco_data) mco summary(mco) # También lo podemos ver gráficamente ggplot(mco_data, aes(x,y))+ geom_point(with=.2, alpha=0.5) + geom_smooth(method = &quot;lm&quot;, se = TRUE) + labs(title = &quot;Diagrama de dispersión&quot;, subtitle = &quot;ScatterPlot&quot;, x = &quot;x&quot;, y = &quot;y&quot;) + theme_minimal() En resumen…. Para estimar: mco &lt;- lm(y ~ x1 + x2 + x3, data = misdatos) Para mirar resultados: summary(mco) Para mirar gráficamente: ggplot() + geom_point() + geom_smooth(method = \"lm\") 2.8.2.2 MCO con datos reales rm(list = ls()) data(&quot;CPS1985&quot;) names(CPS1985) # Correlación entre variables CPS1985 %&gt;% summarize(cor1 = cor(wage, education), cor2 = cor(wage, experience)) # Gráficamente ggplot(CPS1985, aes(education, log(wage))) + geom_point() + geom_smooth(method = &#39;lm&#39;, se = T) + labs(title=&quot;Diagrama de dispersión&quot;, subtitle= &quot;ScatterPlot&quot;, caption=&quot;Fuente: CPS1985 (paquete AER)&quot;, x=&quot;Educación en años&quot;, y=&quot;Salario (en logaritmo)&quot;) # Estimación # Creamos variables que utilizaremos en las estimaciones # Crear dos variables: log(wage) y experiencia al cuadrado. CPS1985$lnwage &lt;- log(CPS1985$wage) CPS1985$exp2 &lt;- CPS1985$exp * CPS1985$exp # R no nos permite elevar variables al cuadrado dentro de la función # Generamos variables categóricas que queramos incluir en la regresión # Variables dicótomicas (sobre variable binarias). table(CPS1985$gender) CPS1985$sexo &lt;- ifelse(CPS1985$gender == &quot;male&quot;, 1, 0) table(CPS1985$union) CPS1985$sind &lt;- ifelse(CPS1985$union == &quot;yes&quot;, 1, 0) # Variables dicótomas (sobre variables categóricas) CPS1985 &lt;- cbind(CPS1985, dummy(factor(CPS1985$occupation), sep = &quot;_&quot;)) # Generando formas editables f0 &lt;- wage ~ education f1 &lt;- lnwage ~ education f2 &lt;- lnwage ~ education + experience f3 &lt;- lnwage ~ education + experience + exp2 f4 &lt;- lnwage ~ education + experience + exp2 + sexo f5 &lt;- lnwage ~ education + experience + exp2 + sexo + sind f6 &lt;- lnwage ~ education + experience + exp2 + sexo + sind + CPS1985_services # Estimaciones mco_0 &lt;- lm(f0, data=CPS1985, na.action = na.exclude) mco_1 &lt;- lm(f1, data=CPS1985, na.action = na.exclude) mco_2 &lt;- lm(f2, data=CPS1985, na.action = na.exclude) mco_3 &lt;- lm(f3, data=CPS1985, na.action = na.exclude) mco_4 &lt;- lm(f4, data=CPS1985, na.action = na.exclude) mco_5 &lt;- lm(f5, data=CPS1985, na.action = na.exclude) mco_6 &lt;- lm(f6, data=CPS1985, na.action = na.exclude) # Mirar los resultados de mis estimaciones summary(mco_0) summary(mco_1) summary(mco_2) summary(mco_3) summary(mco_4) summary(mco_5) summary(mco_6) # Exportar resultados # El paquete se llama &quot;stargazer&quot; setwd(here(&quot;resultados&quot;)) stargazer(mco_1, mco_2, mco_3, # Modelos type = &quot;text&quot;, title = &quot;Estimación MCO salarios vs. educ&quot;, style = &quot;qje&quot;, # Estilos notes = &quot;\\\\footnotezie ***p=.01; ** p =.05; *p=.1&quot;, notes.append = F, # Para remplazar notas puestas anteriormente. single.row = F, # Para que los errores estandar esten en la misma linea que los coeficientes no.space = T, # No se generen espacios entre los regresores. out = &quot;est1-3.doc&quot;, digits = 2) 2.8.3 R Markdown Herramienta para crear informes que sean automáticos, reproducibles y con datos que se puedan actualizar en el tiempo. Se pueden generar informes en formato word, pdf, html. R markdown (Rmd) es básicamente una intersección entre texto narrativo y código que genera visualizaciones y estimaciones con el fin de analizar datos. Rmd puede generar: texto plano, segmentos de co ́digo, gr ́aficos, tablas, tableros interactivos. R markdown es especialmente útil: Informes rutinarios: Por ejemplo, informe semanal sobre un conjunto de análisis que se actualiza en el tiempo. Informes de análisis para un subconjunto de datos: Por ejemplo, informes por país de una base de datos que contiene información de distintos países. 2.8.3.1 Conceptos Básicos Markdown es el lenguaje que permite escribir documentos en texto plano. Los archivos escritos en Markdown tienen la extensión .md. R Markdown es la variación especifica para R. Permite escribir texto plano con Markdown y adjuntar código proveniente de R. Los archivos escritos en R Markdown tienen la extensión .Rmd. knirt: Paquete de R. Sirve para leer los segmentos de código que queremos introducir en los reportes. Pandoc: Sirve para convertir el output en un archivo con formato word/pdf/html. Es un software que viene instalado automáticamente en 2.8.3.2 Proceso Fuente: https://rmarkdown.rstudio.com/authoring quick tour.html 2.8.3.3 Primer archivo en R Markdown Opciones para elegir el tipo de documento y si quiero confeccionar un documento/presentación/un tablero u otros tipos de archivo más detallados. Opciones para cambiar título y autor(a). 2.8.3.4 Directorio de trabajo El directorio de trabajo de un archivo .Rmd será donde esta guardado el archivo con esa extensión. De este modo, R buscará los archivos en la carpeta en donde este guardado el archivo .Rmd. Para este ejercicio simplemente dejaremos los datos que utilizaremos junto al archivo. 2.8.3.5 Componentes de R Markdown YAML: fijar título, fecha y tipo de output. Markdown text: introducir texto. Code Chunk: cargar paquetes, datos, visualizaciones. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
